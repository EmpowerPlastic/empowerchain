{
  "version": 3,
  "sources": ["../../node_modules/@segment/analytics-next/src/core/connection/index.ts", "../../node_modules/@segment/analytics-next/src/lib/priority-queue/persisted.ts", "../../node_modules/@segment/analytics-next/src/lib/merged-options.ts", "../../node_modules/@segment/analytics-next/src/core/stats/metric-helpers.ts", "../../node_modules/@segment/analytics-next/src/lib/p-while.ts"],
  "sourcesContent": ["import { isBrowser } from '../environment'\n\nexport function isOnline(): boolean {\n  if (isBrowser()) {\n    return window.navigator.onLine\n  }\n\n  return true\n}\n\nexport function isOffline(): boolean {\n  return !isOnline()\n}\n", "import { PriorityQueue } from '.'\nimport { Context, SerializedContext } from '../../core/context'\nimport { isBrowser } from '../../core/environment'\n\nlet loc:\n  | Storage\n  | { getItem: () => void; setItem: () => void; removeItem: () => void } = {\n  getItem() {},\n  setItem() {},\n  removeItem() {},\n}\n\ntry {\n  loc = isBrowser() && window.localStorage ? window.localStorage : loc\n} catch (err) {\n  console.warn('Unable to access localStorage', err)\n}\n\nfunction persisted(key: string): Context[] {\n  const items = loc.getItem(key)\n  return (items ? JSON.parse(items) : []).map(\n    (p: SerializedContext) => new Context(p.event, p.id)\n  )\n}\n\nfunction persistItems(key: string, items: Context[]): void {\n  const existing = persisted(key)\n  const all = [...items, ...existing]\n\n  const merged = all.reduce((acc, item) => {\n    return {\n      ...acc,\n      [item.id]: item,\n    }\n  }, {} as Record<string, Context>)\n\n  loc.setItem(key, JSON.stringify(Object.values(merged)))\n}\n\nfunction seen(key: string): Record<string, number> {\n  const stored = loc.getItem(key)\n  return stored ? JSON.parse(stored) : {}\n}\n\nfunction persistSeen(key: string, memory: Record<string, number>): void {\n  const stored = seen(key)\n\n  loc.setItem(\n    key,\n    JSON.stringify({\n      ...stored,\n      ...memory,\n    })\n  )\n}\n\nfunction remove(key: string): void {\n  loc.removeItem(key)\n}\n\nconst now = (): number => new Date().getTime()\n\nfunction mutex(key: string, onUnlock: Function, attempt = 0): void {\n  const lockTimeout = 50\n  const lockKey = `persisted-queue:v1:${key}:lock`\n\n  const expired = (lock: number): boolean => new Date().getTime() > lock\n  const rawLock = loc.getItem(lockKey)\n  const lock = rawLock ? (JSON.parse(rawLock) as number) : null\n\n  const allowed = lock === null || expired(lock)\n  if (allowed) {\n    loc.setItem(lockKey, JSON.stringify(now() + lockTimeout))\n    onUnlock()\n    loc.removeItem(lockKey)\n    return\n  }\n\n  if (!allowed && attempt < 3) {\n    setTimeout(() => {\n      mutex(key, onUnlock, attempt + 1)\n    }, lockTimeout)\n  } else {\n    console.error('Unable to retrieve lock')\n  }\n}\n\nexport class PersistedPriorityQueue extends PriorityQueue<Context> {\n  constructor(maxAttempts: number, key: string) {\n    super(maxAttempts, [])\n\n    const itemsKey = `persisted-queue:v1:${key}:items`\n    const seenKey = `persisted-queue:v1:${key}:seen`\n\n    let saved: Context[] = []\n    let lastSeen: Record<string, number> = {}\n\n    mutex(key, () => {\n      try {\n        saved = persisted(itemsKey)\n        lastSeen = seen(seenKey)\n        remove(itemsKey)\n        remove(seenKey)\n\n        this.queue = [...saved, ...this.queue]\n        this.seen = { ...lastSeen, ...this.seen }\n      } catch (err) {\n        console.error(err)\n      }\n    })\n\n    window.addEventListener('pagehide', () => {\n      // we deliberately want to use the less powerful 'pagehide' API to only persist on events where the analytics instance gets destroyed, and not on tab away.\n      if (this.todo > 0) {\n        const items = [...this.queue, ...this.future]\n        try {\n          mutex(key, () => {\n            persistItems(itemsKey, items)\n            persistSeen(seenKey, this.seen)\n          })\n        } catch (err) {\n          console.error(err)\n        }\n      }\n    })\n  }\n}\n", "import { JSONObject, Options } from '../core/events/interfaces'\nimport { LegacySettings } from '../browser'\n\n/**\n * Merge legacy settings and initialized Integration option overrides.\n *\n * This will merge any options that were passed from initialization into\n * overrides for settings that are returned by the Segment CDN.\n *\n * i.e. this allows for passing options directly into destinations from\n * the Analytics constructor.\n */\nexport function mergedOptions(\n  settings: LegacySettings,\n  options: Options\n): Record<string, JSONObject> {\n  const optionOverrides = Object.entries(options.integrations ?? {}).reduce(\n    (overrides, [integration, options]) => {\n      if (typeof options === 'object') {\n        return {\n          ...overrides,\n          [integration]: options,\n        }\n      }\n\n      return {\n        ...overrides,\n        [integration]: {},\n      }\n    },\n    {} as Record<string, JSONObject>\n  )\n\n  return Object.entries(settings.integrations).reduce(\n    (integrationSettings, [integration, settings]) => {\n      return {\n        ...integrationSettings,\n        [integration]: {\n          ...settings,\n          ...optionOverrides[integration],\n        },\n      }\n    },\n    {} as Record<string, JSONObject>\n  )\n}\n", "import { Context } from '../context'\n\nexport interface RecordIntegrationMetricProps {\n  integrationName: string\n  methodName: string\n  didError?: boolean\n  type: 'classic' | 'action'\n}\n\nexport function recordIntegrationMetric(\n  ctx: Context,\n  {\n    methodName,\n    integrationName,\n    type,\n    didError = false,\n  }: RecordIntegrationMetricProps\n): void {\n  ctx.stats.increment(\n    `analytics_js.integration.invoke${didError ? '.error' : ''}`,\n    1,\n    [\n      `method:${methodName}`,\n      `integration_name:${integrationName}`,\n      `type:${type}`,\n    ]\n  )\n}\n", "export const pWhile = async <T>(\n  condition: (value: T | undefined) => boolean,\n  action: () => T | PromiseLike<T>\n): Promise<void> => {\n  const loop = async (actionResult: T | undefined): Promise<void> => {\n    if (condition(actionResult)) {\n      return loop(await action())\n    }\n  }\n\n  return loop(undefined)\n}\n"],
  "mappings": "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",
  "names": ["lock", "PersistedPriorityQueue", "_a", "options", "settings", "_a"]
}
