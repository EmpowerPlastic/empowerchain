{
  "version": 3,
  "sources": ["../../node_modules/obj-case/index.js", "../../node_modules/@segment/facade/lib/address.js", "../../node_modules/@segment/facade/lib/clone.js", "../../node_modules/@segment/facade/lib/is-enabled.js", "../../node_modules/@segment/isodate/lib/index.js", "../../node_modules/new-date/lib/milliseconds.js", "../../node_modules/new-date/lib/seconds.js", "../../node_modules/new-date/lib/index.js", "../../node_modules/@segment/isodate-traverse/lib/index.js", "../../node_modules/@segment/facade/lib/facade.js", "../../node_modules/@segment/facade/lib/alias.js", "../../node_modules/@segment/facade/lib/is-email.js", "../../node_modules/@segment/facade/lib/group.js", "../../node_modules/@segment/facade/lib/identify.js", "../../node_modules/@segment/facade/lib/track.js", "../../node_modules/@segment/facade/lib/page.js", "../../node_modules/@segment/facade/lib/screen.js", "../../node_modules/@segment/facade/lib/delete.js", "../../node_modules/@segment/facade/lib/index.js", "../../node_modules/unfetch/src/index.mjs", "../../node_modules/@segment/analytics-next/src/lib/get-global.ts", "../../node_modules/@segment/analytics-next/src/lib/fetch.ts", "../../node_modules/@segment/analytics-next/src/generated/version.ts", "../../node_modules/@segment/analytics-next/src/lib/version-type.ts", "../../node_modules/@segment/analytics-next/src/core/constants/index.ts", "../../node_modules/@segment/analytics-next/src/core/stats/remote-metrics.ts", "../../node_modules/@segment/analytics-next/src/core/stats/index.ts", "../../node_modules/@segment/analytics-next/src/core/context/index.ts", "../../node_modules/@segment/analytics-next/src/lib/to-facade.ts", "../../node_modules/@segment/analytics-next/src/plugins/middleware/index.ts"],
  "sourcesContent": ["\nvar identity = function(_){ return _; };\n\n\n/**\n * Module exports, export\n */\n\nmodule.exports = multiple(find);\nmodule.exports.find = module.exports;\n\n\n/**\n * Export the replacement function, return the modified object\n */\n\nmodule.exports.replace = function (obj, key, val, options) {\n  multiple(replace).call(this, obj, key, val, options);\n  return obj;\n};\n\n\n/**\n * Export the delete function, return the modified object\n */\n\nmodule.exports.del = function (obj, key, options) {\n  multiple(del).call(this, obj, key, null, options);\n  return obj;\n};\n\n\n/**\n * Compose applying the function to a nested key\n */\n\nfunction multiple (fn) {\n  return function (obj, path, val, options) {\n    var normalize = options && isFunction(options.normalizer) ? options.normalizer : defaultNormalize;\n    path = normalize(path);\n\n    var key;\n    var finished = false;\n\n    while (!finished) loop();\n\n    function loop() {\n      for (key in obj) {\n        var normalizedKey = normalize(key);\n        if (0 === path.indexOf(normalizedKey)) {\n          var temp = path.substr(normalizedKey.length);\n          if (temp.charAt(0) === '.' || temp.length === 0) {\n            path = temp.substr(1);\n            var child = obj[key];\n\n            // we're at the end and there is nothing.\n            if (null == child) {\n              finished = true;\n              return;\n            }\n\n            // we're at the end and there is something.\n            if (!path.length) {\n              finished = true;\n              return;\n            }\n\n            // step into child\n            obj = child;\n\n            // but we're done here\n            return;\n          }\n        }\n      }\n\n      key = undefined;\n      // if we found no matching properties\n      // on the current object, there's no match.\n      finished = true;\n    }\n\n    if (!key) return;\n    if (null == obj) return obj;\n\n    // the `obj` and `key` is one above the leaf object and key, so\n    // start object: { a: { 'b.c': 10 } }\n    // end object: { 'b.c': 10 }\n    // end key: 'b.c'\n    // this way, you can do `obj[key]` and get `10`.\n    return fn(obj, key, val);\n  };\n}\n\n\n/**\n * Find an object by its key\n *\n * find({ first_name : 'Calvin' }, 'firstName')\n */\n\nfunction find (obj, key) {\n  if (obj.hasOwnProperty(key)) return obj[key];\n}\n\n\n/**\n * Delete a value for a given key\n *\n * del({ a : 'b', x : 'y' }, 'X' }) -> { a : 'b' }\n */\n\nfunction del (obj, key) {\n  if (obj.hasOwnProperty(key)) delete obj[key];\n  return obj;\n}\n\n\n/**\n * Replace an objects existing value with a new one\n *\n * replace({ a : 'b' }, 'a', 'c') -> { a : 'c' }\n */\n\nfunction replace (obj, key, val) {\n  if (obj.hasOwnProperty(key)) obj[key] = val;\n  return obj;\n}\n\n/**\n * Normalize a `dot.separated.path`.\n *\n * A.HELL(!*&#(!)O_WOR   LD.bar => ahelloworldbar\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction defaultNormalize(path) {\n  return path.replace(/[^a-zA-Z0-9\\.]+/g, '').toLowerCase();\n}\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @return {boolean} Returns `true` if `val` is a function, otherwise `false`.\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n", "\"use strict\";\n\nimport get from \"obj-case\";\n\nfunction trait(a, b) {\n  return function () {\n    // @ts-ignore\n    let traits = this.traits();\n    // @ts-ignore\n    let props = this.properties ? this.properties() : {};\n\n    return (\n      get(traits, \"address.\" + a) ||\n      get(traits, a) ||\n      (b ? get(traits, \"address.\" + b) : null) ||\n      (b ? get(traits, b) : null) ||\n      get(props, \"address.\" + a) ||\n      get(props, a) ||\n      (b ? get(props, \"address.\" + b) : null) ||\n      (b ? get(props, b) : null)\n    );\n  };\n}\n\n/**\n * Add address getters to `proto`.\n *\n * @ignore\n * @param {Function} proto\n */\nexport default function (proto) {\n  proto.zip = trait(\"postalCode\", \"zip\");\n  proto.country = trait(\"country\");\n  proto.street = trait(\"street\");\n  proto.state = trait(\"state\");\n  proto.city = trait(\"city\");\n  proto.region = trait(\"region\");\n}\n", "export function clone(properties) {\n  if (typeof properties !== 'object') return properties\n\n  if (Object.prototype.toString.call(properties) === '[object Object]') {\n    const temp = {};\n    for (const key in properties) {\n      if (Object.prototype.hasOwnProperty.call(properties, key)) {\n        temp[key] = clone(properties[key]);\n      }\n    }\n    return temp;\n  } else if (Array.isArray(properties)) {\n    return properties.map(clone);\n  } else {\n    // this is dangerous because it means this is not cloned\n    return properties;\n  }\n}\n", "\"use strict\";\n\n// A few integrations are disabled by default. They must be explicitly enabled\n// by setting options[Provider] = true.\nlet disabled = {\n  Salesforce: true,\n};\n\n/**\n * Check whether an integration should be enabled by default.\n *\n * @ignore\n * @param {string} integration\n * @return {boolean}\n */\nexport default function (integration) {\n  return !disabled[integration];\n}\n", "'use strict';\n\n/**\n * Matcher, slightly modified from:\n *\n * https://github.com/csnover/js-iso8601/blob/lax/iso8601.js\n */\n\nvar matcher = /^(\\d{4})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:([ T])(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,\\.](\\d{1,}))?)?(?:(Z)|([+\\-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\n\n/**\n * Convert an ISO date string to a date. Fallback to native `Date.parse`.\n *\n * https://github.com/csnover/js-iso8601/blob/lax/iso8601.js\n *\n * @param {String} iso\n * @return {Date}\n */\n\nexports.parse = function(iso) {\n  var numericKeys = [1, 5, 6, 7, 11, 12];\n  var arr = matcher.exec(iso);\n  var offset = 0;\n\n  // fallback to native parsing\n  if (!arr) {\n    return new Date(iso);\n  }\n\n  /* eslint-disable no-cond-assign */\n  // remove undefined values\n  for (var i = 0, val; val = numericKeys[i]; i++) {\n    arr[val] = parseInt(arr[val], 10) || 0;\n  }\n  /* eslint-enable no-cond-assign */\n\n  // allow undefined days and months\n  arr[2] = parseInt(arr[2], 10) || 1;\n  arr[3] = parseInt(arr[3], 10) || 1;\n\n  // month is 0-11\n  arr[2]--;\n\n  // allow abitrary sub-second precision\n  arr[8] = arr[8] ? (arr[8] + '00').substring(0, 3) : 0;\n\n  // apply timezone if one exists\n  if (arr[4] === ' ') {\n    offset = new Date().getTimezoneOffset();\n  } else if (arr[9] !== 'Z' && arr[10]) {\n    offset = arr[11] * 60 + arr[12];\n    if (arr[10] === '+') {\n      offset = 0 - offset;\n    }\n  }\n\n  var millis = Date.UTC(arr[1], arr[2], arr[3], arr[5], arr[6] + offset, arr[7], arr[8]);\n  return new Date(millis);\n};\n\n\n/**\n * Checks whether a `string` is an ISO date string. `strict` mode requires that\n * the date string at least have a year, month and date.\n *\n * @param {String} string\n * @param {Boolean} strict\n * @return {Boolean}\n */\n\nexports.is = function(string, strict) {\n  if (typeof string !== 'string') {\n    return false;\n  }\n  if (strict && (/^\\d{4}-\\d{2}-\\d{2}/).test(string) === false) {\n    return false;\n  }\n  return matcher.test(string);\n};\n", "\"use strict\";\n\n/**\n * Matcher.\n */\n\nvar matcher = /\\d{13}/;\n\n/**\n * Check whether a string is a millisecond date string.\n *\n * @param {string} string\n * @return {boolean}\n */\nexports.is = function (string) {\n  return matcher.test(string);\n};\n\n/**\n * Convert a millisecond string to a date.\n *\n * @param {string} millis\n * @return {Date}\n */\nexports.parse = function (millis) {\n  millis = parseInt(millis, 10);\n  return new Date(millis);\n};\n", "\"use strict\";\n\n/**\n * Matcher.\n */\n\nvar matcher = /\\d{10}/;\n\n/**\n * Check whether a string is a second date string.\n *\n * @param {string} string\n * @return {Boolean}\n */\nexports.is = function (string) {\n  return matcher.test(string);\n};\n\n/**\n * Convert a second string to a date.\n *\n * @param {string} seconds\n * @return {Date}\n */\nexports.parse = function (seconds) {\n  var millis = parseInt(seconds, 10) * 1000;\n  return new Date(millis);\n};\n", "\"use strict\";\n\nvar isodate = require(\"@segment/isodate\");\nvar milliseconds = require(\"./milliseconds\");\nvar seconds = require(\"./seconds\");\n\nvar objProto = Object.prototype;\nvar toStr = objProto.toString;\n\nfunction isDate(value) {\n  return toStr.call(value) === \"[object Date]\";\n}\n\nfunction isNumber(value) {\n  return toStr.call(value) === \"[object Number]\";\n}\n\n/**\n * Returns a new Javascript Date object, allowing a variety of extra input types\n * over the native Date constructor.\n *\n * @param {Date|string|number} val\n */\nmodule.exports = function newDate(val) {\n  if (isDate(val)) return val;\n  if (isNumber(val)) return new Date(toMs(val));\n\n  // date strings\n  if (isodate.is(val)) {\n    return isodate.parse(val);\n  }\n  if (milliseconds.is(val)) {\n    return milliseconds.parse(val);\n  }\n  if (seconds.is(val)) {\n    return seconds.parse(val);\n  }\n\n  // fallback to Date.parse\n  return new Date(val);\n};\n\n/**\n * If the number passed val is seconds from the epoch, turn it into milliseconds.\n * Milliseconds would be greater than 31557600000 (December 31, 1970).\n *\n * @param {number} num\n */\nfunction toMs(num) {\n  if (num < 31557600000) return num * 1000;\n  return num;\n}\n", "'use strict';\n\nvar isodate = require('@segment/isodate');\n\n/**\n * Expose `traverse`.\n */\nmodule.exports = traverse;\n\n/**\n * Recursively traverse an object or array, and convert\n * all ISO date strings parse into Date objects.\n *\n * @param {Object} input - object, array, or string to convert\n * @param {Boolean} strict - only convert strings with year, month, and date\n * @return {Object}\n */\nfunction traverse(input, strict) {\n  if (strict === undefined) strict = true;\n  if (input && typeof input === 'object') {\n    return traverseObject(input, strict);\n  } else if (Array.isArray(input)) {\n    return traverseArray(input, strict);\n  } else if (isodate.is(input, strict)) {\n    return isodate.parse(input);\n  }\n  return input;\n}\n\n/**\n * Object traverser helper function.\n *\n * @param {Object} obj - object to traverse\n * @param {Boolean} strict - only convert strings with year, month, and date\n * @return {Object}\n */\nfunction traverseObject(obj, strict) {\n  Object.keys(obj).forEach(function(key) {\n    obj[key] = traverse(obj[key], strict);\n  });\n  return obj;\n}\n\n/**\n * Array traverser helper function\n *\n * @param {Array} arr - array to traverse\n * @param {Boolean} strict - only convert strings with year, month, and date\n * @return {Array}\n */\nfunction traverseArray(arr, strict) {\n  arr.forEach(function(value, index) {\n    arr[index] = traverse(value, strict);\n  });\n  return arr;\n}\n", "\"use strict\";\n\nimport address from \"./address\";\nimport { clone } from \"./clone\";\nimport isEnabled from \"./is-enabled\";\nimport newDate from \"new-date\";\nimport objCase from \"obj-case\";\nimport traverse from \"@segment/isodate-traverse\";\n\n/**\n * A *Facade* is an object meant for creating convience wrappers around\n * objects. When developing integrations, you probably want to look at its\n * subclasses, such as {@link Track} or {@link Identify}, rather than this\n * general-purpose class.\n *\n * This letructor will initialize a new `Facade` with an `obj` of arguments.\n *\n * If the inputted `obj` doesn't have a `timestamp` property, one will be added\n * with the value `new Date()`. Otherwise, the `timestamp` property will be\n * converted to a Date using the `new-date` package.\n *\n * By default, the inputted object will be defensively copied, and all ISO\n * strings present in the string will be converted into Dates.\n *\n * @param {Object} obj - The object to wrap.\n * @param {Object} opts - Options about what kind of Facade to create.\n * @param {boolean} [opts.clone=true] - Whether to make defensive clones. If enabled,\n * the inputted object will be cloned, and any objects derived from this facade\n * will be cloned before being returned.\n * @param {boolean} [opts.traverse=true] - Whether to perform ISODate-Traverse\n * on the inputted object.\n *\n * @see {@link https://github.com/segmentio/new-date|new-date}\n * @see {@link https://github.com/segmentio/isodate-traverse|isodate-traverse}\n */\nexport function Facade (obj, opts) {\n  opts = opts || {};\n  this.raw = clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();\n  else obj.timestamp = newDate(obj.timestamp);\n  if (opts.traverse) traverse(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\n\nconst f = Facade.prototype;\n\n/**\n * Get a potentially-nested field in this facade. `field` should be a\n * period-separated sequence of properties.\n *\n * If the first field passed in points to a function (e.g. the `field` passed\n * in is `a.b.c` and this facade's `obj.a` is a function), then that function\n * will be called, and then the deeper fields will be fetched (using obj-case)\n * from what that function returns. If the first field isn't a function, then\n * this function works just like obj-case.\n *\n * Because this function uses obj-case, the camel- or snake-case of the input\n * is irrelevant.\n *\n * @example\n * YourClass.prototype.height = function() {\n *   return this.proxy('getDimensions.height') ||\n *     this.proxy('props.size.side_length');\n * }\n * @param {string} field - A sequence of properties, joined by periods (`.`).\n * @return {*} - A property of the inputted object.\n * @see {@link https://github.com/segmentio/obj-case|obj-case}\n */\nf.proxy = function(field) {\n  let fields = field.split(\".\");\n  field = fields.shift();\n\n  // Call a function at the beginning to take advantage of facaded fields\n  let obj = this[field] || this.obj[field];\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n\n  obj = objCase(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Directly access a specific `field` from the underlying object. Only\n * \"top-level\" fields will work with this function. \"Nested\" fields *will not\n * work* with this function.\n *\n * @param {string} field\n * @return {*}\n */\nf.field = function(field) {\n  let obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Utility method to always proxy a particular `field`. In other words, it\n * returns a function that will always return `this.proxy(field)`.\n *\n * @example\n * MyClass.prototype.height = Facade.proxy('options.dimensions.height');\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.proxy = function(field) {\n  return function() {\n    return this.proxy(field);\n  };\n};\n\n/**\n * Utility method to always access a `field`. In other words, it returns a\n * function that will always return `this.field(field)`.\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.field = function(field) {\n  return function() {\n    return this.field(field);\n  };\n};\n\n/**\n * Create a helper function for fetching a \"plural\" thing.\n *\n * The generated method will take the inputted `path` and append an \"s\" to it\n * and calls `this.proxy` with this \"pluralized\" path. If that produces an\n * array, that will be returned. Otherwise, a one-element array containing\n * `this.proxy(path)` will be returned.\n *\n * @example\n * MyClass.prototype.birds = Facade.multi('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.multi = function(path) {\n  return function() {\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    let one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone(one) : one];\n    return one || [];\n  };\n};\n\n/**\n * Create a helper function for getting a \"singular\" thing.\n *\n * The generated method will take the inputted path and call\n * `this.proxy(path)`. If a truthy thing is produced, it will be returned.\n * Otherwise, `this.proxy(path + 's')` will be called, and if that produces an\n * array the first element of that array will be returned. Otherwise,\n * `undefined` is returned.\n *\n * @example\n * MyClass.prototype.bird = Facade.one('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.one = function(path) {\n  return function() {\n    let one = this.proxy(path);\n    if (one) return one;\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\n\n/**\n * Gets the underlying object this facade wraps around.\n *\n * If this facade has a property `type`, it will be invoked as a function and\n * will be assigned as the property `type` of the outputted object.\n *\n * @return {Object}\n */\nf.json = function() {\n  let ret = this.opts.clone ? clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\n\n/**\n * Gets a copy of the unmodified input object this facade wraps around.\n * \n * Unlike the `json` method which does make some subtle modifications \n * to datetime values and the `type` property. This method returns a copy of \n * the unmodified input object\n * \n * @return {Object}\n */\nf.rawEvent = function() {\n  return this.raw;\n};\n\n/**\n * Get the options of a call. If an integration is passed, only the options for\n * that integration are included. If the integration is not enabled, then\n * `undefined` is returned.\n *\n * Options are taken from the `options` property of the underlying object,\n * falling back to the object's `context` or simply `{}`.\n *\n * @param {string} integration - The name of the integration to get settings\n * for. Casing does not matter.\n * @return {Object|undefined}\n */\nf.options = function(integration) {\n  let obj = this.obj.options || this.obj.context || {};\n  let options = this.opts.clone ? clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  let integrations = this.integrations();\n  let value = integrations[integration] || objCase(integrations, integration);\n  if (typeof value !== \"object\") value = objCase(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\n\n/**\n * An alias for {@link Facade#options}.\n */\nf.context = f.options;\n\n/**\n * Check whether an integration is enabled.\n *\n * Basically, this method checks whether this integration is explicitly\n * enabled. If it isn'texplicitly mentioned, it checks whether it has been\n * enabled at the global level. Some integrations (e.g. Salesforce), cannot\n * enabled by these global event settings.\n *\n * More concretely, the deciding factors here are:\n *\n * 1. If `this.integrations()` has the integration set to `true`, return `true`.\n * 2. If `this.integrations().providers` has the integration set to `true`, return `true`.\n * 3. If integrations are set to default-disabled via global parameters (i.e.\n * `options.providers.all`, `options.all`, or `integrations.all`), then return\n * false.\n * 4. If the integration is one of the special default-deny integrations\n * (currently, only Salesforce), then return false.\n * 5. Else, return true.\n *\n * @param {string} integration\n * @return {boolean}\n */\nf.enabled = function(integration) {\n  let allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\")\n    allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n\n  let enabled = allEnabled && isEnabled(integration);\n  let options = this.integrations();\n\n  // If the integration is explicitly enabled or disabled, use that\n  // First, check options.providers for backwards compatibility\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n\n  // Next, check for the integration's existence in 'options' to enable it.\n  // If the settings are a boolean, use that, otherwise it should be enabled.\n  if (options.hasOwnProperty(integration)) {\n    let settings = options[integration];\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n\n  return !!enabled;\n};\n\n/**\n * Get all `integration` options.\n *\n * @ignore\n * @param {string} integration\n * @return {Object}\n */\nf.integrations = function() {\n  return (\n    this.obj.integrations || this.proxy(\"options.providers\") || this.options()\n  );\n};\n\n/**\n * Check whether the user is active.\n *\n * @return {boolean}\n */\nf.active = function() {\n  let active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\n\n/**\n * Get `sessionId / anonymousId`.\n *\n * @return {*}\n */\nf.anonymousId = function() {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\n\n/**\n * An alias for {@link Facade#anonymousId}.\n *\n * @function\n * @return {string}\n */\nf.sessionId = f.anonymousId;\n\n/**\n * Get `groupId` from `context.groupId`.\n *\n * @function\n * @return {string}\n */\nf.groupId = Facade.proxy(\"options.groupId\");\n\n/**\n * Get the call's \"traits\". All event types can pass in traits, though {@link\n * Identify} and {@link Group} override this implementation.\n *\n * Traits are gotten from `options.traits`, augmented with a property `id` with\n * the event's `userId`.\n *\n * The parameter `aliases` is meant to transform keys in `options.traits` into\n * new keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx`\n * in the traits, and move it to `yyy`. If `xxx` is a method of this facade,\n * it'll be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { options: { traits: { foo: \"bar\" } }, anonymousId: \"xxx\" }\n * let facade = new Facade(obj)\n *\n * facade.traits() // { \"foo\": \"bar\" }\n * facade.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * facade.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\nf.traits = function(aliases) {\n  let ret = this.proxy(\"options.traits\") || {};\n  let id = this.userId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"options.traits.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * The library and version of the client used to produce the message.\n *\n * If the library name cannot be determined, it is set to `\"unknown\"`. If the\n * version cannot be determined, it is set to `null`.\n *\n * @return {{name: string, version: string}}\n */\nf.library = function() {\n  let library = this.proxy(\"options.library\");\n  if (!library) return { name: \"unknown\", version: null };\n  if (typeof library === \"string\") return { name: library, version: null };\n  return library;\n};\n\n/**\n * Return the device information, falling back to an empty object.\n *\n * Interesting values of `type` are `\"ios\"` and `\"android\"`, but other values\n * are possible if the client is doing something unusual with `context.device`.\n *\n * @return {{type: string}}\n */\nf.device = function() {\n  let device = this.proxy(\"context.device\");\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n  let library = this.library().name;\n  if (device.type) return device;\n\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\n\n/**\n * Get the User-Agent from `context.userAgent`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userAgent = Facade.proxy(\"context.userAgent\");\n\n/**\n * Get the timezone from `context.timezone`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.timezone = Facade.proxy(\"context.timezone\");\n\n/**\n * Get the timestamp from `context.timestamp`.\n *\n * @function\n * @return string\n */\nf.timestamp = Facade.field(\"timestamp\");\n\n/**\n * Get the channel from `channel`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.channel = Facade.field(\"channel\");\n\n/**\n * Get the IP address from `context.ip`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.ip = Facade.proxy(\"context.ip\");\n\n/**\n * Get the user ID from `userId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userId = Facade.field(\"userId\");\n\n/**\n * Get the ZIP/Postal code from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name zip\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the country from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name country\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the street from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name street\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the state from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name state\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the city from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name city\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the region from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name region\n * @function\n * @memberof f\n * @return {string}\n */\n\naddress(f);\n\n/**\n * Return the cloned and traversed object\n *\n * @ignore\n * @param {*} obj\n * @return {*}\n */\nfunction transform (obj) {\n  return clone(obj);\n}\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\n\n/**\n * Initialize a new `Alias` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.from] - The previous ID of the user.\n * @param {string} [dictionary.to] - The new ID of the user.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Alias(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Alias, Facade);\n\n/**\n * Return the type of facade this is. This will always return `\"alias\"`.\n *\n * @return {string}\n */\nAlias.prototype.action = function () {\n  return \"alias\";\n};\n\n/**\n * An alias for {@link Alias#action}.\n *\n * @function\n * @return {string}\n */\nAlias.prototype.type = Alias.prototype.action;\n\n/**\n * Get the user's previous ID from `previousId` or `from`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nAlias.prototype.previousId = function () {\n  return this.field(\"previousId\") || this.field(\"from\");\n};\n\n/**\n * An alias for {@link Alias#previousId}.\n *\n * @function\n * @return {string}\n */\nAlias.prototype.from = Alias.prototype.previousId;\n\n/**\n * Get the user's new ID from `userId` or `to`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nAlias.prototype.userId = function () {\n  return this.field(\"userId\") || this.field(\"to\");\n};\n\n/**\n * An alias for {@link Alias#userId}.\n *\n * @function\n * @return {string}\n */\nAlias.prototype.to = Alias.prototype.userId;\n", "const matcher = /.+\\@.+\\..+/;\n\nexport default function isEmail(string) {\n  return matcher.test(string);\n}\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport isEmail from \"./is-email\";\nimport newDate from \"new-date\";\nimport { Facade } from \"./facade\";\n\n/**\n * Initialize a new `Group` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.userId] - The user to add to the group.\n * @param {string} [dictionary.groupId] - The ID of the group.\n * @param {Object} [dictionary.traits] - The traits of the group.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Group(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Group, Facade);\n\nconst g = Group.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"group\"`.\n *\n * @return {string}\n */\ng.action = function () {\n  return \"group\";\n};\n\n/**\n * An alias for {@link Group#action}.\n *\n * @function\n * @return {string}\n */\ng.type = g.action;\n\n/**\n * Get the group ID from `groupId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ng.groupId = Facade.field(\"groupId\");\n\n/**\n * Get the time of creation of the group from `traits.createdAt`,\n * `traits.created`, `properties.createdAt`, or `properties.created`.\n *\n * @return {Date}\n */\ng.created = function () {\n  var created =\n    this.proxy(\"traits.createdAt\") ||\n    this.proxy(\"traits.created\") ||\n    this.proxy(\"properties.createdAt\") ||\n    this.proxy(\"properties.created\");\n\n  if (created) return newDate(created);\n};\n\n/**\n * Get the group's email from `traits.email`, falling back to `groupId` only if\n * it looks like a valid email.\n *\n * @return {string}\n */\ng.email = function () {\n  var email = this.proxy(\"traits.email\");\n  if (email) return email;\n  var groupId = this.groupId();\n  if (isEmail(groupId)) return groupId;\n};\n\n/**\n * Get the group's traits. This is identical to how {@link Facade#traits}\n * works, except it looks at `traits.*` instead of `options.traits.*`.\n *\n * Traits are gotten from `traits`, augmented with a property `id` with\n * the event's `groupId`.\n *\n * The parameter `aliases` is meant to transform keys in `traits` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * var obj = { traits: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * var group = new Group(obj)\n *\n * group.traits() // { \"foo\": \"bar\" }\n * group.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * group.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\ng.traits = function (aliases) {\n  var ret = this.properties();\n  var id = this.groupId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"traits.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Get the group's name from `traits.name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ng.name = Facade.proxy(\"traits.name\");\n\n/**\n * Get the group's industry from `traits.industry`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ng.industry = Facade.proxy(\"traits.industry\");\n\n/**\n * Get the group's employee count from `traits.employees`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\ng.employees = Facade.proxy(\"traits.employees\");\n\n/**\n * Get the group's properties from `traits` or `properties`, falling back to\n * simply an empty object.\n *\n * @return {Object}\n */\ng.properties = function () {\n  // TODO remove this function\n  return this.field(\"traits\") || this.field(\"properties\") || {};\n};\n", "\"use strict\";\n\nimport { Facade } from \"./facade\";\nimport get from \"obj-case\";\nimport inherit from \"inherits\";\nimport isEmail from \"./is-email\";\nimport newDate from \"new-date\";\n\nlet trim = (str) => str.trim();\n\n/**\n * Initialize a new `Identify` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.userId] - The ID of the user.\n * @param {string} [dictionary.anonymousId] - The anonymous ID of the user.\n * @param {string} [dictionary.traits] - The user's traits.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Identify(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Identify, Facade);\n\nconst i = Identify.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"identify\"`.\n *\n * @return {string}\n */\ni.action = function () {\n  return \"identify\";\n};\n\n/**\n * An alias for {@link Identify#action}.\n *\n * @function\n * @return {string}\n */\ni.type = i.action;\n\n/**\n * Get the user's traits. This is identical to how {@link Facade#traits} works,\n * except it looks at `traits.*` instead of `options.traits.*`.\n *\n * Traits are gotten from `traits`, augmented with a property `id` with\n * the event's `userId`.\n *\n * The parameter `aliases` is meant to transform keys in `traits` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { traits: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let identify = new Identify(obj)\n *\n * identify.traits() // { \"foo\": \"bar\" }\n * identify.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * identify.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\ni.traits = function (aliases) {\n  let ret = this.field(\"traits\") || {};\n  let id = this.userId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (let alias in aliases) {\n    let value =\n      this[alias] == null ? this.proxy(\"traits.\" + alias) : this[alias]();\n    if (value == null) continue;\n    ret[aliases[alias]] = value;\n    if (alias !== aliases[alias]) delete ret[alias];\n  }\n\n  return ret;\n};\n\n/**\n * Get the user's email from `traits.email`, falling back to `userId` only if\n * it looks like a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.email = function () {\n  let email = this.proxy(\"traits.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the time of creation of the user from `traits.created` or\n * `traits.createdAt`.\n *\n * @return {Date}\n */\ni.created = function () {\n  let created = this.proxy(\"traits.created\") || this.proxy(\"traits.createdAt\");\n  if (created) return newDate(created);\n};\n\n/**\n * Get the time of creation of the user's company from `traits.company.created`\n * or `traits.company.createdAt`.\n *\n * @return {Date}\n */\ni.companyCreated = function () {\n  let created =\n    this.proxy(\"traits.company.created\") ||\n    this.proxy(\"traits.company.createdAt\");\n\n  if (created) {\n    return newDate(created);\n  }\n};\n\n/**\n * Get the user's company name from `traits.company.name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.companyName = function () {\n  return this.proxy(\"traits.company.name\");\n};\n\n/**\n * Get the user's name `traits.name`, falling back to combining {@link\n * Identify#firstName} and {@link Identify#lastName} if possible.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.name = function () {\n  let name = this.proxy(\"traits.name\");\n  if (typeof name === \"string\") {\n    return trim(name);\n  }\n\n  let firstName = this.firstName();\n  let lastName = this.lastName();\n  if (firstName && lastName) {\n    return trim(firstName + \" \" + lastName);\n  }\n};\n\n/**\n * Get the user's first name from `traits.firstName`, optionally splitting it\n * out of a the full name if that's all that was provided.\n *\n * Splitting the full name works on the assumption that the full name is of the\n * form \"FirstName LastName\"; it will not work for non-Western names.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.firstName = function () {\n  let firstName = this.proxy(\"traits.firstName\");\n  if (typeof firstName === \"string\") {\n    return trim(firstName);\n  }\n\n  let name = this.proxy(\"traits.name\");\n  if (typeof name === \"string\") {\n    return trim(name).split(\" \")[0];\n  }\n};\n\n/**\n * Get the user's last name from `traits.lastName`, optionally splitting it out\n * of a the full name if that's all that was provided.\n *\n * Splitting the full name works on the assumption that the full name is of the\n * form \"FirstName LastName\"; it will not work for non-Western names.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.lastName = function () {\n  let lastName = this.proxy(\"traits.lastName\");\n  if (typeof lastName === \"string\") {\n    return trim(lastName);\n  }\n\n  let name = this.proxy(\"traits.name\");\n  if (typeof name !== \"string\") {\n    return;\n  }\n\n  let space = trim(name).indexOf(\" \");\n  if (space === -1) {\n    return;\n  }\n\n  return trim(name.substr(space + 1));\n};\n\n/**\n * Get the user's \"unique id\" from `userId`, `traits.username`, or\n * `traits.email`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.uid = function () {\n  return this.userId() || this.username() || this.email();\n};\n\n/**\n * Get the user's description from `traits.description` or `traits.background`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.description = function () {\n  return this.proxy(\"traits.description\") || this.proxy(\"traits.background\");\n};\n\n/**\n * Get the user's age from `traits.age`, falling back to computing it from\n * `traits.birthday` and the current time.\n *\n * @return {number}\n */\ni.age = function () {\n  let date = this.birthday();\n  let age = get(this.traits(), \"age\");\n  if (age != null) return age;\n  if (!(date instanceof Date)) return;\n  let now = new Date();\n  return now.getFullYear() - date.getFullYear();\n};\n\n/**\n * Get the URL of the user's avatar from `traits.avatar`, `traits.photoUrl`, or\n * `traits.avatarUrl`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.avatar = function () {\n  let traits = this.traits();\n  return (\n    get(traits, \"avatar\") || get(traits, \"photoUrl\") || get(traits, \"avatarUrl\")\n  );\n};\n\n/**\n * Get the user's job position from `traits.position` or `traits.jobTitle`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\ni.position = function () {\n  let traits = this.traits();\n  return get(traits, \"position\") || get(traits, \"jobTitle\");\n};\n\n/**\n * Get the user's username from `traits.username`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ni.username = Facade.proxy(\"traits.username\");\n\n/**\n * Get the user's website from `traits.website`, or if there are multiple in\n * `traits.websites`, return the first one.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ni.website = Facade.one(\"traits.website\");\n\n/**\n * Get the user's websites from `traits.websites`, or if there is only one in\n * `traits.website`, then wrap it in an array.\n *\n * This *should* be an array of strings, but may not be if the client isn't\n * adhering to the spec.\n *\n * @function\n * @return {array}\n */\ni.websites = Facade.multi(\"traits.website\");\n\n/**\n * Get the user's phone number from `traits.phone`, or if there are multiple in\n * `traits.phones`, return the first one.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ni.phone = Facade.one(\"traits.phone\");\n\n/**\n * Get the user's phone numbers from `traits.phones`, or if there is only one\n * in `traits.phone`, then wrap it in an array.\n *\n * This *should* be an array of strings, but may not be if the client isn't\n * adhering to the spec.\n *\n * @function\n * @return {array}\n */\ni.phones = Facade.multi(\"traits.phone\");\n\n/**\n * Get the user's address from `traits.address`.\n *\n * This *should* be an object, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {object}\n */\ni.address = Facade.proxy(\"traits.address\");\n\n/**\n * Get the user's gender from `traits.gender`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\ni.gender = Facade.proxy(\"traits.gender\");\n\n/**\n * Get the user's birthday from `traits.birthday`.\n *\n * This *should* be a Date if `opts.traverse` was enabled (it is by default)\n * when letructing this Identify. Otherwise, it should be a string. But it\n * may be neither if the client isn't adhering to the spec.\n * spec.\n *\n * @function\n * @return {object}\n */\ni.birthday = Facade.proxy(\"traits.birthday\");\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\nimport { Identify } from \"./identify\";\nimport isEmail from \"./is-email\";\nimport get from \"obj-case\";\n\n/**\n * Initialize a new `Track` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.event] - The name of the event being tracked.\n * @param {string} [dictionary.userId] - The ID of the user being tracked.\n * @param {string} [dictionary.anonymousId] - The anonymous ID of the user.\n * @param {string} [dictionary.properties] - Properties of the track event.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Track(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Track, Facade);\n\nlet t = Track.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"track\"`.\n *\n * @return {string}\n */\nt.action = function () {\n  return \"track\";\n};\n\n/**\n * An alias for {@link Track#action}.\n *\n * @function\n * @return {string}\n */\nt.type = t.action;\n\n/**\n * Get the event name from `event`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.event = Facade.field(\"event\");\n\n/**\n * Get the event value, usually the monetary value, from `properties.value`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.value = Facade.proxy(\"properties.value\");\n\n/**\n * Get the event cateogry from `properties.category`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.category = Facade.proxy(\"properties.category\");\n\n/**\n * Get the event ID from `properties.id`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.id = Facade.proxy(\"properties.id\");\n\n/**\n * Get the product ID from `properties.productId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.productId = function () {\n  return (\n    this.proxy(\"properties.product_id\") || this.proxy(\"properties.productId\")\n  );\n};\n\n/**\n * Get the promotion ID from `properties.promotionId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.promotionId = function () {\n  return (\n    this.proxy(\"properties.promotion_id\") ||\n    this.proxy(\"properties.promotionId\")\n  );\n};\n\n/**\n * Get the cart ID from `properties.cartId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.cartId = function () {\n  return this.proxy(\"properties.cart_id\") || this.proxy(\"properties.cartId\");\n};\n\n/**\n * Get the checkout ID from `properties.checkoutId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.checkoutId = function () {\n  return (\n    this.proxy(\"properties.checkout_id\") || this.proxy(\"properties.checkoutId\")\n  );\n};\n\n/**\n * Get the payment ID from `properties.paymentId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.paymentId = function () {\n  return (\n    this.proxy(\"properties.payment_id\") || this.proxy(\"properties.paymentId\")\n  );\n};\n\n/**\n * Get the coupon ID from `properties.couponId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.couponId = function () {\n  return (\n    this.proxy(\"properties.coupon_id\") || this.proxy(\"properties.couponId\")\n  );\n};\n\n/**\n * Get the wishlist ID from `properties.wishlistId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.wishlistId = function () {\n  return (\n    this.proxy(\"properties.wishlist_id\") || this.proxy(\"properties.wishlistId\")\n  );\n};\n\n/**\n * Get the review ID from `properties.reviewId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.reviewId = function () {\n  return (\n    this.proxy(\"properties.review_id\") || this.proxy(\"properties.reviewId\")\n  );\n};\n\n/**\n * Get the order ID from `properties.id` or `properties.orderId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.orderId = function () {\n  // doesn't follow above convention since this fallback order was how it used to be\n  return (\n    this.proxy(\"properties.id\") ||\n    this.proxy(\"properties.order_id\") ||\n    this.proxy(\"properties.orderId\")\n  );\n};\n\n/**\n * Get the SKU from `properties.sku`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.sku = Facade.proxy(\"properties.sku\");\n\n/**\n * Get the amount of tax for this purchase from `properties.tax`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.tax = Facade.proxy(\"properties.tax\");\n\n/**\n * Get the name of this event from `properties.name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.name = Facade.proxy(\"properties.name\");\n\n/**\n * Get the price of this purchase from `properties.price`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.price = Facade.proxy(\"properties.price\");\n\n/**\n * Get the total for this purchase from `properties.total`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.total = Facade.proxy(\"properties.total\");\n\n/**\n * Whether this is a repeat purchase from `properties.repeat`.\n *\n * This *should* be a boolean, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {boolean}\n */\nt.repeat = Facade.proxy(\"properties.repeat\");\n\n/**\n * Get the coupon for this purchase from `properties.coupon`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.coupon = Facade.proxy(\"properties.coupon\");\n\n/**\n * Get the shipping for this purchase from `properties.shipping`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.shipping = Facade.proxy(\"properties.shipping\");\n\n/**\n * Get the discount for this purchase from `properties.discount`.\n *\n * This *should* be a number, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {number}\n */\nt.discount = Facade.proxy(\"properties.discount\");\n\n/**\n * Get the shipping method for this purchase from `properties.shippingMethod`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.shippingMethod = function () {\n  return (\n    this.proxy(\"properties.shipping_method\") ||\n    this.proxy(\"properties.shippingMethod\")\n  );\n};\n\n/**\n * Get the payment method for this purchase from `properties.paymentMethod`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.paymentMethod = function () {\n  return (\n    this.proxy(\"properties.payment_method\") ||\n    this.proxy(\"properties.paymentMethod\")\n  );\n};\n\n/**\n * Get a description for this event from `properties.description`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.description = Facade.proxy(\"properties.description\");\n\n/**\n * Get a plan, as in the plan the user is on, for this event from\n * `properties.plan`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string}\n */\nt.plan = Facade.proxy(\"properties.plan\");\n\n/**\n * Get the subtotal for this purchase from `properties.subtotal`.\n *\n * If `properties.subtotal` isn't available, then fall back to computing the\n * total from `properties.total` or `properties.revenue`, and then subtracting\n * tax, shipping, and discounts.\n *\n * If neither subtotal, total, nor revenue are available, then return 0.\n *\n * @return {number}\n */\nt.subtotal = function () {\n  let subtotal = get(this.properties(), \"subtotal\");\n  let total = this.total() || this.revenue();\n\n  if (subtotal) return subtotal;\n  if (!total) return 0;\n\n  if (this.total()) {\n    let n = this.tax();\n    if (n) total -= n;\n    n = this.shipping();\n    if (n) total -= n;\n    n = this.discount();\n    if (n) total += n;\n  }\n\n  return total;\n};\n\n/**\n * Get the products for this event from `properties.products` if it's an\n * array, falling back to an empty array.\n *\n * @return {Array}\n */\nt.products = function () {\n  let props = this.properties();\n  let products = get(props, \"products\");\n  if (Array.isArray(products)) {\n    return products.filter(item => item !== null)\n  }\n  return [];\n};\n\n/**\n * Get the quantity for this event from `properties.quantity`, falling back to\n * a quantity of one.\n *\n * @return {number}\n */\nt.quantity = function () {\n  let props = this.obj.properties || {};\n  return props.quantity || 1;\n};\n\n/**\n * Get the currency for this event from `properties.currency`, falling back to\n * \"USD\".\n *\n * @return {string}\n */\nt.currency = function () {\n  let props = this.obj.properties || {};\n  return props.currency || \"USD\";\n};\n\n/**\n * Get the referrer for this event from `context.referrer.url`,\n * `context.page.referrer`, or `properties.referrer`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\nt.referrer = function () {\n  // TODO re-examine whether this function is necessary\n  return (\n    this.proxy(\"context.referrer.url\") ||\n    this.proxy(\"context.page.referrer\") ||\n    this.proxy(\"properties.referrer\")\n  );\n};\n\n/**\n * Get the query for this event from `options.query`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return {string|object}\n */\nt.query = Facade.proxy(\"options.query\");\n\n/**\n * Get the page's properties. This is identical to how {@link Facade#traits}\n * works, except it looks at `properties.*` instead of `options.traits.*`.\n *\n * Properties are gotten from `properties`.\n *\n * The parameter `aliases` is meant to transform keys in `properties` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { properties: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let track = new Track(obj)\n *\n * track.traits() // { \"foo\": \"bar\" }\n * track.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * track.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\nt.properties = function (aliases) {\n  let ret = this.field(\"properties\") || {};\n  aliases = aliases || {};\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"properties.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Get the username of the user for this event from `traits.username`,\n * `properties.username`, `userId`, or `anonymousId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string|undefined}\n */\nt.username = function () {\n  return (\n    this.proxy(\"traits.username\") ||\n    this.proxy(\"properties.username\") ||\n    this.userId() ||\n    this.sessionId()\n  );\n};\n\n/**\n * Get the email of the user for this event from `trais.email`,\n * `properties.email`, or `options.traits.email`, falling back to `userId` if\n * it looks like a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string|undefined}\n */\nt.email = function () {\n  let email =\n    this.proxy(\"traits.email\") ||\n    this.proxy(\"properties.email\") ||\n    this.proxy(\"options.traits.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the revenue for this event.\n *\n * If this is an \"Order Completed\" event, this will be the `properties.total`\n * falling back to the `properties.revenue`. For all other events, this is\n * simply taken from `properties.revenue`.\n *\n * If there are dollar signs in these properties, they will be removed. The\n * result will be parsed into a number.\n *\n * @return {number}\n */\nt.revenue = function () {\n  let revenue = this.proxy(\"properties.revenue\");\n  let event = this.event();\n  let orderCompletedRegExp = /^[ _]?completed[ _]?order[ _]?|^[ _]?order[ _]?completed[ _]?$/i;\n\n  // it's always revenue, unless it's called during an order completion.\n  if (!revenue && event && event.match(orderCompletedRegExp)) {\n    revenue = this.proxy(\"properties.total\");\n  }\n\n  return currency(revenue);\n};\n\n/**\n * Get the revenue for this event in \"cents\" -- in other words, multiply the\n * {@link Track#revenue} by 100, or return 0 if there isn't a numerical revenue\n * for this event.\n *\n * @return {number}\n */\nt.cents = function () {\n  let revenue = this.revenue();\n  return typeof revenue !== \"number\" ? this.value() || 0 : revenue * 100;\n};\n\n/**\n * Convert this event into an {@link Identify} facade.\n *\n * This works by taking this event's underlying object and creating an Identify\n * from it. This event's traits, taken from `options.traits`, will be used as\n * the Identify's traits.\n *\n * @return {Identify}\n */\nt.identify = function () {\n  // TODO: remove me.\n  let json = this.json();\n  json.traits = this.traits();\n  return new Identify(json, this.opts);\n};\n\n/**\n * Get float from currency value.\n *\n * @ignore\n * @param {*} val\n * @return {number}\n */\nfunction currency(val) {\n  if (!val) return;\n  if (typeof val === \"number\") {\n    return val;\n  }\n  if (typeof val !== \"string\") {\n    return;\n  }\n\n  val = val.replace(/\\$/g, \"\");\n  val = parseFloat(val);\n\n  if (!isNaN(val)) {\n    return val;\n  }\n}\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\nimport { Track } from \"./track\";\nimport isEmail from \"./is-email\";\n\n/**\n * Initialize a new `Page` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The page category.\n * @param {string} [dictionary.name] - The page name.\n * @param {string} [dictionary.properties] - The page properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Page(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Page, Facade);\n\nconst p = Page.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"page\"`.\n *\n * @return {string}\n */\np.action = function () {\n  return \"page\";\n};\n\n/**\n * An alias for {@link Page#action}.\n *\n * @function\n * @return {string}\n */\np.type = p.action;\n\n/**\n * Get the page category from `category`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.category = Facade.field(\"category\");\n\n/**\n * Get the page name from `name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.name = Facade.field(\"name\");\n\n/**\n * Get the page title from `properties.title`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.title = Facade.proxy(\"properties.title\");\n\n/**\n * Get the page path from `properties.path`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.path = Facade.proxy(\"properties.path\");\n\n/**\n * Get the page URL from `properties.url`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.url = Facade.proxy(\"properties.url\");\n\n/**\n * Get the HTTP referrer from `context.referrer.url`, `context.page.referrer`,\n * or `properties.referrer`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.referrer = function () {\n  return (\n    this.proxy(\"context.referrer.url\") ||\n    this.proxy(\"context.page.referrer\") ||\n    this.proxy(\"properties.referrer\")\n  );\n};\n\n/**\n * Get the page's properties. This is identical to how {@link Facade#traits}\n * works, except it looks at `properties.*` instead of `options.traits.*`.\n *\n * Properties are gotten from `properties`, augmented with the page's `name`\n * and `category`.\n *\n * The parameter `aliases` is meant to transform keys in `properties` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { properties: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let page = new Page(obj)\n *\n * page.traits() // { \"foo\": \"bar\" }\n * page.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * page.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\np.properties = function (aliases) {\n  let props = this.field(\"properties\") || {};\n  let category = this.category();\n  let name = this.name();\n  aliases = aliases || {};\n\n  if (category) props.category = category;\n  if (name) props.name = name;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"properties.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      props[aliases[alias]] = value;\n      if (alias !== aliases[alias]) delete props[alias];\n    }\n  }\n\n  return props;\n};\n\n/**\n * Get the user's email from `context.traits.email` or `properties.email`,\n * falling back to `userId` if it's a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.email = function () {\n  let email =\n    this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the page fullName. This is `$category $name` if both are present, and\n * just `name` otherwiser.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.fullName = function () {\n  let category = this.category();\n  let name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\n\n/**\n * Get an event name from this page call. If `name` is present, this will be\n * `Viewed $name Page`; otherwise, it will be `Loaded a Page`.\n *\n * @param {string} name - The name of this page.\n * @return {string}\n */\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\n\n/**\n * Convert this Page to a {@link Track} facade. The inputted `name` will be\n * converted to the Track's event name via {@link Page#event}.\n *\n * @param {string} name\n * @return {Track}\n */\np.track = function (name) {\n  let json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new Track(json, this.opts);\n};\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Page } from \"./page\";\nimport { Track } from \"./track\";\n\n/**\n * Initialize a new `Screen` facade with a `dictionary` of arguments.\n *\n * Note that this class extends {@link Page}, so its methods are available to\n * instances of this class as well.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The page category.\n * @param {string} [dictionary.name] - The page name.\n * @param {string} [dictionary.properties] - The page properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Page\n */\nexport function Screen(dictionary, opts) {\n  Page.call(this, dictionary, opts);\n}\n\ninherit(Screen, Page);\n\n/**\n * Return the type of facade this is. This will always return `\"screen\"`.\n *\n * @return {string}\n */\nScreen.prototype.action = function () {\n  return \"screen\";\n};\n\n/**\n * An alias for {@link Screen#action}.\n *\n * @function\n * @return {string}\n */\nScreen.prototype.type = Screen.prototype.action;\n\n/**\n * Get an event name from this screen call. If `name` is present, this will be\n * `Viewed $name Screen`; otherwise, it will be `Loaded a Screen`.\n *\n * @param {string} name - The name of this screen.\n * @return {string}\n */\nScreen.prototype.event = function (name) {\n  return name ? \"Viewed \" + name + \" Screen\" : \"Loaded a Screen\";\n};\n\n/**\n * Convert this Screen to a {@link Track} facade. The inputted `name` will be\n * converted to the Track's event name via {@link Screen#event}.\n *\n * @param {string} name\n * @return {Track}\n */\nScreen.prototype.track = function (name) {\n  let json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new Track(json, this.opts);\n};\n", "\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\n\n/**\n * Initialize a new `Delete` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The delete category.\n * @param {string} [dictionary.name] - The delete name.\n * @param {string} [dictionary.properties] - The delete properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Delete(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Delete, Facade);\n\n/**\n * Return the type of facade this is. This will always return `\"delete\"`.\n *\n * @return {string}\n */\nDelete.prototype.type = function () {\n  return \"delete\";\n};\n", "\"use strict\";\n\nimport { Facade } from \"./facade\";\nimport { Alias } from \"./alias\";\nimport { Group } from \"./group\";\nimport { Identify } from \"./identify\";\nimport { Track } from \"./track\";\nimport { Page } from \"./page\";\nimport { Screen } from \"./screen\";\nimport { Delete } from \"./delete\";\n\nexport default {\n  ...Facade,\n  Alias,\n  Group,\n  Identify,\n  Track,\n  Page,\n  Screen,\n  Delete,\n};\n\nexport { Facade, Alias, Group, Identify, Track, Page, Screen, Delete };\n", "export default function(url, options) {\n\toptions = options || {};\n\treturn new Promise( (resolve, reject) => {\n\t\tconst request = new XMLHttpRequest();\n\t\tconst keys = [];\n\t\tconst all = [];\n\t\tconst headers = {};\n\n\t\tconst response = () => ({\n\t\t\tok: (request.status/100|0) == 2,\t\t// 200-299\n\t\t\tstatusText: request.statusText,\n\t\t\tstatus: request.status,\n\t\t\turl: request.responseURL,\n\t\t\ttext: () => Promise.resolve(request.responseText),\n\t\t\tjson: () => Promise.resolve(request.responseText).then(JSON.parse),\n\t\t\tblob: () => Promise.resolve(new Blob([request.response])),\n\t\t\tclone: response,\n\t\t\theaders: {\n\t\t\t\tkeys: () => keys,\n\t\t\t\tentries: () => all,\n\t\t\t\tget: n => headers[n.toLowerCase()],\n\t\t\t\thas: n => n.toLowerCase() in headers\n\t\t\t}\n\t\t});\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\trequest.onload = () => {\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (m, key, value) => {\n\t\t\t\tkeys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theaders[key] = headers[key] ? `${headers[key]},${value}` : value;\n\t\t\t});\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.withCredentials = options.credentials=='include';\n\n\t\tfor (const i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.send(options.body || null);\n\t});\n}\n", "// This an imperfect polyfill for globalThis\nexport const getGlobal = () => {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis\n  }\n  if (typeof self !== 'undefined') {\n    return self\n  }\n  if (typeof window !== 'undefined') {\n    return window\n  }\n  if (typeof global !== 'undefined') {\n    return global\n  }\n  return null\n}\n", "import unfetch from 'unfetch'\nimport { getGlobal } from './get-global'\n\n/**\n * Wrapper around native `fetch` containing `unfetch` fallback.\n */\nexport const fetch: typeof global.fetch = (...args) => {\n  const global = getGlobal()\n  return ((global && global.fetch) || unfetch)(...args)\n}\n", "// This file is generated.\nexport const version = '1.63.0'\n", "// Default value will be updated to 'web' in `bundle-umd.ts` for web build.\nlet _version: 'web' | 'npm' = 'npm'\n\nexport function setVersionType(version: typeof _version) {\n  _version = version\n}\n\nexport function getVersionType(): typeof _version {\n  return _version\n}\n", "export const SEGMENT_API_HOST = 'api.segment.io/v1'\n", "import { fetch } from '../../lib/fetch'\nimport { version } from '../../generated/version'\nimport { getVersionType } from '../../lib/version-type'\nimport { SEGMENT_API_HOST } from '../constants'\n\nexport interface MetricsOptions {\n  host?: string\n  sampleRate?: number\n  flushTimer?: number\n  maxQueueSize?: number\n}\n\n/**\n * Type expected by the segment metrics API endpoint\n */\ntype RemoteMetric = {\n  type: 'Counter'\n  metric: string\n  value: 1\n  tags: {\n    library: string\n    library_version: string\n    [key: string]: string\n  }\n}\n\nconst createRemoteMetric = (\n  metric: string,\n  tags: string[],\n  versionType: 'web' | 'npm'\n): RemoteMetric => {\n  const formattedTags = tags.reduce((acc, t) => {\n    const [k, v] = t.split(':')\n    acc[k] = v\n    return acc\n  }, {} as Record<string, string>)\n\n  return {\n    type: 'Counter',\n    metric,\n    value: 1,\n    tags: {\n      ...formattedTags,\n      library: 'analytics.js',\n      library_version:\n        versionType === 'web' ? `next-${version}` : `npm:next-${version}`,\n    },\n  }\n}\n\nfunction logError(err: unknown): void {\n  console.error('Error sending segment performance metrics', err)\n}\n\nexport class RemoteMetrics {\n  private host: string\n  private flushTimer: number\n  private maxQueueSize: number\n\n  sampleRate: number\n  queue: RemoteMetric[]\n\n  constructor(options?: MetricsOptions) {\n    this.host = options?.host ?? SEGMENT_API_HOST\n    this.sampleRate = options?.sampleRate ?? 1\n    this.flushTimer = options?.flushTimer ?? 30 * 1000 /* 30s */\n    this.maxQueueSize = options?.maxQueueSize ?? 20\n\n    this.queue = []\n\n    if (this.sampleRate > 0) {\n      let flushing = false\n\n      const run = (): void => {\n        if (flushing) {\n          return\n        }\n\n        flushing = true\n        this.flush().catch(logError)\n\n        flushing = false\n\n        setTimeout(run, this.flushTimer)\n      }\n      run()\n    }\n  }\n\n  increment(metric: string, tags: string[]): void {\n    // All metrics are part of an allow list in Tracking API\n    if (!metric.includes('analytics_js.')) {\n      return\n    }\n\n    // /m doesn't like empty tags\n    if (tags.length === 0) {\n      return\n    }\n\n    if (Math.random() > this.sampleRate) {\n      return\n    }\n\n    if (this.queue.length >= this.maxQueueSize) {\n      return\n    }\n\n    const remoteMetric = createRemoteMetric(metric, tags, getVersionType())\n    this.queue.push(remoteMetric)\n\n    if (metric.includes('error')) {\n      this.flush().catch(logError)\n    }\n  }\n\n  async flush(): Promise<void> {\n    if (this.queue.length <= 0) {\n      return\n    }\n\n    await this.send().catch((error) => {\n      logError(error)\n      this.sampleRate = 0\n    })\n  }\n\n  private async send(): Promise<Response> {\n    const payload = { series: this.queue }\n    this.queue = []\n\n    const headers = { 'Content-Type': 'text/plain' }\n    const url = `https://${this.host}/m`\n\n    return fetch(url, {\n      headers,\n      body: JSON.stringify(payload),\n      method: 'POST',\n    })\n  }\n}\n", "import { CoreStats } from '@segment/analytics-core'\nimport { MetricsOptions, RemoteMetrics } from './remote-metrics'\n\nlet remoteMetrics: RemoteMetrics | undefined\n\nexport class Stats extends CoreStats {\n  static initRemoteMetrics(options?: MetricsOptions) {\n    remoteMetrics = new RemoteMetrics(options)\n  }\n\n  override increment(metric: string, by?: number, tags?: string[]): void {\n    super.increment(metric, by, tags)\n    remoteMetrics?.increment(metric, tags ?? [])\n  }\n}\n", "import {\n  CoreContext,\n  ContextCancelation,\n  ContextFailedDelivery,\n  SerializedContext,\n  CancelationOptions,\n} from '@segment/analytics-core'\nimport { SegmentEvent } from '../events/interfaces'\nimport { Stats } from '../stats'\n\nexport class Context extends CoreContext<SegmentEvent> {\n  static override system() {\n    return new this({ type: 'track', event: 'system' })\n  }\n  constructor(event: SegmentEvent, id?: string) {\n    super(event, id, new Stats())\n  }\n}\n\nexport { ContextCancelation }\nexport type { ContextFailedDelivery, SerializedContext, CancelationOptions }\n", "import {\n  Alias,\n  Facade,\n  Group,\n  Identify,\n  Options,\n  Page,\n  Screen,\n  Track,\n} from '@segment/facade'\nimport { SegmentEvent } from '../core/events'\n\nexport type SegmentFacade = Facade<SegmentEvent> & {\n  obj: SegmentEvent\n}\n\nexport function toFacade(evt: SegmentEvent, options?: Options): SegmentFacade {\n  let fcd = new Facade(evt, options)\n\n  if (evt.type === 'track') {\n    fcd = new Track(evt, options)\n  }\n\n  if (evt.type === 'identify') {\n    fcd = new Identify(evt, options)\n  }\n\n  if (evt.type === 'page') {\n    fcd = new Page(evt, options)\n  }\n\n  if (evt.type === 'alias') {\n    fcd = new Alias(evt, options)\n  }\n\n  if (evt.type === 'group') {\n    fcd = new Group(evt, options)\n  }\n\n  if (evt.type === 'screen') {\n    fcd = new Screen(evt, options)\n  }\n\n  Object.defineProperty(fcd, 'obj', {\n    value: evt,\n    writable: true,\n  })\n\n  return fcd as SegmentFacade\n}\n", "import { Context, ContextCancelation } from '../../core/context'\nimport { SegmentEvent } from '../../core/events'\nimport { Plugin } from '../../core/plugin'\nimport { SegmentFacade, toFacade } from '../../lib/to-facade'\n\nexport interface MiddlewareParams {\n  payload: SegmentFacade\n\n  integrations?: SegmentEvent['integrations']\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport interface DestinationMiddlewareParams {\n  payload: SegmentFacade\n  integration: string\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport type MiddlewareFunction = (\n  middleware: MiddlewareParams\n) => void | Promise<void>\n\nexport type DestinationMiddlewareFunction = (\n  middleware: DestinationMiddlewareParams\n) => void | Promise<void>\n\nexport async function applyDestinationMiddleware(\n  destination: string,\n  evt: SegmentEvent,\n  middleware: DestinationMiddlewareFunction[]\n): Promise<SegmentEvent | null> {\n  // Clone the event so mutations are localized to a single destination.\n  let modifiedEvent = toFacade(evt, {\n    clone: true,\n    traverse: false,\n  }).rawEvent() as SegmentEvent\n  async function applyMiddleware(\n    event: SegmentEvent,\n    fn: DestinationMiddlewareFunction\n  ): Promise<SegmentEvent | null> {\n    let nextCalled = false\n    let returnedEvent: SegmentEvent | null = null\n\n    await fn({\n      payload: toFacade(event, {\n        clone: true,\n        traverse: false,\n      }),\n      integration: destination,\n      next(evt) {\n        nextCalled = true\n\n        if (evt === null) {\n          returnedEvent = null\n        }\n\n        if (evt) {\n          returnedEvent = evt.obj\n        }\n      },\n    })\n\n    if (!nextCalled && returnedEvent !== null) {\n      returnedEvent = returnedEvent as SegmentEvent\n      returnedEvent.integrations = {\n        ...event.integrations,\n        [destination]: false,\n      }\n    }\n\n    return returnedEvent\n  }\n\n  for (const md of middleware) {\n    const result = await applyMiddleware(modifiedEvent, md)\n    if (result === null) {\n      return null\n    }\n    modifiedEvent = result\n  }\n\n  return modifiedEvent\n}\n\nexport function sourceMiddlewarePlugin(\n  fn: MiddlewareFunction,\n  integrations: SegmentEvent['integrations']\n): Plugin {\n  async function apply(ctx: Context): Promise<Context> {\n    let nextCalled = false\n\n    await fn({\n      payload: toFacade(ctx.event, {\n        clone: true,\n        traverse: false,\n      }),\n      integrations: integrations ?? {},\n      next(evt) {\n        nextCalled = true\n        if (evt) {\n          ctx.event = evt.obj\n        }\n      },\n    })\n\n    if (!nextCalled) {\n      throw new ContextCancelation({\n        retry: false,\n        type: 'middleware_cancellation',\n        reason: 'Middleware `next` function skipped',\n      })\n    }\n\n    return ctx\n  }\n\n  return {\n    name: `Source Middleware ${fn.name}`,\n    type: 'before',\n    version: '0.1.0',\n\n    isLoaded: (): boolean => true,\n    load: (ctx): Promise<Context> => Promise.resolve(ctx),\n\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply,\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_lib", "require_lib", "Facade", "Alias", "Group", "Identify", "Track", "Page", "Screen", "__assign", "url", "options", "Promise", "resolve", "reject", "request", "XMLHttpRequest", "keys", "all", "headers", "response", "ok", "status", "statusText", "responseURL", "text", "responseText", "json", "then", "JSON", "parse", "blob", "Blob", "clone", "entries", "get", "n", "toLowerCase", "has", "i", "open", "method", "onload", "getAllResponseHeaders", "replace", "m", "key", "value", "push", "onerror", "withCredentials", "credentials", "setRequestHeader", "send", "body", "global", "RemoteMetrics", "Stats", "Context", "evt"]
}
