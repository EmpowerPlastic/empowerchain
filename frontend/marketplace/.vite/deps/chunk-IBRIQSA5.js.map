{
  "version": 3,
  "sources": ["../../node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/ics23/v1/proofs.js", "../../node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/commitment/v1/commitment.js", "../../node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/connection/v1/connection.js"],
  "sourcesContent": ["import * as _m0 from \"protobufjs/minimal\";\nimport { isSet, bytesFromBase64, base64FromBytes } from \"../../../helpers\";\nexport let HashOp = /*#__PURE__*/function (HashOp) {\n  HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n  HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n  HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n  HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n  HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n  HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n  HashOp[HashOp[\"SHA512_256\"] = 6] = \"SHA512_256\";\n  HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n  return HashOp;\n}({});\nexport const HashOpSDKType = HashOp;\nexport function hashOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_HASH\":\n      return HashOp.NO_HASH;\n    case 1:\n    case \"SHA256\":\n      return HashOp.SHA256;\n    case 2:\n    case \"SHA512\":\n      return HashOp.SHA512;\n    case 3:\n    case \"KECCAK\":\n      return HashOp.KECCAK;\n    case 4:\n    case \"RIPEMD160\":\n      return HashOp.RIPEMD160;\n    case 5:\n    case \"BITCOIN\":\n      return HashOp.BITCOIN;\n    case 6:\n    case \"SHA512_256\":\n      return HashOp.SHA512_256;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return HashOp.UNRECOGNIZED;\n  }\n}\nexport function hashOpToJSON(object) {\n  switch (object) {\n    case HashOp.NO_HASH:\n      return \"NO_HASH\";\n    case HashOp.SHA256:\n      return \"SHA256\";\n    case HashOp.SHA512:\n      return \"SHA512\";\n    case HashOp.KECCAK:\n      return \"KECCAK\";\n    case HashOp.RIPEMD160:\n      return \"RIPEMD160\";\n    case HashOp.BITCOIN:\n      return \"BITCOIN\";\n    case HashOp.SHA512_256:\n      return \"SHA512_256\";\n    case HashOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\nexport let LengthOp = /*#__PURE__*/function (LengthOp) {\n  LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n  LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n  LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n  LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n  LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n  LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n  LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n  LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n  LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n  LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n  return LengthOp;\n}({});\nexport const LengthOpSDKType = LengthOp;\nexport function lengthOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_PREFIX\":\n      return LengthOp.NO_PREFIX;\n    case 1:\n    case \"VAR_PROTO\":\n      return LengthOp.VAR_PROTO;\n    case 2:\n    case \"VAR_RLP\":\n      return LengthOp.VAR_RLP;\n    case 3:\n    case \"FIXED32_BIG\":\n      return LengthOp.FIXED32_BIG;\n    case 4:\n    case \"FIXED32_LITTLE\":\n      return LengthOp.FIXED32_LITTLE;\n    case 5:\n    case \"FIXED64_BIG\":\n      return LengthOp.FIXED64_BIG;\n    case 6:\n    case \"FIXED64_LITTLE\":\n      return LengthOp.FIXED64_LITTLE;\n    case 7:\n    case \"REQUIRE_32_BYTES\":\n      return LengthOp.REQUIRE_32_BYTES;\n    case 8:\n    case \"REQUIRE_64_BYTES\":\n      return LengthOp.REQUIRE_64_BYTES;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return LengthOp.UNRECOGNIZED;\n  }\n}\nexport function lengthOpToJSON(object) {\n  switch (object) {\n    case LengthOp.NO_PREFIX:\n      return \"NO_PREFIX\";\n    case LengthOp.VAR_PROTO:\n      return \"VAR_PROTO\";\n    case LengthOp.VAR_RLP:\n      return \"VAR_RLP\";\n    case LengthOp.FIXED32_BIG:\n      return \"FIXED32_BIG\";\n    case LengthOp.FIXED32_LITTLE:\n      return \"FIXED32_LITTLE\";\n    case LengthOp.FIXED64_BIG:\n      return \"FIXED64_BIG\";\n    case LengthOp.FIXED64_LITTLE:\n      return \"FIXED64_LITTLE\";\n    case LengthOp.REQUIRE_32_BYTES:\n      return \"REQUIRE_32_BYTES\";\n    case LengthOp.REQUIRE_64_BYTES:\n      return \"REQUIRE_64_BYTES\";\n    case LengthOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * ExistenceProof takes a key and a value and a set of steps to perform on it.\n * The result of peforming all these steps will provide a \"root hash\", which can\n * be compared to the value in a header.\n * \n * Since it is computationally infeasible to produce a hash collission for any of the used\n * cryptographic hash functions, if someone can provide a series of operations to transform\n * a given key and value into a root hash that matches some trusted root, these key and values\n * must be in the referenced merkle tree.\n * \n * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n * which should be controlled by a spec. Eg. with lengthOp as NONE,\n * prefix = FOO, key = BAR, value = CHOICE\n * and\n * prefix = F, key = OOBAR, value = CHOICE\n * would produce the same value.\n * \n * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n * length-prefix the data before hashing it.\n */\n\n/**\n * ExistenceProof takes a key and a value and a set of steps to perform on it.\n * The result of peforming all these steps will provide a \"root hash\", which can\n * be compared to the value in a header.\n * \n * Since it is computationally infeasible to produce a hash collission for any of the used\n * cryptographic hash functions, if someone can provide a series of operations to transform\n * a given key and value into a root hash that matches some trusted root, these key and values\n * must be in the referenced merkle tree.\n * \n * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n * which should be controlled by a spec. Eg. with lengthOp as NONE,\n * prefix = FOO, key = BAR, value = CHOICE\n * and\n * prefix = F, key = OOBAR, value = CHOICE\n * would produce the same value.\n * \n * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n * length-prefix the data before hashing it.\n */\n\n/**\n * NonExistenceProof takes a proof of two neighbors, one left of the desired key,\n * one right of the desired key. If both proofs are valid AND they are neighbors,\n * then there is no valid proof for the given key.\n */\n\n/**\n * NonExistenceProof takes a proof of two neighbors, one left of the desired key,\n * one right of the desired key. If both proofs are valid AND they are neighbors,\n * then there is no valid proof for the given key.\n */\n\n/** CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages */\n\n/** CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages */\n\n/**\n * LeafOp represents the raw key-value data we wish to prove, and\n * must be flexible to represent the internal transformation from\n * the original key-value pairs into the basis hash, for many existing\n * merkle trees.\n * \n * key and value are passed in. So that the signature of this operation is:\n * leafOp(key, value) -> output\n * \n * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n * hkey = prehashKey(key)\n * hvalue = prehashValue(value)\n * \n * Then combine the bytes, and hash it\n * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n */\n\n/**\n * LeafOp represents the raw key-value data we wish to prove, and\n * must be flexible to represent the internal transformation from\n * the original key-value pairs into the basis hash, for many existing\n * merkle trees.\n * \n * key and value are passed in. So that the signature of this operation is:\n * leafOp(key, value) -> output\n * \n * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n * hkey = prehashKey(key)\n * hvalue = prehashValue(value)\n * \n * Then combine the bytes, and hash it\n * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n */\n\n/**\n * InnerOp represents a merkle-proof step that is not a leaf.\n * It represents concatenating two children and hashing them to provide the next result.\n * \n * The result of the previous step is passed in, so the signature of this op is:\n * innerOp(child) -> output\n * \n * The result of applying InnerOp should be:\n * output = op.hash(op.prefix || child || op.suffix)\n * \n * where the || operator is concatenation of binary data,\n * and child is the result of hashing all the tree below this step.\n * \n * Any special data, like prepending child with the length, or prepending the entire operation with\n * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n * If either of prefix or suffix is empty, we just treat it as an empty string\n */\n\n/**\n * InnerOp represents a merkle-proof step that is not a leaf.\n * It represents concatenating two children and hashing them to provide the next result.\n * \n * The result of the previous step is passed in, so the signature of this op is:\n * innerOp(child) -> output\n * \n * The result of applying InnerOp should be:\n * output = op.hash(op.prefix || child || op.suffix)\n * \n * where the || operator is concatenation of binary data,\n * and child is the result of hashing all the tree below this step.\n * \n * Any special data, like prepending child with the length, or prepending the entire operation with\n * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n * If either of prefix or suffix is empty, we just treat it as an empty string\n */\n\n/**\n * ProofSpec defines what the expected parameters are for a given proof type.\n * This can be stored in the client and used to validate any incoming proofs.\n * \n * verify(ProofSpec, Proof) -> Proof | Error\n * \n * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n * LeafHash for a given tree, there are many possible key-value pairs that can\n * generate a given hash (by interpretting the preimage differently).\n * We need this for proper security, requires client knows a priori what\n * tree format server uses. But not in code, rather a configuration object.\n */\n\n/**\n * ProofSpec defines what the expected parameters are for a given proof type.\n * This can be stored in the client and used to validate any incoming proofs.\n * \n * verify(ProofSpec, Proof) -> Proof | Error\n * \n * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n * LeafHash for a given tree, there are many possible key-value pairs that can\n * generate a given hash (by interpretting the preimage differently).\n * We need this for proper security, requires client knows a priori what\n * tree format server uses. But not in code, rather a configuration object.\n */\n\n/**\n * InnerSpec contains all store-specific structure info to determine if two proofs from a\n * given store are neighbors.\n * \n * This enables:\n * \n * isLeftMost(spec: InnerSpec, op: InnerOp)\n * isRightMost(spec: InnerSpec, op: InnerOp)\n * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)\n */\n\n/**\n * InnerSpec contains all store-specific structure info to determine if two proofs from a\n * given store are neighbors.\n * \n * This enables:\n * \n * isLeftMost(spec: InnerSpec, op: InnerOp)\n * isRightMost(spec: InnerSpec, op: InnerOp)\n * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)\n */\n\n/** BatchProof is a group of multiple proof types than can be compressed */\n\n/** BatchProof is a group of multiple proof types than can be compressed */\n\n/** Use BatchEntry not CommitmentProof, to avoid recursion */\n\n/** Use BatchEntry not CommitmentProof, to avoid recursion */\n\n/** Use BatchEntry not CommitmentProof, to avoid recursion */\n\n/** Use BatchEntry not CommitmentProof, to avoid recursion */\n\nfunction createBaseExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: undefined,\n    path: []\n  };\n}\nexport const ExistenceProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.path) {\n      InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseExistenceProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.path.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),\n      leaf: isSet(object.leaf) ? LeafOp.fromJSON(object.leaf) : undefined,\n      path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map(e => InnerOp.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? LeafOp.toJSON(message.leaf) : undefined);\n    if (message.path) {\n      obj.path = message.path.map(e => e ? InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.path = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$key, _object$value, _object$path;\n    const message = createBaseExistenceProof();\n    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();\n    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path = object.path) === null || _object$path === void 0 ? void 0 : _object$path.map(e => InnerOp.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: undefined,\n    right: undefined\n  };\n}\nexport const NonExistenceProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseNonExistenceProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      left: isSet(object.left) ? ExistenceProof.fromJSON(object.left) : undefined,\n      right: isSet(object.right) ? ExistenceProof.fromJSON(object.right) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? ExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? ExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$key2;\n    const message = createBaseNonExistenceProof();\n    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? ExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? ExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};\nfunction createBaseCommitmentProof() {\n  return {\n    exist: undefined,\n    nonexist: undefined,\n    batch: undefined,\n    compressed: undefined\n  };\n}\nexport const CommitmentProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.batch !== undefined) {\n      BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.compressed !== undefined) {\n      CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommitmentProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.batch = BatchProof.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.compressed = CompressedBatchProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      exist: isSet(object.exist) ? ExistenceProof.fromJSON(object.exist) : undefined,\n      nonexist: isSet(object.nonexist) ? NonExistenceProof.fromJSON(object.nonexist) : undefined,\n      batch: isSet(object.batch) ? BatchProof.fromJSON(object.batch) : undefined,\n      compressed: isSet(object.compressed) ? CompressedBatchProof.fromJSON(object.compressed) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? NonExistenceProof.toJSON(message.nonexist) : undefined);\n    message.batch !== undefined && (obj.batch = message.batch ? BatchProof.toJSON(message.batch) : undefined);\n    message.compressed !== undefined && (obj.compressed = message.compressed ? CompressedBatchProof.toJSON(message.compressed) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = createBaseCommitmentProof();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    message.batch = object.batch !== undefined && object.batch !== null ? BatchProof.fromPartial(object.batch) : undefined;\n    message.compressed = object.compressed !== undefined && object.compressed !== null ? CompressedBatchProof.fromPartial(object.compressed) : undefined;\n    return message;\n  }\n};\nfunction createBaseLeafOp() {\n  return {\n    hash: 0,\n    prehashKey: 0,\n    prehashValue: 0,\n    length: 0,\n    prefix: new Uint8Array()\n  };\n}\nexport const LeafOp = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prehashKey !== 0) {\n      writer.uint32(16).int32(message.prehashKey);\n    }\n    if (message.prehashValue !== 0) {\n      writer.uint32(24).int32(message.prehashValue);\n    }\n    if (message.length !== 0) {\n      writer.uint32(32).int32(message.length);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(42).bytes(message.prefix);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLeafOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prehashKey = reader.int32();\n          break;\n        case 3:\n          message.prehashValue = reader.int32();\n          break;\n        case 4:\n          message.length = reader.int32();\n          break;\n        case 5:\n          message.prefix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0,\n      prehashKey: isSet(object.prehashKey) ? hashOpFromJSON(object.prehashKey) : 0,\n      prehashValue: isSet(object.prehashValue) ? hashOpFromJSON(object.prehashValue) : 0,\n      length: isSet(object.length) ? lengthOpFromJSON(object.length) : 0,\n      prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array()\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prehashKey !== undefined && (obj.prehashKey = hashOpToJSON(message.prehashKey));\n    message.prehashValue !== undefined && (obj.prehashValue = hashOpToJSON(message.prehashValue));\n    message.length !== undefined && (obj.length = lengthOpToJSON(message.length));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$hash, _object$prehashKey, _object$prehashValue, _object$length, _object$prefix;\n    const message = createBaseLeafOp();\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : 0;\n    message.prehashKey = (_object$prehashKey = object.prehashKey) !== null && _object$prehashKey !== void 0 ? _object$prehashKey : 0;\n    message.prehashValue = (_object$prehashValue = object.prehashValue) !== null && _object$prehashValue !== void 0 ? _object$prehashValue : 0;\n    message.length = (_object$length = object.length) !== null && _object$length !== void 0 ? _object$length : 0;\n    message.prefix = (_object$prefix = object.prefix) !== null && _object$prefix !== void 0 ? _object$prefix : new Uint8Array();\n    return message;\n  }\n};\nfunction createBaseInnerOp() {\n  return {\n    hash: 0,\n    prefix: new Uint8Array(),\n    suffix: new Uint8Array()\n  };\n}\nexport const InnerOp = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(18).bytes(message.prefix);\n    }\n    if (message.suffix.length !== 0) {\n      writer.uint32(26).bytes(message.suffix);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseInnerOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prefix = reader.bytes();\n          break;\n        case 3:\n          message.suffix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0,\n      prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array(),\n      suffix: isSet(object.suffix) ? bytesFromBase64(object.suffix) : new Uint8Array()\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    message.suffix !== undefined && (obj.suffix = base64FromBytes(message.suffix !== undefined ? message.suffix : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$hash2, _object$prefix2, _object$suffix;\n    const message = createBaseInnerOp();\n    message.hash = (_object$hash2 = object.hash) !== null && _object$hash2 !== void 0 ? _object$hash2 : 0;\n    message.prefix = (_object$prefix2 = object.prefix) !== null && _object$prefix2 !== void 0 ? _object$prefix2 : new Uint8Array();\n    message.suffix = (_object$suffix = object.suffix) !== null && _object$suffix !== void 0 ? _object$suffix : new Uint8Array();\n    return message;\n  }\n};\nfunction createBaseProofSpec() {\n  return {\n    leafSpec: undefined,\n    innerSpec: undefined,\n    maxDepth: 0,\n    minDepth: 0,\n    prehashKeyBeforeComparison: false\n  };\n}\nexport const ProofSpec = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.leafSpec !== undefined) {\n      LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.innerSpec !== undefined) {\n      InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.maxDepth !== 0) {\n      writer.uint32(24).int32(message.maxDepth);\n    }\n    if (message.minDepth !== 0) {\n      writer.uint32(32).int32(message.minDepth);\n    }\n    if (message.prehashKeyBeforeComparison === true) {\n      writer.uint32(40).bool(message.prehashKeyBeforeComparison);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofSpec();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.leafSpec = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.innerSpec = InnerSpec.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.maxDepth = reader.int32();\n          break;\n        case 4:\n          message.minDepth = reader.int32();\n          break;\n        case 5:\n          message.prehashKeyBeforeComparison = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      leafSpec: isSet(object.leafSpec) ? LeafOp.fromJSON(object.leafSpec) : undefined,\n      innerSpec: isSet(object.innerSpec) ? InnerSpec.fromJSON(object.innerSpec) : undefined,\n      maxDepth: isSet(object.maxDepth) ? Number(object.maxDepth) : 0,\n      minDepth: isSet(object.minDepth) ? Number(object.minDepth) : 0,\n      prehashKeyBeforeComparison: isSet(object.prehashKeyBeforeComparison) ? Boolean(object.prehashKeyBeforeComparison) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.leafSpec !== undefined && (obj.leafSpec = message.leafSpec ? LeafOp.toJSON(message.leafSpec) : undefined);\n    message.innerSpec !== undefined && (obj.innerSpec = message.innerSpec ? InnerSpec.toJSON(message.innerSpec) : undefined);\n    message.maxDepth !== undefined && (obj.maxDepth = Math.round(message.maxDepth));\n    message.minDepth !== undefined && (obj.minDepth = Math.round(message.minDepth));\n    message.prehashKeyBeforeComparison !== undefined && (obj.prehashKeyBeforeComparison = message.prehashKeyBeforeComparison);\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$maxDepth, _object$minDepth, _object$prehashKeyBef;\n    const message = createBaseProofSpec();\n    message.leafSpec = object.leafSpec !== undefined && object.leafSpec !== null ? LeafOp.fromPartial(object.leafSpec) : undefined;\n    message.innerSpec = object.innerSpec !== undefined && object.innerSpec !== null ? InnerSpec.fromPartial(object.innerSpec) : undefined;\n    message.maxDepth = (_object$maxDepth = object.maxDepth) !== null && _object$maxDepth !== void 0 ? _object$maxDepth : 0;\n    message.minDepth = (_object$minDepth = object.minDepth) !== null && _object$minDepth !== void 0 ? _object$minDepth : 0;\n    message.prehashKeyBeforeComparison = (_object$prehashKeyBef = object.prehashKeyBeforeComparison) !== null && _object$prehashKeyBef !== void 0 ? _object$prehashKeyBef : false;\n    return message;\n  }\n};\nfunction createBaseInnerSpec() {\n  return {\n    childOrder: [],\n    childSize: 0,\n    minPrefixLength: 0,\n    maxPrefixLength: 0,\n    emptyChild: new Uint8Array(),\n    hash: 0\n  };\n}\nexport const InnerSpec = {\n  encode(message, writer = _m0.Writer.create()) {\n    writer.uint32(10).fork();\n    for (const v of message.childOrder) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.childSize !== 0) {\n      writer.uint32(16).int32(message.childSize);\n    }\n    if (message.minPrefixLength !== 0) {\n      writer.uint32(24).int32(message.minPrefixLength);\n    }\n    if (message.maxPrefixLength !== 0) {\n      writer.uint32(32).int32(message.maxPrefixLength);\n    }\n    if (message.emptyChild.length !== 0) {\n      writer.uint32(42).bytes(message.emptyChild);\n    }\n    if (message.hash !== 0) {\n      writer.uint32(48).int32(message.hash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseInnerSpec();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.childOrder.push(reader.int32());\n            }\n          } else {\n            message.childOrder.push(reader.int32());\n          }\n          break;\n        case 2:\n          message.childSize = reader.int32();\n          break;\n        case 3:\n          message.minPrefixLength = reader.int32();\n          break;\n        case 4:\n          message.maxPrefixLength = reader.int32();\n          break;\n        case 5:\n          message.emptyChild = reader.bytes();\n          break;\n        case 6:\n          message.hash = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      childOrder: Array.isArray(object === null || object === void 0 ? void 0 : object.childOrder) ? object.childOrder.map(e => Number(e)) : [],\n      childSize: isSet(object.childSize) ? Number(object.childSize) : 0,\n      minPrefixLength: isSet(object.minPrefixLength) ? Number(object.minPrefixLength) : 0,\n      maxPrefixLength: isSet(object.maxPrefixLength) ? Number(object.maxPrefixLength) : 0,\n      emptyChild: isSet(object.emptyChild) ? bytesFromBase64(object.emptyChild) : new Uint8Array(),\n      hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.childOrder) {\n      obj.childOrder = message.childOrder.map(e => Math.round(e));\n    } else {\n      obj.childOrder = [];\n    }\n    message.childSize !== undefined && (obj.childSize = Math.round(message.childSize));\n    message.minPrefixLength !== undefined && (obj.minPrefixLength = Math.round(message.minPrefixLength));\n    message.maxPrefixLength !== undefined && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));\n    message.emptyChild !== undefined && (obj.emptyChild = base64FromBytes(message.emptyChild !== undefined ? message.emptyChild : new Uint8Array()));\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$childOrder, _object$childSize, _object$minPrefixLeng, _object$maxPrefixLeng, _object$emptyChild, _object$hash3;\n    const message = createBaseInnerSpec();\n    message.childOrder = ((_object$childOrder = object.childOrder) === null || _object$childOrder === void 0 ? void 0 : _object$childOrder.map(e => e)) || [];\n    message.childSize = (_object$childSize = object.childSize) !== null && _object$childSize !== void 0 ? _object$childSize : 0;\n    message.minPrefixLength = (_object$minPrefixLeng = object.minPrefixLength) !== null && _object$minPrefixLeng !== void 0 ? _object$minPrefixLeng : 0;\n    message.maxPrefixLength = (_object$maxPrefixLeng = object.maxPrefixLength) !== null && _object$maxPrefixLeng !== void 0 ? _object$maxPrefixLeng : 0;\n    message.emptyChild = (_object$emptyChild = object.emptyChild) !== null && _object$emptyChild !== void 0 ? _object$emptyChild : new Uint8Array();\n    message.hash = (_object$hash3 = object.hash) !== null && _object$hash3 !== void 0 ? _object$hash3 : 0;\n    return message;\n  }\n};\nfunction createBaseBatchProof() {\n  return {\n    entries: []\n  };\n}\nexport const BatchProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    for (const v of message.entries) {\n      BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBatchProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(BatchEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map(e => BatchEntry.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? BatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$entries;\n    const message = createBaseBatchProof();\n    message.entries = ((_object$entries = object.entries) === null || _object$entries === void 0 ? void 0 : _object$entries.map(e => BatchEntry.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nexport const BatchEntry = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBatchEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      exist: isSet(object.exist) ? ExistenceProof.fromJSON(object.exist) : undefined,\n      nonexist: isSet(object.nonexist) ? NonExistenceProof.fromJSON(object.nonexist) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? NonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = createBaseBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nfunction createBaseCompressedBatchProof() {\n  return {\n    entries: [],\n    lookupInners: []\n  };\n}\nexport const CompressedBatchProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    for (const v of message.entries) {\n      CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.lookupInners) {\n      InnerOp.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompressedBatchProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(CompressedBatchEntry.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.lookupInners.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map(e => CompressedBatchEntry.fromJSON(e)) : [],\n      lookupInners: Array.isArray(object === null || object === void 0 ? void 0 : object.lookupInners) ? object.lookupInners.map(e => InnerOp.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? CompressedBatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    if (message.lookupInners) {\n      obj.lookupInners = message.lookupInners.map(e => e ? InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.lookupInners = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$entries2, _object$lookupInners;\n    const message = createBaseCompressedBatchProof();\n    message.entries = ((_object$entries2 = object.entries) === null || _object$entries2 === void 0 ? void 0 : _object$entries2.map(e => CompressedBatchEntry.fromPartial(e))) || [];\n    message.lookupInners = ((_object$lookupInners = object.lookupInners) === null || _object$lookupInners === void 0 ? void 0 : _object$lookupInners.map(e => InnerOp.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseCompressedBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nexport const CompressedBatchEntry = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.exist !== undefined) {\n      CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompressedBatchEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = CompressedNonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      exist: isSet(object.exist) ? CompressedExistenceProof.fromJSON(object.exist) : undefined,\n      nonexist: isSet(object.nonexist) ? CompressedNonExistenceProof.fromJSON(object.nonexist) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? CompressedExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? CompressedNonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = createBaseCompressedBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? CompressedExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? CompressedNonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nfunction createBaseCompressedExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: undefined,\n    path: []\n  };\n}\nexport const CompressedExistenceProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    writer.uint32(34).fork();\n    for (const v of message.path) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompressedExistenceProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),\n      leaf: isSet(object.leaf) ? LeafOp.fromJSON(object.leaf) : undefined,\n      path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map(e => Number(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? LeafOp.toJSON(message.leaf) : undefined);\n    if (message.path) {\n      obj.path = message.path.map(e => Math.round(e));\n    } else {\n      obj.path = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$key3, _object$value2, _object$path2;\n    const message = createBaseCompressedExistenceProof();\n    message.key = (_object$key3 = object.key) !== null && _object$key3 !== void 0 ? _object$key3 : new Uint8Array();\n    message.value = (_object$value2 = object.value) !== null && _object$value2 !== void 0 ? _object$value2 : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path2 = object.path) === null || _object$path2 === void 0 ? void 0 : _object$path2.map(e => e)) || [];\n    return message;\n  }\n};\nfunction createBaseCompressedNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: undefined,\n    right: undefined\n  };\n}\nexport const CompressedNonExistenceProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompressedNonExistenceProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      left: isSet(object.left) ? CompressedExistenceProof.fromJSON(object.left) : undefined,\n      right: isSet(object.right) ? CompressedExistenceProof.fromJSON(object.right) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? CompressedExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? CompressedExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$key4;\n    const message = createBaseCompressedNonExistenceProof();\n    message.key = (_object$key4 = object.key) !== null && _object$key4 !== void 0 ? _object$key4 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? CompressedExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? CompressedExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};", "import { CommitmentProof } from \"../../../../cosmos/ics23/v1/proofs\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { isSet, bytesFromBase64, base64FromBytes } from \"../../../../helpers\";\n/**\n * MerkleRoot defines a merkle root hash.\n * In the Cosmos SDK, the AppHash of a block header becomes the root.\n */\n\n/**\n * MerkleRoot defines a merkle root hash.\n * In the Cosmos SDK, the AppHash of a block header becomes the root.\n */\n\n/**\n * MerklePrefix is merkle path prefixed to the key.\n * The constructed key from the Path and the key will be append(Path.KeyPath,\n * append(Path.KeyPrefix, key...))\n */\n\n/**\n * MerklePrefix is merkle path prefixed to the key.\n * The constructed key from the Path and the key will be append(Path.KeyPath,\n * append(Path.KeyPrefix, key...))\n */\n\n/**\n * MerklePath is the path used to verify commitment proofs, which can be an\n * arbitrary structured object (defined by a commitment type).\n * MerklePath is represented from root-to-leaf\n */\n\n/**\n * MerklePath is the path used to verify commitment proofs, which can be an\n * arbitrary structured object (defined by a commitment type).\n * MerklePath is represented from root-to-leaf\n */\n\n/**\n * MerkleProof is a wrapper type over a chain of CommitmentProofs.\n * It demonstrates membership or non-membership for an element or set of\n * elements, verifiable in conjunction with a known commitment root. Proofs\n * should be succinct.\n * MerkleProofs are ordered from leaf-to-root\n */\n\n/**\n * MerkleProof is a wrapper type over a chain of CommitmentProofs.\n * It demonstrates membership or non-membership for an element or set of\n * elements, verifiable in conjunction with a known commitment root. Proofs\n * should be succinct.\n * MerkleProofs are ordered from leaf-to-root\n */\n\nfunction createBaseMerkleRoot() {\n  return {\n    hash: new Uint8Array()\n  };\n}\nexport const MerkleRoot = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMerkleRoot();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array()\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$hash;\n    const message = createBaseMerkleRoot();\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : new Uint8Array();\n    return message;\n  }\n};\nfunction createBaseMerklePrefix() {\n  return {\n    keyPrefix: new Uint8Array()\n  };\n}\nexport const MerklePrefix = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.keyPrefix.length !== 0) {\n      writer.uint32(10).bytes(message.keyPrefix);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMerklePrefix();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.keyPrefix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      keyPrefix: isSet(object.keyPrefix) ? bytesFromBase64(object.keyPrefix) : new Uint8Array()\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.keyPrefix !== undefined && (obj.keyPrefix = base64FromBytes(message.keyPrefix !== undefined ? message.keyPrefix : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$keyPrefix;\n    const message = createBaseMerklePrefix();\n    message.keyPrefix = (_object$keyPrefix = object.keyPrefix) !== null && _object$keyPrefix !== void 0 ? _object$keyPrefix : new Uint8Array();\n    return message;\n  }\n};\nfunction createBaseMerklePath() {\n  return {\n    keyPath: []\n  };\n}\nexport const MerklePath = {\n  encode(message, writer = _m0.Writer.create()) {\n    for (const v of message.keyPath) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMerklePath();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.keyPath.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      keyPath: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPath) ? object.keyPath.map(e => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.keyPath) {\n      obj.keyPath = message.keyPath.map(e => e);\n    } else {\n      obj.keyPath = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$keyPath;\n    const message = createBaseMerklePath();\n    message.keyPath = ((_object$keyPath = object.keyPath) === null || _object$keyPath === void 0 ? void 0 : _object$keyPath.map(e => e)) || [];\n    return message;\n  }\n};\nfunction createBaseMerkleProof() {\n  return {\n    proofs: []\n  };\n}\nexport const MerkleProof = {\n  encode(message, writer = _m0.Writer.create()) {\n    for (const v of message.proofs) {\n      CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMerkleProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proofs.push(CommitmentProof.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      proofs: Array.isArray(object === null || object === void 0 ? void 0 : object.proofs) ? object.proofs.map(e => CommitmentProof.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.proofs) {\n      obj.proofs = message.proofs.map(e => e ? CommitmentProof.toJSON(e) : undefined);\n    } else {\n      obj.proofs = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$proofs;\n    const message = createBaseMerkleProof();\n    message.proofs = ((_object$proofs = object.proofs) === null || _object$proofs === void 0 ? void 0 : _object$proofs.map(e => CommitmentProof.fromPartial(e))) || [];\n    return message;\n  }\n};", "import { MerklePrefix } from \"../../commitment/v1/commitment\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Long, isSet } from \"../../../../helpers\";\n/**\n * State defines if a connection is in one of the following states:\n * INIT, TRYOPEN, OPEN or UNINITIALIZED.\n */\nexport let State = /*#__PURE__*/function (State) {\n  State[State[\"STATE_UNINITIALIZED_UNSPECIFIED\"] = 0] = \"STATE_UNINITIALIZED_UNSPECIFIED\";\n  State[State[\"STATE_INIT\"] = 1] = \"STATE_INIT\";\n  State[State[\"STATE_TRYOPEN\"] = 2] = \"STATE_TRYOPEN\";\n  State[State[\"STATE_OPEN\"] = 3] = \"STATE_OPEN\";\n  State[State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n  return State;\n}({});\nexport const StateSDKType = State;\nexport function stateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"STATE_UNINITIALIZED_UNSPECIFIED\":\n      return State.STATE_UNINITIALIZED_UNSPECIFIED;\n    case 1:\n    case \"STATE_INIT\":\n      return State.STATE_INIT;\n    case 2:\n    case \"STATE_TRYOPEN\":\n      return State.STATE_TRYOPEN;\n    case 3:\n    case \"STATE_OPEN\":\n      return State.STATE_OPEN;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return State.UNRECOGNIZED;\n  }\n}\nexport function stateToJSON(object) {\n  switch (object) {\n    case State.STATE_UNINITIALIZED_UNSPECIFIED:\n      return \"STATE_UNINITIALIZED_UNSPECIFIED\";\n    case State.STATE_INIT:\n      return \"STATE_INIT\";\n    case State.STATE_TRYOPEN:\n      return \"STATE_TRYOPEN\";\n    case State.STATE_OPEN:\n      return \"STATE_OPEN\";\n    case State.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * ConnectionEnd defines a stateful object on a chain connected to another\n * separate one.\n * NOTE: there must only be 2 defined ConnectionEnds to establish\n * a connection between two chains.\n */\n\n/**\n * ConnectionEnd defines a stateful object on a chain connected to another\n * separate one.\n * NOTE: there must only be 2 defined ConnectionEnds to establish\n * a connection between two chains.\n */\n\n/**\n * IdentifiedConnection defines a connection with additional connection\n * identifier field.\n */\n\n/**\n * IdentifiedConnection defines a connection with additional connection\n * identifier field.\n */\n\n/** Counterparty defines the counterparty chain associated with a connection end. */\n\n/** Counterparty defines the counterparty chain associated with a connection end. */\n\n/** ClientPaths define all the connection paths for a client state. */\n\n/** ClientPaths define all the connection paths for a client state. */\n\n/** ConnectionPaths define all the connection paths for a given client state. */\n\n/** ConnectionPaths define all the connection paths for a given client state. */\n\n/**\n * Version defines the versioning scheme used to negotiate the IBC verison in\n * the connection handshake.\n */\n\n/**\n * Version defines the versioning scheme used to negotiate the IBC verison in\n * the connection handshake.\n */\n\n/** Params defines the set of Connection parameters. */\n\n/** Params defines the set of Connection parameters. */\n\nfunction createBaseConnectionEnd() {\n  return {\n    clientId: \"\",\n    versions: [],\n    state: 0,\n    counterparty: undefined,\n    delayPeriod: BigInt(\"0\")\n  };\n}\nexport const ConnectionEnd = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    for (const v of message.versions) {\n      Version.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.state !== 0) {\n      writer.uint32(24).int32(message.state);\n    }\n    if (message.counterparty !== undefined) {\n      Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.delayPeriod !== BigInt(0)) {\n      writer.uint32(40).uint64(Long.fromString(message.delayPeriod.toString()));\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseConnectionEnd();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.versions.push(Version.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.state = reader.int32();\n          break;\n        case 4:\n          message.counterparty = Counterparty.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.delayPeriod = BigInt(reader.uint64().toString());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n      versions: Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map(e => Version.fromJSON(e)) : [],\n      state: isSet(object.state) ? stateFromJSON(object.state) : 0,\n      counterparty: isSet(object.counterparty) ? Counterparty.fromJSON(object.counterparty) : undefined,\n      delayPeriod: isSet(object.delayPeriod) ? BigInt(object.delayPeriod.toString()) : BigInt(\"0\")\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(\"0\")).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$clientId, _object$versions, _object$state;\n    const message = createBaseConnectionEnd();\n    message.clientId = (_object$clientId = object.clientId) !== null && _object$clientId !== void 0 ? _object$clientId : \"\";\n    message.versions = ((_object$versions = object.versions) === null || _object$versions === void 0 ? void 0 : _object$versions.map(e => Version.fromPartial(e))) || [];\n    message.state = (_object$state = object.state) !== null && _object$state !== void 0 ? _object$state : 0;\n    message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? Counterparty.fromPartial(object.counterparty) : undefined;\n    message.delayPeriod = object.delayPeriod !== undefined && object.delayPeriod !== null ? BigInt(object.delayPeriod.toString()) : BigInt(\"0\");\n    return message;\n  }\n};\nfunction createBaseIdentifiedConnection() {\n  return {\n    id: \"\",\n    clientId: \"\",\n    versions: [],\n    state: 0,\n    counterparty: undefined,\n    delayPeriod: BigInt(\"0\")\n  };\n}\nexport const IdentifiedConnection = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clientId !== \"\") {\n      writer.uint32(18).string(message.clientId);\n    }\n    for (const v of message.versions) {\n      Version.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.state !== 0) {\n      writer.uint32(32).int32(message.state);\n    }\n    if (message.counterparty !== undefined) {\n      Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.delayPeriod !== BigInt(0)) {\n      writer.uint32(48).uint64(Long.fromString(message.delayPeriod.toString()));\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseIdentifiedConnection();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.clientId = reader.string();\n          break;\n        case 3:\n          message.versions.push(Version.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.state = reader.int32();\n          break;\n        case 5:\n          message.counterparty = Counterparty.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.delayPeriod = BigInt(reader.uint64().toString());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet(object.id) ? String(object.id) : \"\",\n      clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n      versions: Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map(e => Version.fromJSON(e)) : [],\n      state: isSet(object.state) ? stateFromJSON(object.state) : 0,\n      counterparty: isSet(object.counterparty) ? Counterparty.fromJSON(object.counterparty) : undefined,\n      delayPeriod: isSet(object.delayPeriod) ? BigInt(object.delayPeriod.toString()) : BigInt(\"0\")\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== undefined && (obj.id = message.id);\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(\"0\")).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$id, _object$clientId2, _object$versions2, _object$state2;\n    const message = createBaseIdentifiedConnection();\n    message.id = (_object$id = object.id) !== null && _object$id !== void 0 ? _object$id : \"\";\n    message.clientId = (_object$clientId2 = object.clientId) !== null && _object$clientId2 !== void 0 ? _object$clientId2 : \"\";\n    message.versions = ((_object$versions2 = object.versions) === null || _object$versions2 === void 0 ? void 0 : _object$versions2.map(e => Version.fromPartial(e))) || [];\n    message.state = (_object$state2 = object.state) !== null && _object$state2 !== void 0 ? _object$state2 : 0;\n    message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? Counterparty.fromPartial(object.counterparty) : undefined;\n    message.delayPeriod = object.delayPeriod !== undefined && object.delayPeriod !== null ? BigInt(object.delayPeriod.toString()) : BigInt(\"0\");\n    return message;\n  }\n};\nfunction createBaseCounterparty() {\n  return {\n    clientId: \"\",\n    connectionId: \"\",\n    prefix: undefined\n  };\n}\nexport const Counterparty = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    if (message.connectionId !== \"\") {\n      writer.uint32(18).string(message.connectionId);\n    }\n    if (message.prefix !== undefined) {\n      MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCounterparty();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.connectionId = reader.string();\n          break;\n        case 3:\n          message.prefix = MerklePrefix.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n      connectionId: isSet(object.connectionId) ? String(object.connectionId) : \"\",\n      prefix: isSet(object.prefix) ? MerklePrefix.fromJSON(object.prefix) : undefined\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.prefix !== undefined && (obj.prefix = message.prefix ? MerklePrefix.toJSON(message.prefix) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$clientId3, _object$connectionId;\n    const message = createBaseCounterparty();\n    message.clientId = (_object$clientId3 = object.clientId) !== null && _object$clientId3 !== void 0 ? _object$clientId3 : \"\";\n    message.connectionId = (_object$connectionId = object.connectionId) !== null && _object$connectionId !== void 0 ? _object$connectionId : \"\";\n    message.prefix = object.prefix !== undefined && object.prefix !== null ? MerklePrefix.fromPartial(object.prefix) : undefined;\n    return message;\n  }\n};\nfunction createBaseClientPaths() {\n  return {\n    paths: []\n  };\n}\nexport const ClientPaths = {\n  encode(message, writer = _m0.Writer.create()) {\n    for (const v of message.paths) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseClientPaths();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.paths.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      paths: Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map(e => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$paths;\n    const message = createBaseClientPaths();\n    message.paths = ((_object$paths = object.paths) === null || _object$paths === void 0 ? void 0 : _object$paths.map(e => e)) || [];\n    return message;\n  }\n};\nfunction createBaseConnectionPaths() {\n  return {\n    clientId: \"\",\n    paths: []\n  };\n}\nexport const ConnectionPaths = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    for (const v of message.paths) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseConnectionPaths();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.paths.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n      paths: Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map(e => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$clientId4, _object$paths2;\n    const message = createBaseConnectionPaths();\n    message.clientId = (_object$clientId4 = object.clientId) !== null && _object$clientId4 !== void 0 ? _object$clientId4 : \"\";\n    message.paths = ((_object$paths2 = object.paths) === null || _object$paths2 === void 0 ? void 0 : _object$paths2.map(e => e)) || [];\n    return message;\n  }\n};\nfunction createBaseVersion() {\n  return {\n    identifier: \"\",\n    features: []\n  };\n}\nexport const Version = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.identifier !== \"\") {\n      writer.uint32(10).string(message.identifier);\n    }\n    for (const v of message.features) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVersion();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.identifier = reader.string();\n          break;\n        case 2:\n          message.features.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      identifier: isSet(object.identifier) ? String(object.identifier) : \"\",\n      features: Array.isArray(object === null || object === void 0 ? void 0 : object.features) ? object.features.map(e => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.identifier !== undefined && (obj.identifier = message.identifier);\n    if (message.features) {\n      obj.features = message.features.map(e => e);\n    } else {\n      obj.features = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$identifier, _object$features;\n    const message = createBaseVersion();\n    message.identifier = (_object$identifier = object.identifier) !== null && _object$identifier !== void 0 ? _object$identifier : \"\";\n    message.features = ((_object$features = object.features) === null || _object$features === void 0 ? void 0 : _object$features.map(e => e)) || [];\n    return message;\n  }\n};\nfunction createBaseParams() {\n  return {\n    maxExpectedTimePerBlock: BigInt(\"0\")\n  };\n}\nexport const Params = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.maxExpectedTimePerBlock !== BigInt(0)) {\n      writer.uint32(8).uint64(Long.fromString(message.maxExpectedTimePerBlock.toString()));\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.maxExpectedTimePerBlock = BigInt(reader.uint64().toString());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      maxExpectedTimePerBlock: isSet(object.maxExpectedTimePerBlock) ? BigInt(object.maxExpectedTimePerBlock.toString()) : BigInt(\"0\")\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.maxExpectedTimePerBlock !== undefined && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(\"0\")).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = createBaseParams();\n    message.maxExpectedTimePerBlock = object.maxExpectedTimePerBlock !== undefined && object.maxExpectedTimePerBlock !== null ? BigInt(object.maxExpectedTimePerBlock.toString()) : BigInt(\"0\");\n    return message;\n  }\n};"],
  "mappings": "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",
  "names": ["HashOp", "LengthOp", "_m0", "_m0", "State", "Long"]
}
