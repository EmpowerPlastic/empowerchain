import {
  query_exports as query_exports32,
  query_rpc_Query_exports as query_rpc_Query_exports30
} from "./chunk-54G5HQN3.js";
import {
  MsgPayPacketFee,
  MsgPayPacketFeeAsync,
  MsgRegisterCounterpartyPayee,
  MsgRegisterPayee,
  tx_exports as tx_exports23,
  tx_rpc_msg_exports as tx_rpc_msg_exports22
} from "./chunk-WXO4LDNY.js";
import {
  MsgRegisterInterchainAccount,
  MsgSendTx,
  packet_exports,
  tx_exports as tx_exports24,
  tx_rpc_msg_exports as tx_rpc_msg_exports23,
  typeFromJSON
} from "./chunk-H77UCQPP.js";
import {
  MsgTransfer,
  tx_exports as tx_exports25,
  tx_rpc_msg_exports as tx_rpc_msg_exports24
} from "./chunk-XMNLCDD7.js";
import {
  MsgAcknowledgement,
  MsgChannelCloseConfirm,
  MsgChannelCloseInit,
  MsgChannelOpenAck,
  MsgChannelOpenConfirm,
  MsgChannelOpenInit,
  MsgChannelOpenTry,
  MsgRecvPacket,
  MsgTimeout,
  MsgTimeoutOnClose,
  tx_exports as tx_exports26,
  tx_rpc_msg_exports as tx_rpc_msg_exports25
} from "./chunk-JLOYDEL7.js";
import {
  MsgCreateClient,
  MsgSubmitMisbehaviour,
  MsgUpdateClient,
  MsgUpgradeClient,
  tx_exports as tx_exports27,
  tx_rpc_msg_exports as tx_rpc_msg_exports26
} from "./chunk-7AG75TEV.js";
import {
  MsgConnectionOpenAck,
  MsgConnectionOpenConfirm,
  MsgConnectionOpenInit,
  MsgConnectionOpenTry,
  tx_exports as tx_exports28,
  tx_rpc_msg_exports as tx_rpc_msg_exports27
} from "./chunk-YFN4IYLT.js";
import {
  ConnectionEnd,
  ConnectionPaths,
  IdentifiedConnection,
  MerkleRoot,
  Params as Params15,
  ProofSpec,
  commitment_exports,
  connection_exports,
  proofs_exports
} from "./chunk-IBRIQSA5.js";
import {
  MsgApproveProject,
  MsgCreateApplicant,
  MsgCreateCreditType,
  MsgCreateIssuer,
  MsgCreateProject,
  MsgIssueCredits,
  MsgRejectProject,
  MsgRetireCredits,
  MsgSuspendProject,
  MsgTransferCredits,
  MsgUpdateApplicant,
  MsgUpdateCreditType,
  MsgUpdateIssuer,
  MsgUpdateParams as MsgUpdateParams12,
  MsgUpdateProject,
  tx_exports as tx_exports21,
  tx_rpc_msg_exports as tx_rpc_msg_exports20
} from "./chunk-TMBFTG73.js";
import {
  MsgCreateProof,
  tx_exports as tx_exports22,
  tx_rpc_msg_exports as tx_rpc_msg_exports21
} from "./chunk-KUGAQWOG.js";
import {
  genesis_exports,
  query_exports as query_exports26,
  query_rpc_Query_exports as query_rpc_Query_exports24
} from "./chunk-SDEZEJWK.js";
import {
  fee_exports
} from "./chunk-LT4HFK7R.js";
import {
  Params as Params12,
  controller_exports,
  query_exports as query_exports27,
  query_rpc_Query_exports as query_rpc_Query_exports25
} from "./chunk-KGDDXVR3.js";
import {
  Params as Params13,
  host_exports,
  query_exports as query_exports28,
  query_rpc_Query_exports as query_rpc_Query_exports26
} from "./chunk-X2M55673.js";
import {
  DenomTrace,
  Params as Params14,
  query_exports as query_exports29,
  query_rpc_Query_exports as query_rpc_Query_exports27,
  transfer_exports
} from "./chunk-IWH4GOH2.js";
import {
  query_exports as query_exports30,
  query_rpc_Query_exports as query_rpc_Query_exports28
} from "./chunk-TPFOTVEA.js";
import {
  Channel,
  IdentifiedChannel,
  PacketState,
  channel_exports,
  orderFromJSON,
  stateFromJSON
} from "./chunk-3SYTEMXM.js";
import {
  query_exports as query_exports31,
  query_rpc_Query_exports as query_rpc_Query_exports29
} from "./chunk-IG6M2UQO.js";
import {
  ClientConsensusStates,
  Height,
  IdentifiedClientState,
  Params as Params11,
  client_exports
} from "./chunk-2L6AETVN.js";
import {
  MsgCancelUpgrade,
  MsgSoftwareUpgrade,
  tx_exports as tx_exports17,
  tx_rpc_msg_exports as tx_rpc_msg_exports16
} from "./chunk-C3UAW7AZ.js";
import {
  MsgCreatePeriodicVestingAccount,
  MsgCreatePermanentLockedAccount,
  MsgCreateVestingAccount,
  tx_exports as tx_exports18,
  tx_rpc_msg_exports as tx_rpc_msg_exports17,
  vesting_exports
} from "./chunk-DLSKLEVI.js";
import {
  query_exports as query_exports22,
  query_rpc_Query_exports as query_rpc_Query_exports20
} from "./chunk-YDFPY2KV.js";
import {
  MsgClearAdmin,
  MsgExecuteContract,
  MsgInstantiateContract,
  MsgInstantiateContract2,
  MsgMigrateContract,
  MsgPinCodes,
  MsgStoreAndInstantiateContract,
  MsgStoreCode,
  MsgSudoContract,
  MsgUnpinCodes,
  MsgUpdateAdmin,
  MsgUpdateInstantiateConfig,
  MsgUpdateParams as MsgUpdateParams10,
  tx_exports as tx_exports19,
  tx_rpc_msg_exports as tx_rpc_msg_exports18
} from "./chunk-V7NAUS23.js";
import {
  AccessConfig,
  CodeInfo,
  ContractCodeHistoryEntry,
  ContractInfo,
  Model,
  Params as Params8,
  accessTypeFromJSON,
  types_exports as types_exports7
} from "./chunk-3WIAPAME.js";
import {
  query_exports as query_exports23,
  query_rpc_Query_exports as query_rpc_Query_exports21
} from "./chunk-V5UHBU56.js";
import {
  query_exports as query_exports24,
  query_rpc_Query_exports as query_rpc_Query_exports22
} from "./chunk-74QWUAKM.js";
import {
  Applicant,
  CreditBalance,
  CreditCollection,
  CreditType,
  IDCounters as IDCounters2,
  Issuer,
  Params as Params10,
  Project,
  types_exports as types_exports9
} from "./chunk-CMRKTJPJ.js";
import {
  ProofMetadata,
  query_exports as query_exports25,
  query_rpc_Query_exports as query_rpc_Query_exports23,
  types_exports as types_exports10
} from "./chunk-OSFJKPGL.js";
import {
  MsgCreateCertificate,
  MsgUpdateParams as MsgUpdateParams11,
  tx_exports as tx_exports20,
  tx_rpc_msg_exports as tx_rpc_msg_exports19
} from "./chunk-6WCII5A6.js";
import {
  Certificate,
  IDCounters,
  Params as Params9,
  certificateTypeFromJSON,
  types_exports as types_exports8
} from "./chunk-BYYZD52L.js";
import {
  MsgGrantAllowance,
  MsgRevokeAllowance,
  tx_exports as tx_exports8,
  tx_rpc_msg_exports as tx_rpc_msg_exports8
} from "./chunk-NDKEPCDV.js";
import {
  MsgDeposit,
  MsgExecLegacyContent,
  MsgSubmitProposal,
  MsgUpdateParams as MsgUpdateParams6,
  MsgVote,
  MsgVoteWeighted,
  tx_exports as tx_exports9,
  tx_rpc_msg_exports as tx_rpc_msg_exports9
} from "./chunk-X4J3SKPX.js";
import {
  MsgDeposit as MsgDeposit2,
  MsgSubmitProposal as MsgSubmitProposal2,
  MsgVote as MsgVote2,
  MsgVoteWeighted as MsgVoteWeighted2,
  tx_exports as tx_exports10,
  tx_rpc_msg_exports as tx_rpc_msg_exports10
} from "./chunk-4T6EMXMG.js";
import {
  MsgCreateGroup,
  MsgCreateGroupPolicy,
  MsgCreateGroupWithPolicy,
  MsgExec as MsgExec2,
  MsgLeaveGroup,
  MsgSubmitProposal as MsgSubmitProposal3,
  MsgUpdateGroupAdmin,
  MsgUpdateGroupMembers,
  MsgUpdateGroupMetadata,
  MsgUpdateGroupPolicyAdmin,
  MsgUpdateGroupPolicyDecisionPolicy,
  MsgUpdateGroupPolicyMetadata,
  MsgVote as MsgVote3,
  MsgWithdrawProposal,
  execFromJSON,
  tx_exports as tx_exports11,
  tx_rpc_msg_exports as tx_rpc_msg_exports11
} from "./chunk-YHYQSQ2U.js";
import {
  MsgUpdateParams as MsgUpdateParams7,
  tx_exports as tx_exports12,
  tx_rpc_msg_exports as tx_rpc_msg_exports12
} from "./chunk-N7PAGRDR.js";
import {
  MsgSend as MsgSend2,
  tx_exports as tx_exports13,
  tx_rpc_msg_exports as tx_rpc_msg_exports13
} from "./chunk-RJZUTQN5.js";
import {
  MsgUnjail,
  MsgUpdateParams as MsgUpdateParams8,
  tx_exports as tx_exports14,
  tx_rpc_msg_exports as tx_rpc_msg_exports14
} from "./chunk-XULBIQDR.js";
import {
  MsgBeginRedelegate,
  MsgCancelUnbondingDelegation,
  MsgCreateValidator,
  MsgDelegate,
  MsgEditValidator,
  MsgUndelegate,
  MsgUpdateParams as MsgUpdateParams9,
  tx_exports as tx_exports15,
  tx_rpc_msg_exports as tx_rpc_msg_exports15
} from "./chunk-QDW3SHM5.js";
import {
  query_exports as query_exports21,
  query_rpc_Query_exports as query_rpc_Query_exports19
} from "./chunk-XJVIJOQC.js";
import {
  upgrade_exports
} from "./chunk-WUOSB4IU.js";
import {
  MsgUpdateParams,
  tx_exports,
  tx_rpc_msg_exports
} from "./chunk-XTNJQY3M.js";
import {
  MsgExec,
  MsgGrant,
  MsgRevoke,
  tx_exports as tx_exports2,
  tx_rpc_msg_exports as tx_rpc_msg_exports2
} from "./chunk-RE277WCV.js";
import {
  MsgMultiSend,
  MsgSend,
  MsgSetSendEnabled,
  MsgUpdateParams as MsgUpdateParams2,
  tx_exports as tx_exports3,
  tx_rpc_msg_exports as tx_rpc_msg_exports3
} from "./chunk-A7SKQHDH.js";
import {
  MsgUpdateParams as MsgUpdateParams3,
  tx_exports as tx_exports4,
  tx_rpc_msg_exports as tx_rpc_msg_exports4
} from "./chunk-BBICF5OG.js";
import {
  MsgUpdateParams as MsgUpdateParams4,
  MsgVerifyInvariant,
  tx_exports as tx_exports5,
  tx_rpc_msg_exports as tx_rpc_msg_exports5
} from "./chunk-BJKDCRKD.js";
import {
  MsgCommunityPoolSpend,
  MsgFundCommunityPool,
  MsgSetWithdrawAddress,
  MsgUpdateParams as MsgUpdateParams5,
  MsgWithdrawDelegatorReward,
  MsgWithdrawValidatorCommission,
  tx_exports as tx_exports6,
  tx_rpc_msg_exports as tx_rpc_msg_exports6
} from "./chunk-UZYN35V3.js";
import {
  MsgSubmitEvidence,
  tx_exports as tx_exports7,
  tx_rpc_msg_exports as tx_rpc_msg_exports7
} from "./chunk-IZM7ERV4.js";
import {
  query_exports as query_exports14,
  query_rpc_Query_exports as query_rpc_Query_exports12
} from "./chunk-L7JN62BA.js";
import {
  GroupInfo,
  GroupMember,
  GroupPolicyInfo,
  Proposal as Proposal3,
  Vote as Vote3,
  proposalExecutorResultFromJSON,
  proposalExecutorResultToJSON,
  types_exports as types_exports6,
  voteOptionFromJSON as voteOptionFromJSON3
} from "./chunk-L53VIPL5.js";
import {
  query_exports as query_exports15,
  query_rpc_Query_exports as query_rpc_Query_exports13
} from "./chunk-Y3YMY2YA.js";
import {
  Minter,
  Params as Params5,
  mint_exports
} from "./chunk-TKRH3FEW.js";
import {
  Class,
  NFT,
  nft_exports,
  query_exports as query_exports16,
  query_rpc_Query_exports as query_rpc_Query_exports14
} from "./chunk-3W5YYHOY.js";
import {
  query_exports as query_exports17,
  query_rpc_Query_exports as query_rpc_Query_exports15
} from "./chunk-7OJNORI4.js";
import {
  params_exports as params_exports2,
  query_exports as query_exports18,
  query_rpc_Query_exports as query_rpc_Query_exports16
} from "./chunk-F4TWKZWE.js";
import {
  query_exports as query_exports19,
  query_rpc_Query_exports as query_rpc_Query_exports17
} from "./chunk-ISO7IHWX.js";
import {
  Params as Params6,
  ValidatorSigningInfo,
  slashing_exports
} from "./chunk-IT373EAN.js";
import {
  query_exports as query_exports20,
  query_rpc_Query_exports as query_rpc_Query_exports18
} from "./chunk-TPCOKMRL.js";
import {
  Delegation,
  Params as Params7,
  Redelegation,
  UnbondingDelegation,
  Validator,
  staking_exports
} from "./chunk-TFL62YBX.js";
import {
  abci_exports,
  service_exports,
  service_rpc_Service_exports,
  signing_exports,
  tx_exports as tx_exports16
} from "./chunk-A5R2FICF.js";
import {
  RequestBeginBlock,
  RequestDeliverTx,
  RequestEndBlock,
  ResponseBeginBlock,
  ResponseCommit,
  ResponseDeliverTx,
  ResponseEndBlock,
  types_exports as types_exports3
} from "./chunk-KDGHQXW3.js";
import {
  query_exports as query_exports6,
  query_rpc_Service_exports
} from "./chunk-K2X5ENX7.js";
import {
  query_exports as query_exports7,
  query_rpc_Service_exports as query_rpc_Service_exports2,
  types_exports as types_exports4,
  types_exports2 as types_exports5
} from "./chunk-GZLWUJVJ.js";
import {
  block_exports,
  evidence_exports
} from "./chunk-K2MBWG3Y.js";
import {
  SignedHeader,
  ValidatorSet,
  keys_exports,
  proof_exports,
  types_exports,
  types_exports2,
  validator_exports
} from "./chunk-OOMJJQEG.js";
import {
  query_exports as query_exports8,
  query_rpc_Query_exports as query_rpc_Query_exports6
} from "./chunk-34OK37KG.js";
import {
  params_exports
} from "./chunk-EHVQXC43.js";
import {
  query_exports as query_exports9,
  query_rpc_Query_exports as query_rpc_Query_exports7
} from "./chunk-7FKGN4LL.js";
import {
  DelegatorStartingInfo,
  FeePool,
  Params as Params3,
  ValidatorAccumulatedCommission,
  ValidatorCurrentRewards,
  ValidatorHistoricalRewards,
  ValidatorSlashEvent,
  distribution_exports
} from "./chunk-N6SVBLOC.js";
import {
  query_exports as query_exports10,
  query_rpc_Query_exports as query_rpc_Query_exports8
} from "./chunk-ENXPP7RZ.js";
import {
  Grant,
  feegrant_exports,
  query_exports as query_exports11,
  query_rpc_Query_exports as query_rpc_Query_exports9
} from "./chunk-KHVHGPZA.js";
import {
  query_exports as query_exports12,
  query_rpc_Query_exports as query_rpc_Query_exports10
} from "./chunk-242KJG33.js";
import {
  Deposit,
  DepositParams,
  Params as Params4,
  Proposal,
  TallyParams,
  Vote,
  VotingParams,
  gov_exports,
  voteOptionFromJSON
} from "./chunk-CFHQPDQ2.js";
import {
  query_exports as query_exports13,
  query_rpc_Query_exports as query_rpc_Query_exports11
} from "./chunk-YSFU3BYN.js";
import {
  Deposit as Deposit2,
  DepositParams as DepositParams2,
  Proposal as Proposal2,
  TallyParams as TallyParams2,
  Vote as Vote2,
  VotingParams as VotingParams2,
  gov_exports as gov_exports2,
  voteOptionFromJSON as voteOptionFromJSON2
} from "./chunk-B3OJ4FZV.js";
import {
  Duration,
  duration_exports
} from "./chunk-J33TOWTN.js";
import {
  config_exports,
  query_exports,
  query_rpc_Query_exports
} from "./chunk-XAUN5SM7.js";
import {
  query_exports as query_exports2,
  query_rpc_Query_exports as query_rpc_Query_exports2
} from "./chunk-AREVYSNK.js";
import {
  BaseAccount,
  Params,
  auth_exports
} from "./chunk-V33XUOV5.js";
import {
  query_exports as query_exports3,
  query_rpc_Query_exports as query_rpc_Query_exports3
} from "./chunk-HF7YQEBD.js";
import {
  GrantAuthorization,
  authz_exports
} from "./chunk-U55UB7IY.js";
import {
  Timestamp,
  timestamp_exports
} from "./chunk-NOD7AVEV.js";
import {
  Any,
  any_exports
} from "./chunk-5CF6M437.js";
import {
  options_exports,
  query_exports as query_exports4,
  query_rpc_Query_exports as query_rpc_Query_exports4
} from "./chunk-XNPBZEXJ.js";
import {
  query_exports as query_exports5,
  query_rpc_Query_exports as query_rpc_Query_exports5
} from "./chunk-6KOJOPAE.js";
import {
  Metadata,
  Params as Params2,
  SendEnabled,
  bank_exports
} from "./chunk-EWPXETRV.js";
import {
  Coin,
  DecCoin,
  coin_exports
} from "./chunk-S5OVV5FT.js";
import {
  pagination_exports
} from "./chunk-PJKHK357.js";
import {
  require_any,
  require_build,
  require_build2,
  require_build3,
  require_build4,
  require_build5,
  require_build6,
  require_build7,
  require_build8,
  require_coin,
  require_helpers,
  require_pagination,
  require_signing,
  require_tx,
  require_tx2,
  require_tx3
} from "./chunk-2STNDH4F.js";
import {
  base64FromBytes,
  bytesFromBase64,
  fromJsonTimestamp,
  fromTimestamp,
  import_long,
  isSet,
  omitDefault,
  require_long,
  require_minimal,
  toTimestamp
} from "./chunk-YTDFOCYR.js";
import "./chunk-5SHKMPQI.js";
import {
  _defineProperty
} from "./chunk-65WSFKMD.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-I7XXR53E.js";

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jsonschema/lib/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/jsonschema/lib/helpers.js"(exports, module) {
    "use strict";
    var uri = require_url();
    var ValidationError = exports.ValidationError = function ValidationError2(message, instance, schema, path, name, argument) {
      if (Array.isArray(path)) {
        this.path = path;
        this.property = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else if (path !== void 0) {
        this.property = path;
      }
      if (message) {
        this.message = message;
      }
      if (schema) {
        var id = schema.$id || schema.id;
        this.schema = id || schema;
      }
      if (instance !== void 0) {
        this.instance = instance;
      }
      this.name = name;
      this.argument = argument;
      this.stack = this.toString();
    };
    ValidationError.prototype.toString = function toString() {
      return this.property + " " + this.message;
    };
    var ValidatorResult = exports.ValidatorResult = function ValidatorResult2(instance, schema, options, ctx) {
      this.instance = instance;
      this.schema = schema;
      this.options = options;
      this.path = ctx.path;
      this.propertyPath = ctx.propertyPath;
      this.errors = [];
      this.throwError = options && options.throwError;
      this.throwFirst = options && options.throwFirst;
      this.throwAll = options && options.throwAll;
      this.disableFormat = options && options.disableFormat === true;
    };
    ValidatorResult.prototype.addError = function addError(detail) {
      var err;
      if (typeof detail == "string") {
        err = new ValidationError(detail, this.instance, this.schema, this.path);
      } else {
        if (!detail)
          throw new Error("Missing error detail");
        if (!detail.message)
          throw new Error("Missing error message");
        if (!detail.name)
          throw new Error("Missing validator type");
        err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);
      }
      this.errors.push(err);
      if (this.throwFirst) {
        throw new ValidatorResultError(this);
      } else if (this.throwError) {
        throw err;
      }
      return err;
    };
    ValidatorResult.prototype.importErrors = function importErrors(res) {
      if (typeof res == "string" || res && res.validatorType) {
        this.addError(res);
      } else if (res && res.errors) {
        this.errors = this.errors.concat(res.errors);
      }
    };
    function stringizer(v, i) {
      return i + ": " + v.toString() + "\n";
    }
    ValidatorResult.prototype.toString = function toString(res) {
      return this.errors.map(stringizer).join("");
    };
    Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
      return !this.errors.length;
    } });
    module.exports.ValidatorResultError = ValidatorResultError;
    function ValidatorResultError(result) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ValidatorResultError);
      }
      this.instance = result.instance;
      this.schema = result.schema;
      this.options = result.options;
      this.errors = result.errors;
    }
    ValidatorResultError.prototype = new Error();
    ValidatorResultError.prototype.constructor = ValidatorResultError;
    ValidatorResultError.prototype.name = "Validation Error";
    var SchemaError = exports.SchemaError = function SchemaError2(msg, schema) {
      this.message = msg;
      this.schema = schema;
      Error.call(this, msg);
      Error.captureStackTrace(this, SchemaError2);
    };
    SchemaError.prototype = Object.create(
      Error.prototype,
      {
        constructor: { value: SchemaError, enumerable: false },
        name: { value: "SchemaError", enumerable: false }
      }
    );
    var SchemaContext = exports.SchemaContext = function SchemaContext2(schema, options, path, base, schemas) {
      this.schema = schema;
      this.options = options;
      if (Array.isArray(path)) {
        this.path = path;
        this.propertyPath = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else {
        this.propertyPath = path;
      }
      this.base = base;
      this.schemas = schemas;
    };
    SchemaContext.prototype.resolve = function resolve(target) {
      return uri.resolve(this.base, target);
    };
    SchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {
      var path = propertyName === void 0 ? this.path : this.path.concat([propertyName]);
      var id = schema.$id || schema.id;
      var base = uri.resolve(this.base, id || "");
      var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));
      if (id && !ctx.schemas[base]) {
        ctx.schemas[base] = schema;
      }
      return ctx;
    };
    var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
      // 7.3.1. Dates, Times, and Duration
      "date-time": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
      "date": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
      "time": /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
      "duration": /P(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S)|\d+(D|M(\d+D)?|Y(\d+M(\d+D)?)?)(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S))?|\d+W)/i,
      // 7.3.2. Email Addresses
      // TODO: fix the email production
      "email": /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
      "idn-email": /^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u,
      // 7.3.3. Hostnames
      // 7.3.4. IP Addresses
      "ip-address": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
      // FIXME whitespace is invalid
      "ipv6": /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
      // 7.3.5. Resource Identifiers
      // TODO: A more accurate regular expression for "uri" goes:
      // [A-Za-z][+\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?)?
      "uri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "uri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/,
      "iri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "iri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\u{10FFFF}]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/u,
      "uuid": /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      // 7.3.6. uri-template
      "uri-template": /(%[0-9a-f]{2}|[!#$&(-;=?@\[\]_a-z~]|\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?)*\})*/iu,
      // 7.3.7. JSON Pointers
      "json-pointer": /^(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*$/iu,
      "relative-json-pointer": /^\d+(#|(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*)$/iu,
      // hostname regex from: http://stackoverflow.com/a/1420225/5628
      "hostname": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "host-name": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "utc-millisec": function(input) {
        return typeof input === "string" && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
      },
      // 7.3.8. regex
      "regex": function(input) {
        var result = true;
        try {
          new RegExp(input);
        } catch (e) {
          result = false;
        }
        return result;
      },
      // Other definitions
      // "style" was removed from JSON Schema in draft-4 and is deprecated
      "style": /[\r\n\t ]*[^\r\n\t ][^:]*:[\r\n\t ]*[^\r\n\t ;]*[\r\n\t ]*;?/,
      // "color" was removed from JSON Schema in draft-4 and is deprecated
      "color": /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
      "phone": /^\+(?:[0-9] ?){6,14}[0-9]$/,
      "alpha": /^[a-zA-Z]+$/,
      "alphanumeric": /^[a-zA-Z0-9]+$/
    };
    FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS["ip-address"];
    exports.isFormat = function isFormat(input, format, validator) {
      if (typeof input === "string" && FORMAT_REGEXPS[format] !== void 0) {
        if (FORMAT_REGEXPS[format] instanceof RegExp) {
          return FORMAT_REGEXPS[format].test(input);
        }
        if (typeof FORMAT_REGEXPS[format] === "function") {
          return FORMAT_REGEXPS[format](input);
        }
      } else if (validator && validator.customFormats && typeof validator.customFormats[format] === "function") {
        return validator.customFormats[format](input);
      }
      return true;
    };
    var makeSuffix = exports.makeSuffix = function makeSuffix2(key) {
      key = key.toString();
      if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
        return "." + key;
      }
      if (key.match(/^\d+$/)) {
        return "[" + key + "]";
      }
      return "[" + JSON.stringify(key) + "]";
    };
    exports.deepCompareStrict = function deepCompareStrict(a, b) {
      if (typeof a !== typeof b) {
        return false;
      }
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        return a.every(function(v, i) {
          return deepCompareStrict(a[i], b[i]);
        });
      }
      if (typeof a === "object") {
        if (!a || !b) {
          return a === b;
        }
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        return aKeys.every(function(v) {
          return deepCompareStrict(a[v], b[v]);
        });
      }
      return a === b;
    };
    function deepMerger(target, dst, e, i) {
      if (typeof e === "object") {
        dst[i] = deepMerge(target[i], e);
      } else {
        if (target.indexOf(e) === -1) {
          dst.push(e);
        }
      }
    }
    function copyist(src, dst, key) {
      dst[key] = src[key];
    }
    function copyistWithDeepMerge(target, src, dst, key) {
      if (typeof src[key] !== "object" || !src[key]) {
        dst[key] = src[key];
      } else {
        if (!target[key]) {
          dst[key] = src[key];
        } else {
          dst[key] = deepMerge(target[key], src[key]);
        }
      }
    }
    function deepMerge(target, src) {
      var array = Array.isArray(src);
      var dst = array && [] || {};
      if (array) {
        target = target || [];
        dst = dst.concat(target);
        src.forEach(deepMerger.bind(null, target, dst));
      } else {
        if (target && typeof target === "object") {
          Object.keys(target).forEach(copyist.bind(null, target, dst));
        }
        Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
      }
      return dst;
    }
    module.exports.deepMerge = deepMerge;
    exports.objectGetPath = function objectGetPath(o, s) {
      var parts = s.split("/").slice(1);
      var k;
      while (typeof (k = parts.shift()) == "string") {
        var n = decodeURIComponent(k.replace(/~0/, "~").replace(/~1/g, "/"));
        if (!(n in o))
          return;
        o = o[n];
      }
      return o;
    };
    function pathEncoder(v) {
      return "/" + encodeURIComponent(v).replace(/~/g, "%7E");
    }
    exports.encodePath = function encodePointer(a) {
      return a.map(pathEncoder).join("");
    };
    exports.getDecimalPlaces = function getDecimalPlaces(number) {
      var decimalPlaces = 0;
      if (isNaN(number))
        return decimalPlaces;
      if (typeof number !== "number") {
        number = Number(number);
      }
      var parts = number.toString().split("e");
      if (parts.length === 2) {
        if (parts[1][0] !== "-") {
          return decimalPlaces;
        } else {
          decimalPlaces = Number(parts[1].slice(1));
        }
      }
      var decimalParts = parts[0].split(".");
      if (decimalParts.length === 2) {
        decimalPlaces += decimalParts[1].length;
      }
      return decimalPlaces;
    };
    exports.isSchema = function isSchema(val) {
      return typeof val === "object" && val || typeof val === "boolean";
    };
  }
});

// node_modules/jsonschema/lib/attribute.js
var require_attribute = __commonJS({
  "node_modules/jsonschema/lib/attribute.js"(exports, module) {
    "use strict";
    var helpers = require_helpers2();
    var ValidatorResult = helpers.ValidatorResult;
    var SchemaError = helpers.SchemaError;
    var attribute = {};
    attribute.ignoreProperties = {
      // informative properties
      "id": true,
      "default": true,
      "description": true,
      "title": true,
      // arguments to other properties
      "additionalItems": true,
      "then": true,
      "else": true,
      // special-handled properties
      "$schema": true,
      "$ref": true,
      "extends": true
    };
    var validators = attribute.validators = {};
    validators.type = function validateType(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var types = Array.isArray(schema.type) ? schema.type : [schema.type];
      if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
        var list = types.map(function(v) {
          if (!v)
            return;
          var id = v.$id || v.id;
          return id ? "<" + id + ">" : v + "";
        });
        result.addError({
          name: "type",
          argument: list,
          message: "is not of a type(s) " + list
        });
      }
      return result;
    };
    function testSchemaNoThrow(instance, options, ctx, callback, schema) {
      var throwError = options.throwError;
      var throwAll = options.throwAll;
      options.throwError = false;
      options.throwAll = false;
      var res = this.validateSchema(instance, schema, options, ctx);
      options.throwError = throwError;
      options.throwAll = throwAll;
      if (!res.valid && callback instanceof Function) {
        callback(res);
      }
      return res.valid;
    }
    validators.anyOf = function validateAnyOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      if (!Array.isArray(schema.anyOf)) {
        throw new SchemaError("anyOf must be an array");
      }
      if (!schema.anyOf.some(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      )) {
        var list = schema.anyOf.map(function(v, i) {
          var id = v.$id || v.id;
          if (id)
            return "<" + id + ">";
          return v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
        });
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "anyOf",
          argument: list,
          message: "is not any of " + list.join(",")
        });
      }
      return result;
    };
    validators.allOf = function validateAllOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.allOf)) {
        throw new SchemaError("allOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var self = this;
      schema.allOf.forEach(function(v, i) {
        var valid = self.validateSchema(instance, v, options, ctx);
        if (!valid.valid) {
          var id = v.$id || v.id;
          var msg = id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
          result.addError({
            name: "allOf",
            argument: { id: msg, length: valid.errors.length, valid },
            message: "does not match allOf schema " + msg + " with " + valid.errors.length + " error[s]:"
          });
          result.importErrors(valid);
        }
      });
      return result;
    };
    validators.oneOf = function validateOneOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.oneOf)) {
        throw new SchemaError("oneOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      var count = schema.oneOf.filter(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      ).length;
      var list = schema.oneOf.map(function(v, i) {
        var id = v.$id || v.id;
        return id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
      });
      if (count !== 1) {
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "oneOf",
          argument: list,
          message: "is not exactly one from " + list.join(",")
        });
      }
      return result;
    };
    validators.if = function validateIf(instance, schema, options, ctx) {
      if (instance === void 0)
        return null;
      if (!helpers.isSchema(schema.if))
        throw new Error('Expected "if" keyword to be a schema');
      var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);
      var result = new ValidatorResult(instance, schema, options, ctx);
      var res;
      if (ifValid) {
        if (schema.then === void 0)
          return;
        if (!helpers.isSchema(schema.then))
          throw new Error('Expected "then" keyword to be a schema');
        res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));
        result.importErrors(res);
      } else {
        if (schema.else === void 0)
          return;
        if (!helpers.isSchema(schema.else))
          throw new Error('Expected "else" keyword to be a schema');
        res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));
        result.importErrors(res);
      }
      return result;
    };
    function getEnumerableProperty(object, key) {
      if (Object.hasOwnProperty.call(object, key))
        return object[key];
      if (!(key in object))
        return;
      while (object = Object.getPrototypeOf(object)) {
        if (Object.propertyIsEnumerable.call(object, key))
          return object[key];
      }
    }
    validators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var subschema = schema.propertyNames !== void 0 ? schema.propertyNames : {};
      if (!helpers.isSchema(subschema))
        throw new SchemaError('Expected "propertyNames" to be a schema (object or boolean)');
      for (var property in instance) {
        if (getEnumerableProperty(instance, property) !== void 0) {
          var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));
          result.importErrors(res);
        }
      }
      return result;
    };
    validators.properties = function validateProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var properties = schema.properties || {};
      for (var property in properties) {
        var subschema = properties[property];
        if (subschema === void 0) {
          continue;
        } else if (subschema === null) {
          throw new SchemaError('Unexpected null, expected schema in "properties"');
        }
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, subschema, options, ctx);
        }
        var prop = getEnumerableProperty(instance, property);
        var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
      return result;
    };
    function testAdditionalProperty(instance, schema, options, ctx, property, result) {
      if (!this.types.object(instance))
        return;
      if (schema.properties && schema.properties[property] !== void 0) {
        return;
      }
      if (schema.additionalProperties === false) {
        result.addError({
          name: "additionalProperties",
          argument: property,
          message: "is not allowed to have the additional property " + JSON.stringify(property)
        });
      } else {
        var additionalProperties = schema.additionalProperties || {};
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, additionalProperties, options, ctx);
        }
        var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
    }
    validators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var patternProperties = schema.patternProperties || {};
      for (var property in instance) {
        var test = true;
        for (var pattern in patternProperties) {
          var subschema = patternProperties[pattern];
          if (subschema === void 0) {
            continue;
          } else if (subschema === null) {
            throw new SchemaError('Unexpected null, expected schema in "patternProperties"');
          }
          try {
            var regexp = new RegExp(pattern, "u");
          } catch (_e) {
            regexp = new RegExp(pattern);
          }
          if (!regexp.test(property)) {
            continue;
          }
          test = false;
          if (typeof options.preValidateProperty == "function") {
            options.preValidateProperty(instance, property, subschema, options, ctx);
          }
          var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
          if (res.instance !== result.instance[property])
            result.instance[property] = res.instance;
          result.importErrors(res);
        }
        if (test) {
          testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
        }
      }
      return result;
    };
    validators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      if (schema.patternProperties) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in instance) {
        testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
      }
      return result;
    };
    validators.minProperties = function validateMinProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length >= schema.minProperties)) {
        result.addError({
          name: "minProperties",
          argument: schema.minProperties,
          message: "does not meet minimum property length of " + schema.minProperties
        });
      }
      return result;
    };
    validators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length <= schema.maxProperties)) {
        result.addError({
          name: "maxProperties",
          argument: schema.maxProperties,
          message: "does not meet maximum property length of " + schema.maxProperties
        });
      }
      return result;
    };
    validators.items = function validateItems(instance, schema, options, ctx) {
      var self = this;
      if (!this.types.array(instance))
        return;
      if (schema.items === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      instance.every(function(value, i) {
        if (Array.isArray(schema.items)) {
          var items = schema.items[i] === void 0 ? schema.additionalItems : schema.items[i];
        } else {
          var items = schema.items;
        }
        if (items === void 0) {
          return true;
        }
        if (items === false) {
          result.addError({
            name: "items",
            message: "additionalItems not permitted"
          });
          return false;
        }
        var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
        if (res.instance !== result.instance[i])
          result.instance[i] = res.instance;
        result.importErrors(res);
        return true;
      });
      return result;
    };
    validators.contains = function validateContains(instance, schema, options, ctx) {
      var self = this;
      if (!this.types.array(instance))
        return;
      if (schema.contains === void 0)
        return;
      if (!helpers.isSchema(schema.contains))
        throw new Error('Expected "contains" keyword to be a schema');
      var result = new ValidatorResult(instance, schema, options, ctx);
      var count = instance.some(function(value, i) {
        var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));
        return res.errors.length === 0;
      });
      if (count === false) {
        result.addError({
          name: "contains",
          argument: schema.contains,
          message: "must contain an item matching given schema"
        });
      }
      return result;
    };
    validators.minimum = function validateMinimum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
        if (!(instance > schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than " + schema.minimum
          });
        }
      } else {
        if (!(instance >= schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than or equal to " + schema.minimum
          });
        }
      }
      return result;
    };
    validators.maximum = function validateMaximum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
        if (!(instance < schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than " + schema.maximum
          });
        }
      } else {
        if (!(instance <= schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than or equal to " + schema.maximum
          });
        }
      }
      return result;
    };
    validators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMinimum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance > schema.exclusiveMinimum;
      if (!valid) {
        result.addError({
          name: "exclusiveMinimum",
          argument: schema.exclusiveMinimum,
          message: "must be strictly greater than " + schema.exclusiveMinimum
        });
      }
      return result;
    };
    validators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMaximum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance < schema.exclusiveMaximum;
      if (!valid) {
        result.addError({
          name: "exclusiveMaximum",
          argument: schema.exclusiveMaximum,
          message: "must be strictly less than " + schema.exclusiveMaximum
        });
      }
      return result;
    };
    var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy2(instance, schema, options, ctx, validationType, errorMessage) {
      if (!this.types.number(instance))
        return;
      var validationArgument = schema[validationType];
      if (validationArgument == 0) {
        throw new SchemaError(validationType + " cannot be zero");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var instanceDecimals = helpers.getDecimalPlaces(instance);
      var divisorDecimals = helpers.getDecimalPlaces(validationArgument);
      var maxDecimals = Math.max(instanceDecimals, divisorDecimals);
      var multiplier = Math.pow(10, maxDecimals);
      if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
        result.addError({
          name: validationType,
          argument: validationArgument,
          message: errorMessage + JSON.stringify(validationArgument)
        });
      }
      return result;
    };
    validators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
    };
    validators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
    };
    validators.required = function validateRequired(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (instance === void 0 && schema.required === true) {
        result.addError({
          name: "required",
          message: "is required"
        });
      } else if (this.types.object(instance) && Array.isArray(schema.required)) {
        schema.required.forEach(function(n) {
          if (getEnumerableProperty(instance, n) === void 0) {
            result.addError({
              name: "required",
              argument: n,
              message: "requires property " + JSON.stringify(n)
            });
          }
        });
      }
      return result;
    };
    validators.pattern = function validatePattern(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var pattern = schema.pattern;
      try {
        var regexp = new RegExp(pattern, "u");
      } catch (_e) {
        regexp = new RegExp(pattern);
      }
      if (!instance.match(regexp)) {
        result.addError({
          name: "pattern",
          argument: schema.pattern,
          message: "does not match pattern " + JSON.stringify(schema.pattern.toString())
        });
      }
      return result;
    };
    validators.format = function validateFormat(instance, schema, options, ctx) {
      if (instance === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
        result.addError({
          name: "format",
          argument: schema.format,
          message: "does not conform to the " + JSON.stringify(schema.format) + " format"
        });
      }
      return result;
    };
    validators.minLength = function validateMinLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length >= schema.minLength)) {
        result.addError({
          name: "minLength",
          argument: schema.minLength,
          message: "does not meet minimum length of " + schema.minLength
        });
      }
      return result;
    };
    validators.maxLength = function validateMaxLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length <= schema.maxLength)) {
        result.addError({
          name: "maxLength",
          argument: schema.maxLength,
          message: "does not meet maximum length of " + schema.maxLength
        });
      }
      return result;
    };
    validators.minItems = function validateMinItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length >= schema.minItems)) {
        result.addError({
          name: "minItems",
          argument: schema.minItems,
          message: "does not meet minimum length of " + schema.minItems
        });
      }
      return result;
    };
    validators.maxItems = function validateMaxItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length <= schema.maxItems)) {
        result.addError({
          name: "maxItems",
          argument: schema.maxItems,
          message: "does not meet maximum length of " + schema.maxItems
        });
      }
      return result;
    };
    function testArrays(v, i, a) {
      var j, len = a.length;
      for (j = i + 1, len; j < len; j++) {
        if (helpers.deepCompareStrict(v, a[j])) {
          return false;
        }
      }
      return true;
    }
    validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {
      if (schema.uniqueItems !== true)
        return;
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!instance.every(testArrays)) {
        result.addError({
          name: "uniqueItems",
          message: "contains duplicate item"
        });
      }
      return result;
    };
    validators.dependencies = function validateDependencies(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in schema.dependencies) {
        if (instance[property] === void 0) {
          continue;
        }
        var dep = schema.dependencies[property];
        var childContext = ctx.makeChild(dep, property);
        if (typeof dep == "string") {
          dep = [dep];
        }
        if (Array.isArray(dep)) {
          dep.forEach(function(prop) {
            if (instance[prop] === void 0) {
              result.addError({
                // FIXME there's two different "dependencies" errors here with slightly different outputs
                // Can we make these the same? Or should we create different error types?
                name: "dependencies",
                argument: childContext.propertyPath,
                message: "property " + prop + " not found, required by " + childContext.propertyPath
              });
            }
          });
        } else {
          var res = this.validateSchema(instance, dep, options, childContext);
          if (result.instance !== res.instance)
            result.instance = res.instance;
          if (res && res.errors.length) {
            result.addError({
              name: "dependencies",
              argument: childContext.propertyPath,
              message: "does not meet dependency required by " + childContext.propertyPath
            });
            result.importErrors(res);
          }
        }
      }
      return result;
    };
    validators["enum"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema["enum"])) {
        throw new SchemaError("enum expects an array", schema);
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!schema["enum"].some(helpers.deepCompareStrict.bind(null, instance))) {
        result.addError({
          name: "enum",
          argument: schema["enum"],
          message: "is not one of enum values: " + schema["enum"].map(String).join(",")
        });
      }
      return result;
    };
    validators["const"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!helpers.deepCompareStrict(schema["const"], instance)) {
        result.addError({
          name: "const",
          argument: schema["const"],
          message: "does not exactly match expected constant: " + schema["const"]
        });
      }
      return result;
    };
    validators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {
      var self = this;
      if (instance === void 0)
        return null;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var notTypes = schema.not || schema.disallow;
      if (!notTypes)
        return null;
      if (!Array.isArray(notTypes))
        notTypes = [notTypes];
      notTypes.forEach(function(type) {
        if (self.testType(instance, schema, options, ctx, type)) {
          var id = type && (type.$id || type.id);
          var schemaId = id || type;
          result.addError({
            name: "not",
            argument: schemaId,
            message: "is of prohibited type " + schemaId
          });
        }
      });
      return result;
    };
    module.exports = attribute;
  }
});

// node_modules/jsonschema/lib/scan.js
var require_scan = __commonJS({
  "node_modules/jsonschema/lib/scan.js"(exports, module) {
    "use strict";
    var urilib = require_url();
    var helpers = require_helpers2();
    module.exports.SchemaScanResult = SchemaScanResult;
    function SchemaScanResult(found, ref) {
      this.id = found;
      this.ref = ref;
    }
    module.exports.scan = function scan(base, schema) {
      function scanSchema(baseuri, schema2) {
        if (!schema2 || typeof schema2 != "object")
          return;
        if (schema2.$ref) {
          var resolvedUri = urilib.resolve(baseuri, schema2.$ref);
          ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri] + 1 : 0;
          return;
        }
        var id = schema2.$id || schema2.id;
        var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;
        if (ourBase) {
          if (ourBase.indexOf("#") < 0)
            ourBase += "#";
          if (found[ourBase]) {
            if (!helpers.deepCompareStrict(found[ourBase], schema2)) {
              throw new Error("Schema <" + ourBase + "> already exists with different definition");
            }
            return found[ourBase];
          }
          found[ourBase] = schema2;
          if (ourBase[ourBase.length - 1] == "#") {
            found[ourBase.substring(0, ourBase.length - 1)] = schema2;
          }
        }
        scanArray(ourBase + "/items", Array.isArray(schema2.items) ? schema2.items : [schema2.items]);
        scanArray(ourBase + "/extends", Array.isArray(schema2.extends) ? schema2.extends : [schema2.extends]);
        scanSchema(ourBase + "/additionalItems", schema2.additionalItems);
        scanObject(ourBase + "/properties", schema2.properties);
        scanSchema(ourBase + "/additionalProperties", schema2.additionalProperties);
        scanObject(ourBase + "/definitions", schema2.definitions);
        scanObject(ourBase + "/patternProperties", schema2.patternProperties);
        scanObject(ourBase + "/dependencies", schema2.dependencies);
        scanArray(ourBase + "/disallow", schema2.disallow);
        scanArray(ourBase + "/allOf", schema2.allOf);
        scanArray(ourBase + "/anyOf", schema2.anyOf);
        scanArray(ourBase + "/oneOf", schema2.oneOf);
        scanSchema(ourBase + "/not", schema2.not);
      }
      function scanArray(baseuri, schemas) {
        if (!Array.isArray(schemas))
          return;
        for (var i = 0; i < schemas.length; i++) {
          scanSchema(baseuri + "/" + i, schemas[i]);
        }
      }
      function scanObject(baseuri, schemas) {
        if (!schemas || typeof schemas != "object")
          return;
        for (var p in schemas) {
          scanSchema(baseuri + "/" + p, schemas[p]);
        }
      }
      var found = {};
      var ref = {};
      scanSchema(base, schema);
      return new SchemaScanResult(found, ref);
    };
  }
});

// node_modules/jsonschema/lib/validator.js
var require_validator = __commonJS({
  "node_modules/jsonschema/lib/validator.js"(exports, module) {
    "use strict";
    var urilib = require_url();
    var attribute = require_attribute();
    var helpers = require_helpers2();
    var scanSchema = require_scan().scan;
    var ValidatorResult = helpers.ValidatorResult;
    var ValidatorResultError = helpers.ValidatorResultError;
    var SchemaError = helpers.SchemaError;
    var SchemaContext = helpers.SchemaContext;
    var anonymousBase = "/";
    var Validator2 = function Validator3() {
      this.customFormats = Object.create(Validator3.prototype.customFormats);
      this.schemas = {};
      this.unresolvedRefs = [];
      this.types = Object.create(types);
      this.attributes = Object.create(attribute.validators);
    };
    Validator2.prototype.customFormats = {};
    Validator2.prototype.schemas = null;
    Validator2.prototype.types = null;
    Validator2.prototype.attributes = null;
    Validator2.prototype.unresolvedRefs = null;
    Validator2.prototype.addSchema = function addSchema(schema, base) {
      var self = this;
      if (!schema) {
        return null;
      }
      var scan = scanSchema(base || anonymousBase, schema);
      var ourUri = base || schema.$id || schema.id;
      for (var uri in scan.id) {
        this.schemas[uri] = scan.id[uri];
      }
      for (var uri in scan.ref) {
        this.unresolvedRefs.push(uri);
      }
      this.unresolvedRefs = this.unresolvedRefs.filter(function(uri2) {
        return typeof self.schemas[uri2] === "undefined";
      });
      return this.schemas[ourUri];
    };
    Validator2.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
      if (!Array.isArray(schemas))
        return;
      for (var i = 0; i < schemas.length; i++) {
        this.addSubSchema(baseuri, schemas[i]);
      }
    };
    Validator2.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
      if (!schemas || typeof schemas != "object")
        return;
      for (var p in schemas) {
        this.addSubSchema(baseuri, schemas[p]);
      }
    };
    Validator2.prototype.setSchemas = function setSchemas(schemas) {
      this.schemas = schemas;
    };
    Validator2.prototype.getSchema = function getSchema(urn) {
      return this.schemas[urn];
    };
    Validator2.prototype.validate = function validate(instance, schema, options, ctx) {
      if (typeof schema !== "boolean" && typeof schema !== "object" || schema === null) {
        throw new SchemaError("Expected `schema` to be an object or boolean");
      }
      if (!options) {
        options = {};
      }
      var id = schema.$id || schema.id;
      var base = urilib.resolve(options.base || anonymousBase, id || "");
      if (!ctx) {
        ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));
        if (!ctx.schemas[base]) {
          ctx.schemas[base] = schema;
        }
        var found = scanSchema(base, schema);
        for (var n in found.id) {
          var sch = found.id[n];
          ctx.schemas[n] = sch;
        }
      }
      if (options.required && instance === void 0) {
        var result = new ValidatorResult(instance, schema, options, ctx);
        result.addError("is required, but is undefined");
        return result;
      }
      var result = this.validateSchema(instance, schema, options, ctx);
      if (!result) {
        throw new Error("Result undefined");
      } else if (options.throwAll && result.errors.length) {
        throw new ValidatorResultError(result);
      }
      return result;
    };
    function shouldResolve(schema) {
      var ref = typeof schema === "string" ? schema : schema.$ref;
      if (typeof ref == "string")
        return ref;
      return false;
    }
    Validator2.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (typeof schema === "boolean") {
        if (schema === true) {
          schema = {};
        } else if (schema === false) {
          schema = { type: [] };
        }
      } else if (!schema) {
        throw new Error("schema is undefined");
      }
      if (schema["extends"]) {
        if (Array.isArray(schema["extends"])) {
          var schemaobj = { schema, ctx };
          schema["extends"].forEach(this.schemaTraverser.bind(this, schemaobj));
          schema = schemaobj.schema;
          schemaobj.schema = null;
          schemaobj.ctx = null;
          schemaobj = null;
        } else {
          schema = helpers.deepMerge(schema, this.superResolve(schema["extends"], ctx));
        }
      }
      var switchSchema = shouldResolve(schema);
      if (switchSchema) {
        var resolved = this.resolve(schema, switchSchema, ctx);
        var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);
        return this.validateSchema(instance, resolved.subschema, options, subctx);
      }
      var skipAttributes = options && options.skipAttributes || [];
      for (var key in schema) {
        if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
          var validatorErr = null;
          var validator = this.attributes[key];
          if (validator) {
            validatorErr = validator.call(this, instance, schema, options, ctx);
          } else if (options.allowUnknownAttributes === false) {
            throw new SchemaError("Unsupported attribute: " + key, schema);
          }
          if (validatorErr) {
            result.importErrors(validatorErr);
          }
        }
      }
      if (typeof options.rewrite == "function") {
        var value = options.rewrite.call(this, instance, schema, options, ctx);
        result.instance = value;
      }
      return result;
    };
    Validator2.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {
      schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
    };
    Validator2.prototype.superResolve = function superResolve(schema, ctx) {
      var ref = shouldResolve(schema);
      if (ref) {
        return this.resolve(schema, ref, ctx).subschema;
      }
      return schema;
    };
    Validator2.prototype.resolve = function resolve(schema, switchSchema, ctx) {
      switchSchema = ctx.resolve(switchSchema);
      if (ctx.schemas[switchSchema]) {
        return { subschema: ctx.schemas[switchSchema], switchSchema };
      }
      var parsed = urilib.parse(switchSchema);
      var fragment = parsed && parsed.hash;
      var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
      if (!document || !ctx.schemas[document]) {
        throw new SchemaError("no such schema <" + switchSchema + ">", schema);
      }
      var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
      if (subschema === void 0) {
        throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
      }
      return { subschema, switchSchema };
    };
    Validator2.prototype.testType = function validateType(instance, schema, options, ctx, type) {
      if (type === void 0) {
        return;
      } else if (type === null) {
        throw new SchemaError('Unexpected null in "type" keyword');
      }
      if (typeof this.types[type] == "function") {
        return this.types[type].call(this, instance);
      }
      if (type && typeof type == "object") {
        var res = this.validateSchema(instance, type, options, ctx);
        return res === void 0 || !(res && res.errors.length);
      }
      return true;
    };
    var types = Validator2.prototype.types = {};
    types.string = function testString(instance) {
      return typeof instance == "string";
    };
    types.number = function testNumber(instance) {
      return typeof instance == "number" && isFinite(instance);
    };
    types.integer = function testInteger(instance) {
      return typeof instance == "number" && instance % 1 === 0;
    };
    types.boolean = function testBoolean(instance) {
      return typeof instance == "boolean";
    };
    types.array = function testArray(instance) {
      return Array.isArray(instance);
    };
    types["null"] = function testNull(instance) {
      return instance === null;
    };
    types.date = function testDate(instance) {
      return instance instanceof Date;
    };
    types.any = function testAny(instance) {
      return true;
    };
    types.object = function testObject(instance) {
      return instance && typeof instance === "object" && !Array.isArray(instance) && !(instance instanceof Date);
    };
    module.exports = Validator2;
  }
});

// node_modules/jsonschema/lib/index.js
var require_lib = __commonJS({
  "node_modules/jsonschema/lib/index.js"(exports, module) {
    "use strict";
    var Validator2 = module.exports.Validator = require_validator();
    module.exports.ValidatorResult = require_helpers2().ValidatorResult;
    module.exports.ValidatorResultError = require_helpers2().ValidatorResultError;
    module.exports.ValidationError = require_helpers2().ValidationError;
    module.exports.SchemaError = require_helpers2().SchemaError;
    module.exports.SchemaScanResult = require_scan().SchemaScanResult;
    module.exports.scan = require_scan().scan;
    module.exports.validate = function(instance, schema, options) {
      var v = new Validator2();
      return v.validate(instance, schema, options);
    };
  }
});

// node_modules/@empower-plastic/empowerjs/module/plastic-credit-utils/empower-data-format.schema.json
var require_empower_data_format_schema = __commonJS({
  "node_modules/@empower-plastic/empowerjs/module/plastic-credit-utils/empower-data-format.schema.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema",
      type: "object",
      properties: {
        version: {
          const: "v1"
        },
        credit_props: {
          type: "array",
          allOf: [
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "credit_events_data"
                  },
                  type: {
                    const: "empower_credit_events_data"
                  },
                  content: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        id: {
                          const: "event_data"
                        },
                        type: {
                          const: "empower_event_data"
                        },
                        content: {
                          type: "array",
                          allOf: [
                            {
                              contains: {
                                type: "object",
                                properties: {
                                  id: {
                                    const: "location"
                                  },
                                  type: {
                                    const: "coordinates"
                                  },
                                  content: {
                                    type: "object",
                                    properties: {
                                      latitude: {
                                        type: "number"
                                      },
                                      longitude: {
                                        type: "number"
                                      }
                                    },
                                    required: [
                                      "latitude",
                                      "longitude"
                                    ]
                                  }
                                },
                                required: [
                                  "id",
                                  "type",
                                  "content"
                                ]
                              }
                            },
                            {
                              contains: {
                                type: "object",
                                properties: {
                                  id: {
                                    const: "amount"
                                  },
                                  type: {
                                    const: "number"
                                  },
                                  content: {
                                    type: "number"
                                  }
                                },
                                required: [
                                  "id",
                                  "type",
                                  "content"
                                ]
                              }
                            },
                            {
                              contains: {
                                type: "object",
                                properties: {
                                  id: {
                                    const: "magnitude"
                                  },
                                  type: {
                                    const: "text"
                                  },
                                  content: {
                                    type: "string"
                                  }
                                },
                                required: [
                                  "id",
                                  "type",
                                  "content"
                                ]
                              }
                            },
                            {
                              contains: {
                                type: "object",
                                properties: {
                                  id: {
                                    const: "material"
                                  },
                                  type: {
                                    const: "property_map"
                                  },
                                  content: {
                                    type: "array",
                                    items: [
                                      {
                                        type: "object",
                                        properties: {
                                          key: {
                                            type: "string"
                                          },
                                          value: {
                                            type: "string"
                                          }
                                        },
                                        required: [
                                          "key",
                                          "value"
                                        ]
                                      }
                                    ]
                                  }
                                },
                                required: [
                                  "id",
                                  "type",
                                  "content"
                                ]
                              }
                            },
                            {
                              contains: {
                                type: "object",
                                properties: {
                                  id: {
                                    const: "registration_date"
                                  },
                                  type: {
                                    const: "date"
                                  },
                                  content: {
                                    type: "string"
                                  }
                                },
                                required: [
                                  "id",
                                  "type",
                                  "content"
                                ]
                              }
                            }
                          ]
                        }
                      },
                      required: [
                        "id",
                        "type",
                        "content"
                      ]
                    }
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            },
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "credit_media"
                  },
                  type: {
                    const: "file_list"
                  },
                  content: {
                    type: "array",
                    items: [
                      {
                        type: "object",
                        properties: {
                          name: {
                            type: "string"
                          },
                          url: {
                            type: "string"
                          }
                        },
                        required: [
                          "name",
                          "url"
                        ]
                      }
                    ]
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            },
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "credit_files"
                  },
                  type: {
                    const: "file_list"
                  },
                  content: {
                    type: "array",
                    items: [
                      {
                        type: "object",
                        properties: {
                          name: {
                            type: "string"
                          },
                          url: {
                            type: "string"
                          }
                        },
                        required: [
                          "name",
                          "url"
                        ]
                      }
                    ]
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            },
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "issuance_date"
                  },
                  type: {
                    const: "date"
                  },
                  content: {
                    type: "string"
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            },
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "credit_type"
                  },
                  type: {
                    const: "text"
                  },
                  content: {
                    type: "string"
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            },
            {
              contains: {
                type: "object",
                properties: {
                  id: {
                    const: "applicant_data"
                  },
                  type: {
                    const: "empower_applicant_data"
                  },
                  content: {
                    type: "object",
                    properties: {
                      name: {
                        type: "string"
                      },
                      description: {
                        type: "string"
                      },
                      web_refs: {
                        type: "array",
                        items: [
                          {
                            type: "string"
                          }
                        ]
                      }
                    },
                    required: [
                      "name",
                      "description"
                    ]
                  }
                },
                required: [
                  "id",
                  "type",
                  "content"
                ]
              }
            }
          ]
        }
      }
    };
  }
});

// node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js
var require_types = __commonJS({
  "node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Model = exports.AbsoluteTxPosition = exports.ContractCodeHistoryEntry = exports.ContractInfo = exports.CodeInfo = exports.Params = exports.AccessConfig = exports.AccessTypeParam = exports.contractCodeHistoryOperationTypeToJSON = exports.contractCodeHistoryOperationTypeFromJSON = exports.ContractCodeHistoryOperationType = exports.accessTypeToJSON = exports.accessTypeFromJSON = exports.AccessType = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var _m093 = __importStar(require_minimal());
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    var AccessType;
    (function(AccessType2) {
      AccessType2[AccessType2["ACCESS_TYPE_UNSPECIFIED"] = 0] = "ACCESS_TYPE_UNSPECIFIED";
      AccessType2[AccessType2["ACCESS_TYPE_NOBODY"] = 1] = "ACCESS_TYPE_NOBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ONLY_ADDRESS"] = 2] = "ACCESS_TYPE_ONLY_ADDRESS";
      AccessType2[AccessType2["ACCESS_TYPE_EVERYBODY"] = 3] = "ACCESS_TYPE_EVERYBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ANY_OF_ADDRESSES"] = 4] = "ACCESS_TYPE_ANY_OF_ADDRESSES";
      AccessType2[AccessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AccessType = exports.AccessType || (exports.AccessType = {}));
    function accessTypeFromJSON2(object) {
      switch (object) {
        case 0:
        case "ACCESS_TYPE_UNSPECIFIED":
          return AccessType.ACCESS_TYPE_UNSPECIFIED;
        case 1:
        case "ACCESS_TYPE_NOBODY":
          return AccessType.ACCESS_TYPE_NOBODY;
        case 2:
        case "ACCESS_TYPE_ONLY_ADDRESS":
          return AccessType.ACCESS_TYPE_ONLY_ADDRESS;
        case 3:
        case "ACCESS_TYPE_EVERYBODY":
          return AccessType.ACCESS_TYPE_EVERYBODY;
        case 4:
        case "ACCESS_TYPE_ANY_OF_ADDRESSES":
          return AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AccessType.UNRECOGNIZED;
      }
    }
    exports.accessTypeFromJSON = accessTypeFromJSON2;
    function accessTypeToJSON(object) {
      switch (object) {
        case AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "ACCESS_TYPE_UNSPECIFIED";
        case AccessType.ACCESS_TYPE_NOBODY:
          return "ACCESS_TYPE_NOBODY";
        case AccessType.ACCESS_TYPE_ONLY_ADDRESS:
          return "ACCESS_TYPE_ONLY_ADDRESS";
        case AccessType.ACCESS_TYPE_EVERYBODY:
          return "ACCESS_TYPE_EVERYBODY";
        case AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES:
          return "ACCESS_TYPE_ANY_OF_ADDRESSES";
        case AccessType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.accessTypeToJSON = accessTypeToJSON;
    var ContractCodeHistoryOperationType;
    (function(ContractCodeHistoryOperationType2) {
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"] = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"] = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"] = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"] = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContractCodeHistoryOperationType = exports.ContractCodeHistoryOperationType || (exports.ContractCodeHistoryOperationType = {}));
    function contractCodeHistoryOperationTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
        case 2:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
        case 3:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ContractCodeHistoryOperationType.UNRECOGNIZED;
      }
    }
    exports.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;
    function contractCodeHistoryOperationTypeToJSON(object) {
      switch (object) {
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        case ContractCodeHistoryOperationType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;
    function createBaseAccessTypeParam() {
      return {
        value: 0
      };
    }
    exports.AccessTypeParam = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.value !== 0) {
          writer.uint32(8).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessTypeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          value: (0, helpers_1.isSet)(object.value) ? accessTypeFromJSON2(object.value) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.value !== void 0 && (obj.value = accessTypeToJSON(message.value));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAccessTypeParam();
        message.value = object.value ?? 0;
        return message;
      }
    };
    function createBaseAccessConfig() {
      return {
        permission: 0,
        address: "",
        addresses: []
      };
    }
    exports.AccessConfig = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.permission !== 0) {
          writer.uint32(8).int32(message.permission);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        for (const v of message.addresses) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.permission = reader.int32();
              break;
            case 2:
              message.address = reader.string();
              break;
            case 3:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          permission: (0, helpers_1.isSet)(object.permission) ? accessTypeFromJSON2(object.permission) : 0,
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          addresses: Array.isArray(object == null ? void 0 : object.addresses) ? object.addresses.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.permission !== void 0 && (obj.permission = accessTypeToJSON(message.permission));
        message.address !== void 0 && (obj.address = message.address);
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAccessConfig();
        message.permission = object.permission ?? 0;
        message.address = object.address ?? "";
        message.addresses = ((_a = object.addresses) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        codeUploadAccess: void 0,
        instantiateDefaultPermission: 0
      };
    }
    exports.Params = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.codeUploadAccess !== void 0) {
          exports.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();
        }
        if (message.instantiateDefaultPermission !== 0) {
          writer.uint32(16).int32(message.instantiateDefaultPermission);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeUploadAccess = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            case 2:
              message.instantiateDefaultPermission = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeUploadAccess: (0, helpers_1.isSet)(object.codeUploadAccess) ? exports.AccessConfig.fromJSON(object.codeUploadAccess) : void 0,
          instantiateDefaultPermission: (0, helpers_1.isSet)(object.instantiateDefaultPermission) ? accessTypeFromJSON2(object.instantiateDefaultPermission) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeUploadAccess !== void 0 && (obj.codeUploadAccess = message.codeUploadAccess ? exports.AccessConfig.toJSON(message.codeUploadAccess) : void 0);
        message.instantiateDefaultPermission !== void 0 && (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.codeUploadAccess = object.codeUploadAccess !== void 0 && object.codeUploadAccess !== null ? exports.AccessConfig.fromPartial(object.codeUploadAccess) : void 0;
        message.instantiateDefaultPermission = object.instantiateDefaultPermission ?? 0;
        return message;
      }
    };
    function createBaseCodeInfo() {
      return {
        codeHash: new Uint8Array(),
        creator: "",
        instantiateConfig: void 0
      };
    }
    exports.CodeInfo = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.codeHash.length !== 0) {
          writer.uint32(10).bytes(message.codeHash);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.instantiateConfig !== void 0) {
          exports.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.bytes();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 5:
              message.instantiateConfig = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeHash: (0, helpers_1.isSet)(object.codeHash) ? (0, helpers_1.bytesFromBase64)(object.codeHash) : new Uint8Array(),
          creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
          instantiateConfig: (0, helpers_1.isSet)(object.instantiateConfig) ? exports.AccessConfig.fromJSON(object.instantiateConfig) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = (0, helpers_1.base64FromBytes)(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        message.creator !== void 0 && (obj.creator = message.creator);
        message.instantiateConfig !== void 0 && (obj.instantiateConfig = message.instantiateConfig ? exports.AccessConfig.toJSON(message.instantiateConfig) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCodeInfo();
        message.codeHash = object.codeHash ?? new Uint8Array();
        message.creator = object.creator ?? "";
        message.instantiateConfig = object.instantiateConfig !== void 0 && object.instantiateConfig !== null ? exports.AccessConfig.fromPartial(object.instantiateConfig) : void 0;
        return message;
      }
    };
    function createBaseContractInfo() {
      return {
        codeId: helpers_1.Long.UZERO,
        creator: "",
        admin: "",
        label: "",
        created: void 0,
        ibcPortId: "",
        extension: void 0
      };
    }
    exports.ContractInfo = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.created !== void 0) {
          exports.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();
        }
        if (message.ibcPortId !== "") {
          writer.uint32(50).string(message.ibcPortId);
        }
        if (message.extension !== void 0) {
          any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.created = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 6:
              message.ibcPortId = reader.string();
              break;
            case 7:
              message.extension = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
          admin: (0, helpers_1.isSet)(object.admin) ? String(object.admin) : "",
          label: (0, helpers_1.isSet)(object.label) ? String(object.label) : "",
          created: (0, helpers_1.isSet)(object.created) ? exports.AbsoluteTxPosition.fromJSON(object.created) : void 0,
          ibcPortId: (0, helpers_1.isSet)(object.ibcPortId) ? String(object.ibcPortId) : "",
          extension: (0, helpers_1.isSet)(object.extension) ? any_1.Any.fromJSON(object.extension) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.created !== void 0 && (obj.created = message.created ? exports.AbsoluteTxPosition.toJSON(message.created) : void 0);
        message.ibcPortId !== void 0 && (obj.ibcPortId = message.ibcPortId);
        message.extension !== void 0 && (obj.extension = message.extension ? any_1.Any.toJSON(message.extension) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContractInfo();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.creator = object.creator ?? "";
        message.admin = object.admin ?? "";
        message.label = object.label ?? "";
        message.created = object.created !== void 0 && object.created !== null ? exports.AbsoluteTxPosition.fromPartial(object.created) : void 0;
        message.ibcPortId = object.ibcPortId ?? "";
        message.extension = object.extension !== void 0 && object.extension !== null ? any_1.Any.fromPartial(object.extension) : void 0;
        return message;
      }
    };
    function createBaseContractCodeHistoryEntry() {
      return {
        operation: 0,
        codeId: helpers_1.Long.UZERO,
        updated: void 0,
        msg: new Uint8Array()
      };
    }
    exports.ContractCodeHistoryEntry = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.operation !== 0) {
          writer.uint32(8).int32(message.operation);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.updated !== void 0) {
          exports.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractCodeHistoryEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operation = reader.int32();
              break;
            case 2:
              message.codeId = reader.uint64();
              break;
            case 3:
              message.updated = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operation: (0, helpers_1.isSet)(object.operation) ? contractCodeHistoryOperationTypeFromJSON(object.operation) : 0,
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          updated: (0, helpers_1.isSet)(object.updated) ? exports.AbsoluteTxPosition.fromJSON(object.updated) : void 0,
          msg: (0, helpers_1.isSet)(object.msg) ? (0, helpers_1.bytesFromBase64)(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.operation !== void 0 && (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.updated !== void 0 && (obj.updated = message.updated ? exports.AbsoluteTxPosition.toJSON(message.updated) : void 0);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContractCodeHistoryEntry();
        message.operation = object.operation ?? 0;
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.updated = object.updated !== void 0 && object.updated !== null ? exports.AbsoluteTxPosition.fromPartial(object.updated) : void 0;
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAbsoluteTxPosition() {
      return {
        blockHeight: helpers_1.Long.UZERO,
        txIndex: helpers_1.Long.UZERO
      };
    }
    exports.AbsoluteTxPosition = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.blockHeight.isZero()) {
          writer.uint32(8).uint64(message.blockHeight);
        }
        if (!message.txIndex.isZero()) {
          writer.uint32(16).uint64(message.txIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAbsoluteTxPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockHeight = reader.uint64();
              break;
            case 2:
              message.txIndex = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockHeight: (0, helpers_1.isSet)(object.blockHeight) ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.UZERO,
          txIndex: (0, helpers_1.isSet)(object.txIndex) ? helpers_1.Long.fromValue(object.txIndex) : helpers_1.Long.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockHeight !== void 0 && (obj.blockHeight = (message.blockHeight || helpers_1.Long.UZERO).toString());
        message.txIndex !== void 0 && (obj.txIndex = (message.txIndex || helpers_1.Long.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAbsoluteTxPosition();
        message.blockHeight = object.blockHeight !== void 0 && object.blockHeight !== null ? helpers_1.Long.fromValue(object.blockHeight) : helpers_1.Long.UZERO;
        message.txIndex = object.txIndex !== void 0 && object.txIndex !== null ? helpers_1.Long.fromValue(object.txIndex) : helpers_1.Long.UZERO;
        return message;
      }
    };
    function createBaseModel() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array()
      };
    }
    exports.Model = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: (0, helpers_1.isSet)(object.key) ? (0, helpers_1.bytesFromBase64)(object.key) : new Uint8Array(),
          value: (0, helpers_1.isSet)(object.value) ? (0, helpers_1.bytesFromBase64)(object.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModel();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js
var require_aminomessages = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWasmAminoConverters = void 0;
    var encoding_1 = require_build();
    var long_1 = __importDefault(require_long());
    function createWasmAminoConverters() {
      return {
        "/cosmwasm.wasm.v1.MsgStoreCode": {
          aminoType: "wasm/MsgStoreCode",
          toAmino: ({ sender, wasmByteCode }) => ({
            sender,
            wasm_byte_code: (0, encoding_1.toBase64)(wasmByteCode)
          }),
          fromAmino: ({ sender, wasm_byte_code }) => ({
            sender,
            wasmByteCode: (0, encoding_1.fromBase64)(wasm_byte_code),
            instantiatePermission: void 0
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract": {
          aminoType: "wasm/MsgInstantiateContract",
          toAmino: ({ sender, codeId, label, msg, funds, admin }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: admin || void 0
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin }) => ({
            sender,
            codeId: long_1.default.fromString(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin ?? ""
          })
        },
        "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
          aminoType: "wasm/MsgUpdateAdmin",
          toAmino: ({ sender, newAdmin, contract }) => ({
            sender,
            new_admin: newAdmin,
            contract
          }),
          fromAmino: ({ sender, new_admin, contract }) => ({
            sender,
            newAdmin: new_admin,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgClearAdmin": {
          aminoType: "wasm/MsgClearAdmin",
          toAmino: ({ sender, contract }) => ({
            sender,
            contract
          }),
          fromAmino: ({ sender, contract }) => ({
            sender,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgExecuteContract": {
          aminoType: "wasm/MsgExecuteContract",
          toAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds
          }),
          fromAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds]
          })
        },
        "/cosmwasm.wasm.v1.MsgMigrateContract": {
          aminoType: "wasm/MsgMigrateContract",
          toAmino: ({ sender, contract, codeId, msg }) => ({
            sender,
            contract,
            code_id: codeId.toString(),
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg))
          }),
          fromAmino: ({ sender, contract, code_id, msg }) => ({
            sender,
            contract,
            codeId: long_1.default.fromString(code_id),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg))
          })
        }
      };
    }
    exports.createWasmAminoConverters = createWasmAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js
var require_tx4 = __commonJS({
  "node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateInstantiateConfigResponse = exports.MsgUpdateInstantiateConfig = exports.MsgClearAdminResponse = exports.MsgClearAdmin = exports.MsgUpdateAdminResponse = exports.MsgUpdateAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContract2Response = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract2 = exports.MsgInstantiateContract = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;
    var types_1 = require_types();
    var coin_1 = require_coin();
    var _m093 = __importStar(require_minimal());
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseMsgStoreCode() {
      return {
        sender: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0
      };
    }
    exports.MsgStoreCode = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCode();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 5:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          wasmByteCode: (0, helpers_1.isSet)(object.wasmByteCode) ? (0, helpers_1.bytesFromBase64)(object.wasmByteCode) : new Uint8Array(),
          instantiatePermission: (0, helpers_1.isSet)(object.instantiatePermission) ? types_1.AccessConfig.fromJSON(object.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = (0, helpers_1.base64FromBytes)(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreCode();
        message.sender = object.sender ?? "";
        message.wasmByteCode = object.wasmByteCode ?? new Uint8Array();
        message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseMsgStoreCodeResponse() {
      return {
        codeId: helpers_1.Long.UZERO,
        checksum: new Uint8Array()
      };
    }
    exports.MsgStoreCodeResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.checksum.length !== 0) {
          writer.uint32(18).bytes(message.checksum);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.checksum = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          checksum: (0, helpers_1.isSet)(object.checksum) ? (0, helpers_1.bytesFromBase64)(object.checksum) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.checksum !== void 0 && (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== void 0 ? message.checksum : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreCodeResponse();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.checksum = object.checksum ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgInstantiateContract() {
      return {
        sender: "",
        admin: "",
        codeId: helpers_1.Long.UZERO,
        label: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports.MsgInstantiateContract = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          admin: (0, helpers_1.isSet)(object.admin) ? String(object.admin) : "",
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          label: (0, helpers_1.isSet)(object.label) ? String(object.label) : "",
          msg: (0, helpers_1.isSet)(object.msg) ? (0, helpers_1.bytesFromBase64)(object.msg) : new Uint8Array(),
          funds: Array.isArray(object == null ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgInstantiateContract();
        message.sender = object.sender ?? "";
        message.admin = object.admin ?? "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.label = object.label ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = ((_a = object.funds) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgInstantiateContract2() {
      return {
        sender: "",
        admin: "",
        codeId: helpers_1.Long.UZERO,
        label: "",
        msg: new Uint8Array(),
        funds: [],
        salt: new Uint8Array(),
        fixMsg: false
      };
    }
    exports.MsgInstantiateContract2 = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.salt.length !== 0) {
          writer.uint32(58).bytes(message.salt);
        }
        if (message.fixMsg === true) {
          writer.uint32(64).bool(message.fixMsg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 7:
              message.salt = reader.bytes();
              break;
            case 8:
              message.fixMsg = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          admin: (0, helpers_1.isSet)(object.admin) ? String(object.admin) : "",
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          label: (0, helpers_1.isSet)(object.label) ? String(object.label) : "",
          msg: (0, helpers_1.isSet)(object.msg) ? (0, helpers_1.bytesFromBase64)(object.msg) : new Uint8Array(),
          funds: Array.isArray(object == null ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : [],
          salt: (0, helpers_1.isSet)(object.salt) ? (0, helpers_1.bytesFromBase64)(object.salt) : new Uint8Array(),
          fixMsg: (0, helpers_1.isSet)(object.fixMsg) ? Boolean(object.fixMsg) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        message.salt !== void 0 && (obj.salt = (0, helpers_1.base64FromBytes)(message.salt !== void 0 ? message.salt : new Uint8Array()));
        message.fixMsg !== void 0 && (obj.fixMsg = message.fixMsg);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgInstantiateContract2();
        message.sender = object.sender ?? "";
        message.admin = object.admin ?? "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.label = object.label ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = ((_a = object.funds) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.salt = object.salt ?? new Uint8Array();
        message.fixMsg = object.fixMsg ?? false;
        return message;
      }
    };
    function createBaseMsgInstantiateContractResponse() {
      return {
        address: "",
        data: new Uint8Array()
      };
    }
    exports.MsgInstantiateContractResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContractResponse();
        message.address = object.address ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgInstantiateContract2Response() {
      return {
        address: "",
        data: new Uint8Array()
      };
    }
    exports.MsgInstantiateContract2Response = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract2Response();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContract2Response();
        message.address = object.address ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgExecuteContract() {
      return {
        sender: "",
        contract: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports.MsgExecuteContract = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            case 5:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          contract: (0, helpers_1.isSet)(object.contract) ? String(object.contract) : "",
          msg: (0, helpers_1.isSet)(object.msg) ? (0, helpers_1.bytesFromBase64)(object.msg) : new Uint8Array(),
          funds: Array.isArray(object == null ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgExecuteContract();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = ((_a = object.funds) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgExecuteContractResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.MsgExecuteContractResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecuteContractResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContract() {
      return {
        sender: "",
        contract: "",
        codeId: helpers_1.Long.UZERO,
        msg: new Uint8Array()
      };
    }
    exports.MsgMigrateContract = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          contract: (0, helpers_1.isSet)(object.contract) ? String(object.contract) : "",
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          msg: (0, helpers_1.isSet)(object.msg) ? (0, helpers_1.bytesFromBase64)(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMigrateContract();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContractResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.MsgMigrateContractResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMigrateContractResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateAdmin() {
      return {
        sender: "",
        newAdmin: "",
        contract: ""
      };
    }
    exports.MsgUpdateAdmin = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newAdmin !== "") {
          writer.uint32(18).string(message.newAdmin);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newAdmin = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          newAdmin: (0, helpers_1.isSet)(object.newAdmin) ? String(object.newAdmin) : "",
          contract: (0, helpers_1.isSet)(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateAdmin();
        message.sender = object.sender ?? "";
        message.newAdmin = object.newAdmin ?? "";
        message.contract = object.contract ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateAdminResponse() {
      return {};
    }
    exports.MsgUpdateAdminResponse = {
      encode(_, writer = _m093.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateAdminResponse();
        return message;
      }
    };
    function createBaseMsgClearAdmin() {
      return {
        sender: "",
        contract: ""
      };
    }
    exports.MsgClearAdmin = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          contract: (0, helpers_1.isSet)(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgClearAdmin();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        return message;
      }
    };
    function createBaseMsgClearAdminResponse() {
      return {};
    }
    exports.MsgClearAdminResponse = {
      encode(_, writer = _m093.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgClearAdminResponse();
        return message;
      }
    };
    function createBaseMsgUpdateInstantiateConfig() {
      return {
        sender: "",
        codeId: helpers_1.Long.UZERO,
        newInstantiatePermission: void 0
      };
    }
    exports.MsgUpdateInstantiateConfig = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.newInstantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.newInstantiatePermission, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInstantiateConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.codeId = reader.uint64();
              break;
            case 3:
              message.newInstantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: (0, helpers_1.isSet)(object.sender) ? String(object.sender) : "",
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          newInstantiatePermission: (0, helpers_1.isSet)(object.newInstantiatePermission) ? types_1.AccessConfig.fromJSON(object.newInstantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.newInstantiatePermission !== void 0 && (obj.newInstantiatePermission = message.newInstantiatePermission ? types_1.AccessConfig.toJSON(message.newInstantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateInstantiateConfig();
        message.sender = object.sender ?? "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.newInstantiatePermission = object.newInstantiatePermission !== void 0 && object.newInstantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.newInstantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseMsgUpdateInstantiateConfigResponse() {
      return {};
    }
    exports.MsgUpdateInstantiateConfigResponse = {
      encode(_, writer = _m093.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInstantiateConfigResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateInstantiateConfigResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.StoreCode = this.StoreCode.bind(this);
        this.InstantiateContract = this.InstantiateContract.bind(this);
        this.InstantiateContract2 = this.InstantiateContract2.bind(this);
        this.ExecuteContract = this.ExecuteContract.bind(this);
        this.MigrateContract = this.MigrateContract.bind(this);
        this.UpdateAdmin = this.UpdateAdmin.bind(this);
        this.ClearAdmin = this.ClearAdmin.bind(this);
        this.UpdateInstantiateConfig = this.UpdateInstantiateConfig.bind(this);
      }
      StoreCode(request) {
        const data = exports.MsgStoreCode.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreCode", data);
        return promise.then((data2) => exports.MsgStoreCodeResponse.decode(new _m093.Reader(data2)));
      }
      InstantiateContract(request) {
        const data = exports.MsgInstantiateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract", data);
        return promise.then((data2) => exports.MsgInstantiateContractResponse.decode(new _m093.Reader(data2)));
      }
      InstantiateContract2(request) {
        const data = exports.MsgInstantiateContract2.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract2", data);
        return promise.then((data2) => exports.MsgInstantiateContract2Response.decode(new _m093.Reader(data2)));
      }
      ExecuteContract(request) {
        const data = exports.MsgExecuteContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ExecuteContract", data);
        return promise.then((data2) => exports.MsgExecuteContractResponse.decode(new _m093.Reader(data2)));
      }
      MigrateContract(request) {
        const data = exports.MsgMigrateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "MigrateContract", data);
        return promise.then((data2) => exports.MsgMigrateContractResponse.decode(new _m093.Reader(data2)));
      }
      UpdateAdmin(request) {
        const data = exports.MsgUpdateAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateAdmin", data);
        return promise.then((data2) => exports.MsgUpdateAdminResponse.decode(new _m093.Reader(data2)));
      }
      ClearAdmin(request) {
        const data = exports.MsgClearAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ClearAdmin", data);
        return promise.then((data2) => exports.MsgClearAdminResponse.decode(new _m093.Reader(data2)));
      }
      UpdateInstantiateConfig(request) {
        const data = exports.MsgUpdateInstantiateConfig.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateInstantiateConfig", data);
        return promise.then((data2) => exports.MsgUpdateInstantiateConfigResponse.decode(new _m093.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js
var require_messages = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgExecuteEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgClearAdminEncodeObject = exports.isMsgUpdateAdminEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.wasmTypes = void 0;
    var tx_1 = require_tx4();
    exports.wasmTypes = [
      ["/cosmwasm.wasm.v1.MsgClearAdmin", tx_1.MsgClearAdmin],
      ["/cosmwasm.wasm.v1.MsgExecuteContract", tx_1.MsgExecuteContract],
      ["/cosmwasm.wasm.v1.MsgMigrateContract", tx_1.MsgMigrateContract],
      ["/cosmwasm.wasm.v1.MsgStoreCode", tx_1.MsgStoreCode],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract", tx_1.MsgInstantiateContract],
      ["/cosmwasm.wasm.v1.MsgUpdateAdmin", tx_1.MsgUpdateAdmin]
    ];
    function isMsgStoreCodeEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgStoreCode";
    }
    exports.isMsgStoreCodeEncodeObject = isMsgStoreCodeEncodeObject;
    function isMsgInstantiateContractEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract";
    }
    exports.isMsgInstantiateContractEncodeObject = isMsgInstantiateContractEncodeObject;
    function isMsgUpdateAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgUpdateAdmin";
    }
    exports.isMsgUpdateAdminEncodeObject = isMsgUpdateAdminEncodeObject;
    function isMsgClearAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgClearAdmin";
    }
    exports.isMsgClearAdminEncodeObject = isMsgClearAdminEncodeObject;
    function isMsgMigrateEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgMigrateContract";
    }
    exports.isMsgMigrateEncodeObject = isMsgMigrateEncodeObject;
    function isMsgExecuteEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgExecuteContract";
    }
    exports.isMsgExecuteEncodeObject = isMsgExecuteEncodeObject;
  }
});

// node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js
var require_query = __commonJS({
  "node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryContractsByCreatorResponse = exports.QueryContractsByCreatorRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPinnedCodesResponse = exports.QueryPinnedCodesRequest = exports.QueryCodesResponse = exports.QueryCodesRequest = exports.QueryCodeResponse = exports.CodeInfoResponse = exports.QueryCodeRequest = exports.QuerySmartContractStateResponse = exports.QuerySmartContractStateRequest = exports.QueryRawContractStateResponse = exports.QueryRawContractStateRequest = exports.QueryAllContractStateResponse = exports.QueryAllContractStateRequest = exports.QueryContractsByCodeResponse = exports.QueryContractsByCodeRequest = exports.QueryContractHistoryResponse = exports.QueryContractHistoryRequest = exports.QueryContractInfoResponse = exports.QueryContractInfoRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var types_1 = require_types();
    var _m093 = __importStar(require_minimal());
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseQueryContractInfoRequest() {
      return {
        address: ""
      };
    }
    exports.QueryContractInfoRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractInfoRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryContractInfoResponse() {
      return {
        address: "",
        contractInfo: void 0
      };
    }
    exports.QueryContractInfoResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.contractInfo !== void 0) {
          types_1.ContractInfo.encode(message.contractInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.contractInfo = types_1.ContractInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          contractInfo: (0, helpers_1.isSet)(object.contractInfo) ? types_1.ContractInfo.fromJSON(object.contractInfo) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.contractInfo !== void 0 && (obj.contractInfo = message.contractInfo ? types_1.ContractInfo.toJSON(message.contractInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractInfoResponse();
        message.address = object.address ?? "";
        message.contractInfo = object.contractInfo !== void 0 && object.contractInfo !== null ? types_1.ContractInfo.fromPartial(object.contractInfo) : void 0;
        return message;
      }
    };
    function createBaseQueryContractHistoryRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QueryContractHistoryRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractHistoryRequest();
        message.address = object.address ?? "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractHistoryResponse() {
      return {
        entries: [],
        pagination: void 0
      };
    }
    exports.QueryContractHistoryResponse = {
      encode(message, writer = _m093.Writer.create()) {
        for (const v of message.entries) {
          types_1.ContractCodeHistoryEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(types_1.ContractCodeHistoryEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          entries: Array.isArray(object == null ? void 0 : object.entries) ? object.entries.map((e) => types_1.ContractCodeHistoryEntry.fromJSON(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? types_1.ContractCodeHistoryEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractHistoryResponse();
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => types_1.ContractCodeHistoryEntry.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCodeRequest() {
      return {
        codeId: helpers_1.Long.UZERO,
        pagination: void 0
      };
    }
    exports.QueryContractsByCodeRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCodeRequest();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCodeResponse() {
      return {
        contracts: [],
        pagination: void 0
      };
    }
    exports.QueryContractsByCodeResponse = {
      encode(message, writer = _m093.Writer.create()) {
        for (const v of message.contracts) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contracts.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          contracts: Array.isArray(object == null ? void 0 : object.contracts) ? object.contracts.map((e) => String(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.contracts) {
          obj.contracts = message.contracts.map((e) => e);
        } else {
          obj.contracts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractsByCodeResponse();
        message.contracts = ((_a = object.contracts) == null ? void 0 : _a.map((e) => e)) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllContractStateRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QueryAllContractStateRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllContractStateRequest();
        message.address = object.address ?? "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllContractStateResponse() {
      return {
        models: [],
        pagination: void 0
      };
    }
    exports.QueryAllContractStateResponse = {
      encode(message, writer = _m093.Writer.create()) {
        for (const v of message.models) {
          types_1.Model.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.models.push(types_1.Model.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          models: Array.isArray(object == null ? void 0 : object.models) ? object.models.map((e) => types_1.Model.fromJSON(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.models) {
          obj.models = message.models.map((e) => e ? types_1.Model.toJSON(e) : void 0);
        } else {
          obj.models = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllContractStateResponse();
        message.models = ((_a = object.models) == null ? void 0 : _a.map((e) => types_1.Model.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryRawContractStateRequest() {
      return {
        address: "",
        queryData: new Uint8Array()
      };
    }
    exports.QueryRawContractStateRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          queryData: (0, helpers_1.isSet)(object.queryData) ? (0, helpers_1.bytesFromBase64)(object.queryData) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = (0, helpers_1.base64FromBytes)(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRawContractStateRequest();
        message.address = object.address ?? "";
        message.queryData = object.queryData ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryRawContractStateResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.QueryRawContractStateResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRawContractStateResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateRequest() {
      return {
        address: "",
        queryData: new Uint8Array()
      };
    }
    exports.QuerySmartContractStateRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: (0, helpers_1.isSet)(object.address) ? String(object.address) : "",
          queryData: (0, helpers_1.isSet)(object.queryData) ? (0, helpers_1.bytesFromBase64)(object.queryData) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = (0, helpers_1.base64FromBytes)(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySmartContractStateRequest();
        message.address = object.address ?? "";
        message.queryData = object.queryData ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.QuerySmartContractStateResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySmartContractStateResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodeRequest() {
      return {
        codeId: helpers_1.Long.UZERO
      };
    }
    exports.QueryCodeRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeRequest();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        return message;
      }
    };
    function createBaseCodeInfoResponse() {
      return {
        codeId: helpers_1.Long.UZERO,
        creator: "",
        dataHash: new Uint8Array(),
        instantiatePermission: void 0
      };
    }
    exports.CodeInfoResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(26).bytes(message.dataHash);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.dataHash = reader.bytes();
              break;
            case 6:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: (0, helpers_1.isSet)(object.codeId) ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO,
          creator: (0, helpers_1.isSet)(object.creator) ? String(object.creator) : "",
          dataHash: (0, helpers_1.isSet)(object.dataHash) ? (0, helpers_1.bytesFromBase64)(object.dataHash) : new Uint8Array(),
          instantiatePermission: (0, helpers_1.isSet)(object.instantiatePermission) ? types_1.AccessConfig.fromJSON(object.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || helpers_1.Long.UZERO).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCodeInfoResponse();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? helpers_1.Long.fromValue(object.codeId) : helpers_1.Long.UZERO;
        message.creator = object.creator ?? "";
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseQueryCodeResponse() {
      return {
        codeInfo: void 0,
        data: new Uint8Array()
      };
    }
    exports.QueryCodeResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.codeInfo !== void 0) {
          exports.CodeInfoResponse.encode(message.codeInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfo = exports.CodeInfoResponse.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeInfo: (0, helpers_1.isSet)(object.codeInfo) ? exports.CodeInfoResponse.fromJSON(object.codeInfo) : void 0,
          data: (0, helpers_1.isSet)(object.data) ? (0, helpers_1.bytesFromBase64)(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeInfo !== void 0 && (obj.codeInfo = message.codeInfo ? exports.CodeInfoResponse.toJSON(message.codeInfo) : void 0);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeResponse();
        message.codeInfo = object.codeInfo !== void 0 && object.codeInfo !== null ? exports.CodeInfoResponse.fromPartial(object.codeInfo) : void 0;
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryCodesRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryCodesResponse() {
      return {
        codeInfos: [],
        pagination: void 0
      };
    }
    exports.QueryCodesResponse = {
      encode(message, writer = _m093.Writer.create()) {
        for (const v of message.codeInfos) {
          exports.CodeInfoResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfos.push(exports.CodeInfoResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeInfos: Array.isArray(object == null ? void 0 : object.codeInfos) ? object.codeInfos.map((e) => exports.CodeInfoResponse.fromJSON(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.codeInfos) {
          obj.codeInfos = message.codeInfos.map((e) => e ? exports.CodeInfoResponse.toJSON(e) : void 0);
        } else {
          obj.codeInfos = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryCodesResponse();
        message.codeInfos = ((_a = object.codeInfos) == null ? void 0 : _a.map((e) => exports.CodeInfoResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryPinnedCodesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryPinnedCodesRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPinnedCodesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryPinnedCodesResponse() {
      return {
        codeIds: [],
        pagination: void 0
      };
    }
    exports.QueryPinnedCodesResponse = {
      encode(message, writer = _m093.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.codeIds) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.codeIds.push(reader.uint64());
                }
              } else {
                message.codeIds.push(reader.uint64());
              }
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeIds: Array.isArray(object == null ? void 0 : object.codeIds) ? object.codeIds.map((e) => helpers_1.Long.fromValue(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.codeIds) {
          obj.codeIds = message.codeIds.map((e) => (e || helpers_1.Long.UZERO).toString());
        } else {
          obj.codeIds = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPinnedCodesResponse();
        message.codeIds = ((_a = object.codeIds) == null ? void 0 : _a.map((e) => helpers_1.Long.fromValue(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      encode(_, writer = _m093.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryParamsResponse = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.params !== void 0) {
          types_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = types_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          params: (0, helpers_1.isSet)(object.params) ? types_1.Params.fromJSON(object.params) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? types_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? types_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCreatorRequest() {
      return {
        creatorAddress: "",
        pagination: void 0
      };
    }
    exports.QueryContractsByCreatorRequest = {
      encode(message, writer = _m093.Writer.create()) {
        if (message.creatorAddress !== "") {
          writer.uint32(10).string(message.creatorAddress);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCreatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creatorAddress = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creatorAddress: (0, helpers_1.isSet)(object.creatorAddress) ? String(object.creatorAddress) : "",
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creatorAddress !== void 0 && (obj.creatorAddress = message.creatorAddress);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCreatorRequest();
        message.creatorAddress = object.creatorAddress ?? "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCreatorResponse() {
      return {
        contractAddresses: [],
        pagination: void 0
      };
    }
    exports.QueryContractsByCreatorResponse = {
      encode(message, writer = _m093.Writer.create()) {
        for (const v of message.contractAddresses) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof _m093.Reader ? input : new _m093.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCreatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contractAddresses.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          contractAddresses: Array.isArray(object == null ? void 0 : object.contractAddresses) ? object.contractAddresses.map((e) => String(e)) : [],
          pagination: (0, helpers_1.isSet)(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.contractAddresses) {
          obj.contractAddresses = message.contractAddresses.map((e) => e);
        } else {
          obj.contractAddresses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractsByCreatorResponse();
        message.contractAddresses = ((_a = object.contractAddresses) == null ? void 0 : _a.map((e) => e)) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ContractInfo = this.ContractInfo.bind(this);
        this.ContractHistory = this.ContractHistory.bind(this);
        this.ContractsByCode = this.ContractsByCode.bind(this);
        this.AllContractState = this.AllContractState.bind(this);
        this.RawContractState = this.RawContractState.bind(this);
        this.SmartContractState = this.SmartContractState.bind(this);
        this.Code = this.Code.bind(this);
        this.Codes = this.Codes.bind(this);
        this.PinnedCodes = this.PinnedCodes.bind(this);
        this.Params = this.Params.bind(this);
        this.ContractsByCreator = this.ContractsByCreator.bind(this);
      }
      ContractInfo(request) {
        const data = exports.QueryContractInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractInfo", data);
        return promise.then((data2) => exports.QueryContractInfoResponse.decode(new _m093.Reader(data2)));
      }
      ContractHistory(request) {
        const data = exports.QueryContractHistoryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractHistory", data);
        return promise.then((data2) => exports.QueryContractHistoryResponse.decode(new _m093.Reader(data2)));
      }
      ContractsByCode(request) {
        const data = exports.QueryContractsByCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCode", data);
        return promise.then((data2) => exports.QueryContractsByCodeResponse.decode(new _m093.Reader(data2)));
      }
      AllContractState(request) {
        const data = exports.QueryAllContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "AllContractState", data);
        return promise.then((data2) => exports.QueryAllContractStateResponse.decode(new _m093.Reader(data2)));
      }
      RawContractState(request) {
        const data = exports.QueryRawContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "RawContractState", data);
        return promise.then((data2) => exports.QueryRawContractStateResponse.decode(new _m093.Reader(data2)));
      }
      SmartContractState(request) {
        const data = exports.QuerySmartContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "SmartContractState", data);
        return promise.then((data2) => exports.QuerySmartContractStateResponse.decode(new _m093.Reader(data2)));
      }
      Code(request) {
        const data = exports.QueryCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Code", data);
        return promise.then((data2) => exports.QueryCodeResponse.decode(new _m093.Reader(data2)));
      }
      Codes(request = {
        pagination: void 0
      }) {
        const data = exports.QueryCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Codes", data);
        return promise.then((data2) => exports.QueryCodesResponse.decode(new _m093.Reader(data2)));
      }
      PinnedCodes(request = {
        pagination: void 0
      }) {
        const data = exports.QueryPinnedCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "PinnedCodes", data);
        return promise.then((data2) => exports.QueryPinnedCodesResponse.decode(new _m093.Reader(data2)));
      }
      Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new _m093.Reader(data2)));
      }
      ContractsByCreator(request) {
        const data = exports.QueryContractsByCreatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCreator", data);
        return promise.then((data2) => exports.QueryContractsByCreatorResponse.decode(new _m093.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js
var require_queries = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = void 0;
    var encoding_1 = require_build();
    var stargate_1 = require_build8();
    var query_1 = require_query();
    var long_1 = __importDefault(require_long());
    function setupWasmExtension(base) {
      const rpc = (0, stargate_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        wasm: {
          listCodeInfo: async (paginationKey) => {
            const request = {
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.Codes(request);
          },
          getCode: async (id) => {
            const request = { codeId: long_1.default.fromNumber(id) };
            return queryService.Code(request);
          },
          listContractsByCodeId: async (id, paginationKey) => {
            const request = {
              codeId: long_1.default.fromNumber(id),
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractsByCode(request);
          },
          getContractInfo: async (address) => {
            const request = { address };
            return queryService.ContractInfo(request);
          },
          getContractCodeHistory: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractHistory(request);
          },
          getAllContractState: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.AllContractState(request);
          },
          queryContractRaw: async (address, key) => {
            const request = { address, queryData: key };
            return queryService.RawContractState(request);
          },
          queryContractSmart: async (address, query) => {
            const request = { address, queryData: (0, encoding_1.toUtf8)(JSON.stringify(query)) };
            const { data } = await queryService.SmartContractState(request);
            let responseText;
            try {
              responseText = (0, encoding_1.fromUtf8)(data);
            } catch (error) {
              throw new Error(`Could not UTF-8 decode smart query response from contract: ${error}`);
            }
            try {
              return JSON.parse(responseText);
            } catch (error) {
              throw new Error(`Could not JSON parse smart query response from contract: ${error}`);
            }
          }
        }
      };
    }
    exports.setupWasmExtension = setupWasmExtension;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js
var require_modules = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = exports.wasmTypes = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = void 0;
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createWasmAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "wasmTypes", { enumerable: true, get: function() {
      return messages_1.wasmTypes;
    } });
    var queries_1 = require_queries();
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return queries_1.setupWasmExtension;
    } });
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js
var require_cosmwasmclient = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CosmWasmClient = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var stargate_1 = require_build8();
    var tendermint_rpc_1 = require_build7();
    var utils_1 = require_build2();
    var types_1 = require_types();
    var modules_1 = require_modules();
    var CosmWasmClient = class _CosmWasmClient {
      constructor(tmClient) {
        this.codesCache = /* @__PURE__ */ new Map();
        if (tmClient) {
          this.tmClient = tmClient;
          this.queryClient = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, modules_1.setupWasmExtension, stargate_1.setupTxExtension);
        }
      }
      /**
       * Creates an instance by connecting to the given Tendermint RPC endpoint.
       *
       * For now this uses the Tendermint 0.34 client. If you need Tendermint 0.37
       * support, see `create`.
       */
      static async connect(endpoint) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return _CosmWasmClient.create(tmClient);
      }
      /**
       * Creates an instance from a manually created Tendermint client.
       * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async create(tmClient) {
        return new _CosmWasmClient(tmClient);
      }
      getTmClient() {
        return this.tmClient;
      }
      forceGetTmClient() {
        if (!this.tmClient) {
          throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
        }
        return this.tmClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetTmClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetTmClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? (0, stargate_1.accountFromAny)(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetTmClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
          return [];
        function withFilters(originalQuery) {
          return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;
        }
        let txs;
        if ((0, stargate_1.isSearchByHeightQuery)(query)) {
          txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];
        } else if ((0, stargate_1.isSearchBySentFromOrToQuery)(query)) {
          const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);
          const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);
          const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));
          const sentHashes = sent.map((t) => t.hash);
          txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        } else if ((0, stargate_1.isSearchByTagsQuery)(query)) {
          const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(" AND "));
          txs = await this.txsQuery(rawQuery);
        } else {
          throw new Error("Unknown query type");
        }
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
      }
      disconnect() {
        if (this.tmClient)
          this.tmClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.
      // Make sure it is kept in sync!
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            rawLog: result.rawLog,
            transactionHash: txId,
            events: result.events,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new stargate_1.BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * getCodes() returns all codes and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getCodes() {
        const allCodes = [];
        let startAtKey = void 0;
        do {
          const { codeInfos, pagination } = await this.forceGetQueryClient().wasm.listCodeInfo(startAtKey);
          const loadedCodes = codeInfos || [];
          allCodes.push(...loadedCodes);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while ((startAtKey == null ? void 0 : startAtKey.length) !== 0);
        return allCodes.map((entry) => {
          (0, utils_1.assert)(entry.creator && entry.codeId && entry.dataHash, "entry incomplete");
          return {
            id: entry.codeId.toNumber(),
            creator: entry.creator,
            checksum: (0, encoding_1.toHex)(entry.dataHash)
          };
        });
      }
      async getCodeDetails(codeId) {
        const cached = this.codesCache.get(codeId);
        if (cached)
          return cached;
        const { codeInfo, data } = await this.forceGetQueryClient().wasm.getCode(codeId);
        (0, utils_1.assert)(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data, "codeInfo missing or incomplete");
        const codeDetails = {
          id: codeInfo.codeId.toNumber(),
          creator: codeInfo.creator,
          checksum: (0, encoding_1.toHex)(codeInfo.dataHash),
          data
        };
        this.codesCache.set(codeId, codeDetails);
        return codeDetails;
      }
      /**
       * getContracts() returns all contract instances for one code and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getContracts(codeId) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contracts: contracts2, pagination } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId, startAtKey);
          const loadedContracts = contracts2 || [];
          allContracts.push(...loadedContracts);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while ((startAtKey == null ? void 0 : startAtKey.length) !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContract(address) {
        const { address: retrievedAddress, contractInfo } = await this.forceGetQueryClient().wasm.getContractInfo(address);
        if (!contractInfo)
          throw new Error(`No contract found at address "${address}"`);
        (0, utils_1.assert)(retrievedAddress, "address missing");
        (0, utils_1.assert)(contractInfo.codeId && contractInfo.creator && contractInfo.label, "contractInfo incomplete");
        return {
          address: retrievedAddress,
          codeId: contractInfo.codeId.toNumber(),
          creator: contractInfo.creator,
          admin: contractInfo.admin || void 0,
          label: contractInfo.label,
          ibcPortId: contractInfo.ibcPortId || void 0
        };
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContractCodeHistory(address) {
        const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);
        if (!result)
          throw new Error(`No contract history found for address "${address}"`);
        const operations = {
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: "Init",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: "Genesis",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: "Migrate"
        };
        return (result.entries || []).map((entry) => {
          (0, utils_1.assert)(entry.operation && entry.codeId && entry.msg);
          return {
            operation: operations[entry.operation],
            codeId: entry.codeId.toNumber(),
            msg: JSON.parse((0, encoding_1.fromUtf8)(entry.msg))
          };
        });
      }
      /**
       * Returns the data at the key if present (raw contract dependent storage data)
       * or null if no data at this key.
       *
       * Promise is rejected when contract does not exist.
       */
      async queryContractRaw(address, key) {
        await this.getContract(address);
        const { data } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);
        return data ?? null;
      }
      /**
       * Makes a smart query on the contract, returns the parsed JSON document.
       *
       * Promise is rejected when contract does not exist.
       * Promise is rejected for invalid query format.
       * Promise is rejected for invalid response format.
       */
      async queryContractSmart(address, queryMsg) {
        try {
          return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.startsWith("not found: contract")) {
              throw new Error(`No contract found at address "${address}"`);
            } else {
              throw error;
            }
          } else {
            throw error;
          }
        }
      }
      async txsQuery(query) {
        const results = await this.forceGetTmClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(stargate_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.CosmWasmClient = CosmWasmClient;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js
var require_encoding = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromBinary = exports.toBinary = void 0;
    var encoding_1 = require_build();
    function toBinary(obj) {
      return (0, encoding_1.toBase64)((0, encoding_1.toUtf8)(JSON.stringify(obj)));
    }
    exports.toBinary = toBinary;
    function fromBinary(base64) {
      return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)(base64)));
    }
    exports.fromBinary = fromBinary;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js
var require_instantiate2 = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instantiate2Address = exports._instantiate2AddressIntermediate = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var utils_1 = require_build2();
    function hash(type, key) {
      return new crypto_1.Sha256((0, crypto_1.sha256)((0, encoding_1.toAscii)(type))).update(key).digest();
    }
    function toUint64(int) {
      return math_1.Uint64.fromNumber(int).toBytesBigEndian();
    }
    function _instantiate2AddressIntermediate(checksum, creator, salt, msg, prefix) {
      (0, utils_1.assert)(checksum.length === 32);
      const creatorData = (0, encoding_1.fromBech32)(creator).data;
      const msgData = typeof msg === "string" ? (0, encoding_1.toUtf8)(msg) : new Uint8Array();
      if (salt.length < 1 || salt.length > 64)
        throw new Error("Salt must be between 1 and 64 bytes");
      const key = new Uint8Array([
        ...(0, encoding_1.toAscii)("wasm"),
        0,
        ...toUint64(checksum.length),
        ...checksum,
        ...toUint64(creatorData.length),
        ...creatorData,
        ...toUint64(salt.length),
        ...salt,
        ...toUint64(msgData.length),
        ...msgData
      ]);
      const addressData = hash("module", key);
      const address = (0, encoding_1.toBech32)(prefix, addressData);
      return { key, addressData, address };
    }
    exports._instantiate2AddressIntermediate = _instantiate2AddressIntermediate;
    function instantiate2Address(checksum, creator, salt, prefix) {
      return _instantiate2AddressIntermediate(checksum, creator, salt, null, prefix).address;
    }
    exports.instantiate2Address = instantiate2Address;
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages2 = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages2();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages2();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages2();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js
var require_signingcosmwasmclient = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var stargate_1 = require_build8();
    var tendermint_rpc_1 = require_build7();
    var utils_1 = require_build2();
    var tx_1 = require_tx2();
    var tx_2 = require_tx3();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx4();
    var long_1 = __importDefault(require_long());
    var pako_1 = __importDefault(require_pako());
    var cosmwasmclient_1 = require_cosmwasmclient();
    var modules_1 = require_modules();
    function createDeliverTxResponseErrorMessage(result) {
      return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
    }
    var SigningCosmWasmClient2 = class _SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
      constructor(tmClient, signer, options) {
        super(tmClient);
        const { registry: registry28 = new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes, ...modules_1.wasmTypes]), aminoTypes = new stargate_1.AminoTypes({
          ...(0, stargate_1.createDefaultAminoConverters)(),
          ...(0, modules_1.createWasmAminoConverters)()
        }) } = options;
        this.registry = registry28;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      /**
       * Creates an instance by connecting to the given Tendermint RPC endpoint.
       *
       * For now this uses the Tendermint 0.34 client. If you need Tendermint 0.37
       * support, see `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return _SigningCosmWasmClient.createWithSigner(tmClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Tendermint client.
       * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async createWithSigner(tmClient, signer, options = {}) {
        return new _SigningCosmWasmClient(tmClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningCosmWasmClient(void 0, signer, options);
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      /** Uploads code and returns a receipt, including the code ID */
      async upload(senderAddress, wasmCode, fee, memo = "") {
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
          value: tx_4.MsgStoreCode.fromPartial({
            sender: senderAddress,
            wasmByteCode: compressed
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const codeIdAttr = stargate_1.logs.findAttribute(parsedLogs, "store_code", "code_id");
        return {
          originalSize: wasmCode.length,
          originalChecksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(wasmCode)),
          compressedSize: compressed.length,
          compressedChecksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(compressed)),
          codeId: Number.parseInt(codeIdAttr.value, 10),
          logs: parsedLogs,
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate(senderAddress, codeId, msg, label, fee, options = {}) {
        const instantiateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
          value: tx_4.MsgInstantiateContract.fromPartial({
            sender: senderAddress,
            codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const contractAddressAttr = stargate_1.logs.findAttribute(parsedLogs, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: parsedLogs,
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async updateAdmin(senderAddress, contractAddress, newAdmin, fee, memo = "") {
        const updateAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
          value: tx_4.MsgUpdateAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            newAdmin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async clearAdmin(senderAddress, contractAddress, fee, memo = "") {
        const clearAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
          value: tx_4.MsgClearAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async migrate(senderAddress, contractAddress, codeId, migrateMsg, fee, memo = "") {
        const migrateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
          value: tx_4.MsgMigrateContract.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(migrateMsg))
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async execute(senderAddress, contractAddress, msg, fee, memo = "", funds) {
        const instruction = {
          contractAddress,
          msg,
          funds
        };
        return this.executeMultiple(senderAddress, [instruction], fee, memo);
      }
      /**
       * Like `execute` but allows executing multiple messages in one transaction.
       */
      async executeMultiple(senderAddress, instructions, fee, memo = "") {
        const msgs = instructions.map((i) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: tx_4.MsgExecuteContract.fromPartial({
            sender: senderAddress,
            contract: i.contractAddress,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(i.msg)),
            funds: [...i.funds || []]
          })
        }));
        const result = await this.signAndBroadcast(senderAddress, msgs, fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawDelegatorRewardMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress, validatorAddress })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], fee, memo);
      }
      /**
       * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       */
      async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : 1.3;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
            memo: signed.memo
          }
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBody);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo
          }
        };
        const txBodyBytes = this.registry.encode(txBody);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningCosmWasmClient = SigningCosmWasmClient2;
  }
});

// node_modules/@cosmjs/cosmwasm-stargate/build/index.js
var require_build9 = __commonJS({
  "node_modules/@cosmjs/cosmwasm-stargate/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = exports.setupWasmExtension = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = exports.instantiate2Address = exports._instantiate2AddressIntermediate = exports.toBinary = exports.fromBinary = exports.CosmWasmClient = void 0;
    var cosmwasmclient_1 = require_cosmwasmclient();
    Object.defineProperty(exports, "CosmWasmClient", { enumerable: true, get: function() {
      return cosmwasmclient_1.CosmWasmClient;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "fromBinary", { enumerable: true, get: function() {
      return encoding_1.fromBinary;
    } });
    Object.defineProperty(exports, "toBinary", { enumerable: true, get: function() {
      return encoding_1.toBinary;
    } });
    var instantiate2_1 = require_instantiate2();
    Object.defineProperty(exports, "_instantiate2AddressIntermediate", { enumerable: true, get: function() {
      return instantiate2_1._instantiate2AddressIntermediate;
    } });
    Object.defineProperty(exports, "instantiate2Address", { enumerable: true, get: function() {
      return instantiate2_1.instantiate2Address;
    } });
    var modules_1 = require_modules();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return modules_1.createWasmAminoConverters;
    } });
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return modules_1.setupWasmExtension;
    } });
    var signingcosmwasmclient_1 = require_signingcosmwasmclient();
    Object.defineProperty(exports, "SigningCosmWasmClient", { enumerable: true, get: function() {
      return signingcosmwasmclient_1.SigningCosmWasmClient;
    } });
  }
});

// node_modules/@empower-plastic/empowerjs/module/codegen/amino/amino.js
var amino_exports = {};

// node_modules/@empower-plastic/empowerjs/module/codegen/amino/bundle.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var amino = _objectSpread({}, amino_exports);

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos_proto/cosmos.js
var cosmos_exports = {};
__export(cosmos_exports, {
  InterfaceDescriptor: () => InterfaceDescriptor,
  ScalarDescriptor: () => ScalarDescriptor,
  ScalarType: () => ScalarType,
  ScalarTypeSDKType: () => ScalarTypeSDKType,
  scalarTypeFromJSON: () => scalarTypeFromJSON,
  scalarTypeToJSON: () => scalarTypeToJSON
});
var _m0 = __toESM(require_minimal());
var ScalarType = function(ScalarType2) {
  ScalarType2[ScalarType2["SCALAR_TYPE_UNSPECIFIED"] = 0] = "SCALAR_TYPE_UNSPECIFIED";
  ScalarType2[ScalarType2["SCALAR_TYPE_STRING"] = 1] = "SCALAR_TYPE_STRING";
  ScalarType2[ScalarType2["SCALAR_TYPE_BYTES"] = 2] = "SCALAR_TYPE_BYTES";
  ScalarType2[ScalarType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return ScalarType2;
}({});
var ScalarTypeSDKType = ScalarType;
function scalarTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "SCALAR_TYPE_UNSPECIFIED":
      return ScalarType.SCALAR_TYPE_UNSPECIFIED;
    case 1:
    case "SCALAR_TYPE_STRING":
      return ScalarType.SCALAR_TYPE_STRING;
    case 2:
    case "SCALAR_TYPE_BYTES":
      return ScalarType.SCALAR_TYPE_BYTES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScalarType.UNRECOGNIZED;
  }
}
function scalarTypeToJSON(object) {
  switch (object) {
    case ScalarType.SCALAR_TYPE_UNSPECIFIED:
      return "SCALAR_TYPE_UNSPECIFIED";
    case ScalarType.SCALAR_TYPE_STRING:
      return "SCALAR_TYPE_STRING";
    case ScalarType.SCALAR_TYPE_BYTES:
      return "SCALAR_TYPE_BYTES";
    case ScalarType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseInterfaceDescriptor() {
  return {
    name: "",
    description: ""
  };
}
var InterfaceDescriptor = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInterfaceDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    return obj;
  },
  fromPartial(object) {
    var _object$name, _object$description;
    const message = createBaseInterfaceDescriptor();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.description = (_object$description = object.description) !== null && _object$description !== void 0 ? _object$description : "";
    return message;
  }
};
function createBaseScalarDescriptor() {
  return {
    name: "",
    description: "",
    fieldType: []
  };
}
var ScalarDescriptor = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    writer.uint32(26).fork();
    for (const v of message.fieldType) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScalarDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fieldType.push(reader.int32());
            }
          } else {
            message.fieldType.push(reader.int32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      fieldType: Array.isArray(object === null || object === void 0 ? void 0 : object.fieldType) ? object.fieldType.map((e) => scalarTypeFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    if (message.fieldType) {
      obj.fieldType = message.fieldType.map((e) => scalarTypeToJSON(e));
    } else {
      obj.fieldType = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$name2, _object$description2, _object$fieldType;
    const message = createBaseScalarDescriptor();
    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : "";
    message.description = (_object$description2 = object.description) !== null && _object$description2 !== void 0 ? _object$description2 : "";
    message.fieldType = ((_object$fieldType = object.fieldType) === null || _object$fieldType === void 0 ? void 0 : _object$fieldType.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos_proto/bundle.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var cosmos_proto = _objectSpread2({}, cosmos_exports);

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/app/runtime/v1alpha1/module.js
var module_exports = {};
__export(module_exports, {
  Module: () => Module,
  StoreKeyConfig: () => StoreKeyConfig
});
var _m02 = __toESM(require_minimal());
function createBaseModule() {
  return {
    appName: "",
    beginBlockers: [],
    endBlockers: [],
    initGenesis: [],
    exportGenesis: [],
    overrideStoreKeys: []
  };
}
var Module = {
  encode(message, writer = _m02.Writer.create()) {
    if (message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    for (const v of message.beginBlockers) {
      writer.uint32(18).string(v);
    }
    for (const v of message.endBlockers) {
      writer.uint32(26).string(v);
    }
    for (const v of message.initGenesis) {
      writer.uint32(34).string(v);
    }
    for (const v of message.exportGenesis) {
      writer.uint32(42).string(v);
    }
    for (const v of message.overrideStoreKeys) {
      StoreKeyConfig.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appName = reader.string();
          break;
        case 2:
          message.beginBlockers.push(reader.string());
          break;
        case 3:
          message.endBlockers.push(reader.string());
          break;
        case 4:
          message.initGenesis.push(reader.string());
          break;
        case 5:
          message.exportGenesis.push(reader.string());
          break;
        case 6:
          message.overrideStoreKeys.push(StoreKeyConfig.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appName: isSet(object.appName) ? String(object.appName) : "",
      beginBlockers: Array.isArray(object === null || object === void 0 ? void 0 : object.beginBlockers) ? object.beginBlockers.map((e) => String(e)) : [],
      endBlockers: Array.isArray(object === null || object === void 0 ? void 0 : object.endBlockers) ? object.endBlockers.map((e) => String(e)) : [],
      initGenesis: Array.isArray(object === null || object === void 0 ? void 0 : object.initGenesis) ? object.initGenesis.map((e) => String(e)) : [],
      exportGenesis: Array.isArray(object === null || object === void 0 ? void 0 : object.exportGenesis) ? object.exportGenesis.map((e) => String(e)) : [],
      overrideStoreKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.overrideStoreKeys) ? object.overrideStoreKeys.map((e) => StoreKeyConfig.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.appName !== void 0 && (obj.appName = message.appName);
    if (message.beginBlockers) {
      obj.beginBlockers = message.beginBlockers.map((e) => e);
    } else {
      obj.beginBlockers = [];
    }
    if (message.endBlockers) {
      obj.endBlockers = message.endBlockers.map((e) => e);
    } else {
      obj.endBlockers = [];
    }
    if (message.initGenesis) {
      obj.initGenesis = message.initGenesis.map((e) => e);
    } else {
      obj.initGenesis = [];
    }
    if (message.exportGenesis) {
      obj.exportGenesis = message.exportGenesis.map((e) => e);
    } else {
      obj.exportGenesis = [];
    }
    if (message.overrideStoreKeys) {
      obj.overrideStoreKeys = message.overrideStoreKeys.map((e) => e ? StoreKeyConfig.toJSON(e) : void 0);
    } else {
      obj.overrideStoreKeys = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$appName, _object$beginBlockers, _object$endBlockers, _object$initGenesis, _object$exportGenesis, _object$overrideStore;
    const message = createBaseModule();
    message.appName = (_object$appName = object.appName) !== null && _object$appName !== void 0 ? _object$appName : "";
    message.beginBlockers = ((_object$beginBlockers = object.beginBlockers) === null || _object$beginBlockers === void 0 ? void 0 : _object$beginBlockers.map((e) => e)) || [];
    message.endBlockers = ((_object$endBlockers = object.endBlockers) === null || _object$endBlockers === void 0 ? void 0 : _object$endBlockers.map((e) => e)) || [];
    message.initGenesis = ((_object$initGenesis = object.initGenesis) === null || _object$initGenesis === void 0 ? void 0 : _object$initGenesis.map((e) => e)) || [];
    message.exportGenesis = ((_object$exportGenesis = object.exportGenesis) === null || _object$exportGenesis === void 0 ? void 0 : _object$exportGenesis.map((e) => e)) || [];
    message.overrideStoreKeys = ((_object$overrideStore = object.overrideStoreKeys) === null || _object$overrideStore === void 0 ? void 0 : _object$overrideStore.map((e) => StoreKeyConfig.fromPartial(e))) || [];
    return message;
  }
};
function createBaseStoreKeyConfig() {
  return {
    moduleName: "",
    kvStoreKey: ""
  };
}
var StoreKeyConfig = {
  encode(message, writer = _m02.Writer.create()) {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.kvStoreKey !== "") {
      writer.uint32(18).string(message.kvStoreKey);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoreKeyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.moduleName = reader.string();
          break;
        case 2:
          message.kvStoreKey = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      moduleName: isSet(object.moduleName) ? String(object.moduleName) : "",
      kvStoreKey: isSet(object.kvStoreKey) ? String(object.kvStoreKey) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.moduleName !== void 0 && (obj.moduleName = message.moduleName);
    message.kvStoreKey !== void 0 && (obj.kvStoreKey = message.kvStoreKey);
    return obj;
  },
  fromPartial(object) {
    var _object$moduleName, _object$kvStoreKey;
    const message = createBaseStoreKeyConfig();
    message.moduleName = (_object$moduleName = object.moduleName) !== null && _object$moduleName !== void 0 ? _object$moduleName : "";
    message.kvStoreKey = (_object$kvStoreKey = object.kvStoreKey) !== null && _object$kvStoreKey !== void 0 ? _object$kvStoreKey : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/app/v1alpha1/module.js
var module_exports2 = {};
__export(module_exports2, {
  MigrateFromInfo: () => MigrateFromInfo,
  ModuleDescriptor: () => ModuleDescriptor,
  PackageReference: () => PackageReference
});
var _m03 = __toESM(require_minimal());
function createBaseModuleDescriptor() {
  return {
    goImport: "",
    usePackage: [],
    canMigrateFrom: []
  };
}
var ModuleDescriptor = {
  encode(message, writer = _m03.Writer.create()) {
    if (message.goImport !== "") {
      writer.uint32(10).string(message.goImport);
    }
    for (const v of message.usePackage) {
      PackageReference.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.canMigrateFrom) {
      MigrateFromInfo.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m03.Reader ? input : new _m03.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModuleDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.goImport = reader.string();
          break;
        case 2:
          message.usePackage.push(PackageReference.decode(reader, reader.uint32()));
          break;
        case 3:
          message.canMigrateFrom.push(MigrateFromInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      goImport: isSet(object.goImport) ? String(object.goImport) : "",
      usePackage: Array.isArray(object === null || object === void 0 ? void 0 : object.usePackage) ? object.usePackage.map((e) => PackageReference.fromJSON(e)) : [],
      canMigrateFrom: Array.isArray(object === null || object === void 0 ? void 0 : object.canMigrateFrom) ? object.canMigrateFrom.map((e) => MigrateFromInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.goImport !== void 0 && (obj.goImport = message.goImport);
    if (message.usePackage) {
      obj.usePackage = message.usePackage.map((e) => e ? PackageReference.toJSON(e) : void 0);
    } else {
      obj.usePackage = [];
    }
    if (message.canMigrateFrom) {
      obj.canMigrateFrom = message.canMigrateFrom.map((e) => e ? MigrateFromInfo.toJSON(e) : void 0);
    } else {
      obj.canMigrateFrom = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$goImport, _object$usePackage, _object$canMigrateFro;
    const message = createBaseModuleDescriptor();
    message.goImport = (_object$goImport = object.goImport) !== null && _object$goImport !== void 0 ? _object$goImport : "";
    message.usePackage = ((_object$usePackage = object.usePackage) === null || _object$usePackage === void 0 ? void 0 : _object$usePackage.map((e) => PackageReference.fromPartial(e))) || [];
    message.canMigrateFrom = ((_object$canMigrateFro = object.canMigrateFrom) === null || _object$canMigrateFro === void 0 ? void 0 : _object$canMigrateFro.map((e) => MigrateFromInfo.fromPartial(e))) || [];
    return message;
  }
};
function createBasePackageReference() {
  return {
    name: "",
    revision: 0
  };
}
var PackageReference = {
  encode(message, writer = _m03.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revision !== 0) {
      writer.uint32(16).uint32(message.revision);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m03.Reader ? input : new _m03.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePackageReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.revision = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      revision: isSet(object.revision) ? Number(object.revision) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.revision !== void 0 && (obj.revision = Math.round(message.revision));
    return obj;
  },
  fromPartial(object) {
    var _object$name, _object$revision;
    const message = createBasePackageReference();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.revision = (_object$revision = object.revision) !== null && _object$revision !== void 0 ? _object$revision : 0;
    return message;
  }
};
function createBaseMigrateFromInfo() {
  return {
    module: ""
  };
}
var MigrateFromInfo = {
  encode(message, writer = _m03.Writer.create()) {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m03.Reader ? input : new _m03.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMigrateFromInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.module = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      module: isSet(object.module) ? String(object.module) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.module !== void 0 && (obj.module = message.module);
    return obj;
  },
  fromPartial(object) {
    var _object$module;
    const message = createBaseMigrateFromInfo();
    message.module = (_object$module = object.module) !== null && _object$module !== void 0 ? _object$module : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/auth/module/v1/module.js
var module_exports3 = {};
__export(module_exports3, {
  Module: () => Module2,
  ModuleAccountPermission: () => ModuleAccountPermission
});
var _m04 = __toESM(require_minimal());
function createBaseModule2() {
  return {
    bech32Prefix: "",
    moduleAccountPermissions: [],
    authority: ""
  };
}
var Module2 = {
  encode(message, writer = _m04.Writer.create()) {
    if (message.bech32Prefix !== "") {
      writer.uint32(10).string(message.bech32Prefix);
    }
    for (const v of message.moduleAccountPermissions) {
      ModuleAccountPermission.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m04.Reader ? input : new _m04.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bech32Prefix = reader.string();
          break;
        case 2:
          message.moduleAccountPermissions.push(ModuleAccountPermission.decode(reader, reader.uint32()));
          break;
        case 3:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bech32Prefix: isSet(object.bech32Prefix) ? String(object.bech32Prefix) : "",
      moduleAccountPermissions: Array.isArray(object === null || object === void 0 ? void 0 : object.moduleAccountPermissions) ? object.moduleAccountPermissions.map((e) => ModuleAccountPermission.fromJSON(e)) : [],
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.bech32Prefix !== void 0 && (obj.bech32Prefix = message.bech32Prefix);
    if (message.moduleAccountPermissions) {
      obj.moduleAccountPermissions = message.moduleAccountPermissions.map((e) => e ? ModuleAccountPermission.toJSON(e) : void 0);
    } else {
      obj.moduleAccountPermissions = [];
    }
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$bech32Prefix, _object$moduleAccount, _object$authority;
    const message = createBaseModule2();
    message.bech32Prefix = (_object$bech32Prefix = object.bech32Prefix) !== null && _object$bech32Prefix !== void 0 ? _object$bech32Prefix : "";
    message.moduleAccountPermissions = ((_object$moduleAccount = object.moduleAccountPermissions) === null || _object$moduleAccount === void 0 ? void 0 : _object$moduleAccount.map((e) => ModuleAccountPermission.fromPartial(e))) || [];
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};
function createBaseModuleAccountPermission() {
  return {
    account: "",
    permissions: []
  };
}
var ModuleAccountPermission = {
  encode(message, writer = _m04.Writer.create()) {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    for (const v of message.permissions) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m04.Reader ? input : new _m04.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModuleAccountPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        case 2:
          message.permissions.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      account: isSet(object.account) ? String(object.account) : "",
      permissions: Array.isArray(object === null || object === void 0 ? void 0 : object.permissions) ? object.permissions.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.account !== void 0 && (obj.account = message.account);
    if (message.permissions) {
      obj.permissions = message.permissions.map((e) => e);
    } else {
      obj.permissions = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$account, _object$permissions;
    const message = createBaseModuleAccountPermission();
    message.account = (_object$account = object.account) !== null && _object$account !== void 0 ? _object$account : "";
    message.permissions = ((_object$permissions = object.permissions) === null || _object$permissions === void 0 ? void 0 : _object$permissions.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/auth/v1beta1/genesis.js
var genesis_exports2 = {};
__export(genesis_exports2, {
  GenesisState: () => GenesisState
});
var _m05 = __toESM(require_minimal());
function createBaseGenesisState() {
  return {
    params: void 0,
    accounts: []
  };
}
var GenesisState = {
  encode(message, writer = _m05.Writer.create()) {
    if (message.params !== void 0) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.accounts) {
      Any.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m05.Reader ? input : new _m05.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params.decode(reader, reader.uint32());
          break;
        case 2:
          message.accounts.push(Any.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : void 0,
      accounts: Array.isArray(object === null || object === void 0 ? void 0 : object.accounts) ? object.accounts.map((e) => Any.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params.toJSON(message.params) : void 0);
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.accounts = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$accounts;
    const message = createBaseGenesisState();
    message.params = object.params !== void 0 && object.params !== null ? Params.fromPartial(object.params) : void 0;
    message.accounts = ((_object$accounts = object.accounts) === null || _object$accounts === void 0 ? void 0 : _object$accounts.map((e) => Any.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/authz/module/v1/module.js
var module_exports4 = {};
__export(module_exports4, {
  Module: () => Module3
});
var _m06 = __toESM(require_minimal());
function createBaseModule3() {
  return {};
}
var Module3 = {
  encode(_, writer = _m06.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m06.Reader ? input : new _m06.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule3();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/authz/v1beta1/event.js
var event_exports = {};
__export(event_exports, {
  EventGrant: () => EventGrant,
  EventRevoke: () => EventRevoke
});
var _m07 = __toESM(require_minimal());
function createBaseEventGrant() {
  return {
    msgTypeUrl: "",
    granter: "",
    grantee: ""
  };
}
var EventGrant = {
  encode(message, writer = _m07.Writer.create()) {
    if (message.msgTypeUrl !== "") {
      writer.uint32(18).string(message.msgTypeUrl);
    }
    if (message.granter !== "") {
      writer.uint32(26).string(message.granter);
    }
    if (message.grantee !== "") {
      writer.uint32(34).string(message.grantee);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m07.Reader ? input : new _m07.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.msgTypeUrl = reader.string();
          break;
        case 3:
          message.granter = reader.string();
          break;
        case 4:
          message.grantee = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : "",
      granter: isSet(object.granter) ? String(object.granter) : "",
      grantee: isSet(object.grantee) ? String(object.grantee) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
    message.granter !== void 0 && (obj.granter = message.granter);
    message.grantee !== void 0 && (obj.grantee = message.grantee);
    return obj;
  },
  fromPartial(object) {
    var _object$msgTypeUrl, _object$granter, _object$grantee;
    const message = createBaseEventGrant();
    message.msgTypeUrl = (_object$msgTypeUrl = object.msgTypeUrl) !== null && _object$msgTypeUrl !== void 0 ? _object$msgTypeUrl : "";
    message.granter = (_object$granter = object.granter) !== null && _object$granter !== void 0 ? _object$granter : "";
    message.grantee = (_object$grantee = object.grantee) !== null && _object$grantee !== void 0 ? _object$grantee : "";
    return message;
  }
};
function createBaseEventRevoke() {
  return {
    msgTypeUrl: "",
    granter: "",
    grantee: ""
  };
}
var EventRevoke = {
  encode(message, writer = _m07.Writer.create()) {
    if (message.msgTypeUrl !== "") {
      writer.uint32(18).string(message.msgTypeUrl);
    }
    if (message.granter !== "") {
      writer.uint32(26).string(message.granter);
    }
    if (message.grantee !== "") {
      writer.uint32(34).string(message.grantee);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m07.Reader ? input : new _m07.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventRevoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.msgTypeUrl = reader.string();
          break;
        case 3:
          message.granter = reader.string();
          break;
        case 4:
          message.grantee = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : "",
      granter: isSet(object.granter) ? String(object.granter) : "",
      grantee: isSet(object.grantee) ? String(object.grantee) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
    message.granter !== void 0 && (obj.granter = message.granter);
    message.grantee !== void 0 && (obj.grantee = message.grantee);
    return obj;
  },
  fromPartial(object) {
    var _object$msgTypeUrl2, _object$granter2, _object$grantee2;
    const message = createBaseEventRevoke();
    message.msgTypeUrl = (_object$msgTypeUrl2 = object.msgTypeUrl) !== null && _object$msgTypeUrl2 !== void 0 ? _object$msgTypeUrl2 : "";
    message.granter = (_object$granter2 = object.granter) !== null && _object$granter2 !== void 0 ? _object$granter2 : "";
    message.grantee = (_object$grantee2 = object.grantee) !== null && _object$grantee2 !== void 0 ? _object$grantee2 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/authz/v1beta1/genesis.js
var genesis_exports3 = {};
__export(genesis_exports3, {
  GenesisState: () => GenesisState2
});
var _m08 = __toESM(require_minimal());
function createBaseGenesisState2() {
  return {
    authorization: []
  };
}
var GenesisState2 = {
  encode(message, writer = _m08.Writer.create()) {
    for (const v of message.authorization) {
      GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m08.Reader ? input : new _m08.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authorization.push(GrantAuthorization.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorization: Array.isArray(object === null || object === void 0 ? void 0 : object.authorization) ? object.authorization.map((e) => GrantAuthorization.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.authorization) {
      obj.authorization = message.authorization.map((e) => e ? GrantAuthorization.toJSON(e) : void 0);
    } else {
      obj.authorization = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$authorization;
    const message = createBaseGenesisState2();
    message.authorization = ((_object$authorization = object.authorization) === null || _object$authorization === void 0 ? void 0 : _object$authorization.map((e) => GrantAuthorization.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bank/module/v1/module.js
var module_exports5 = {};
__export(module_exports5, {
  Module: () => Module4
});
var _m09 = __toESM(require_minimal());
function createBaseModule4() {
  return {
    blockedModuleAccountsOverride: [],
    authority: ""
  };
}
var Module4 = {
  encode(message, writer = _m09.Writer.create()) {
    for (const v of message.blockedModuleAccountsOverride) {
      writer.uint32(10).string(v);
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m09.Reader ? input : new _m09.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockedModuleAccountsOverride.push(reader.string());
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      blockedModuleAccountsOverride: Array.isArray(object === null || object === void 0 ? void 0 : object.blockedModuleAccountsOverride) ? object.blockedModuleAccountsOverride.map((e) => String(e)) : [],
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.blockedModuleAccountsOverride) {
      obj.blockedModuleAccountsOverride = message.blockedModuleAccountsOverride.map((e) => e);
    } else {
      obj.blockedModuleAccountsOverride = [];
    }
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$blockedModule, _object$authority;
    const message = createBaseModule4();
    message.blockedModuleAccountsOverride = ((_object$blockedModule = object.blockedModuleAccountsOverride) === null || _object$blockedModule === void 0 ? void 0 : _object$blockedModule.map((e) => e)) || [];
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bank/v1beta1/authz.js
var authz_exports2 = {};
__export(authz_exports2, {
  SendAuthorization: () => SendAuthorization
});
var _m010 = __toESM(require_minimal());
function createBaseSendAuthorization() {
  return {
    spendLimit: [],
    allowList: []
  };
}
var SendAuthorization = {
  encode(message, writer = _m010.Writer.create()) {
    for (const v of message.spendLimit) {
      Coin.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.allowList) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m010.Reader ? input : new _m010.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSendAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spendLimit.push(Coin.decode(reader, reader.uint32()));
          break;
        case 2:
          message.allowList.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      spendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.spendLimit) ? object.spendLimit.map((e) => Coin.fromJSON(e)) : [],
      allowList: Array.isArray(object === null || object === void 0 ? void 0 : object.allowList) ? object.allowList.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.spendLimit) {
      obj.spendLimit = message.spendLimit.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.spendLimit = [];
    }
    if (message.allowList) {
      obj.allowList = message.allowList.map((e) => e);
    } else {
      obj.allowList = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$spendLimit, _object$allowList;
    const message = createBaseSendAuthorization();
    message.spendLimit = ((_object$spendLimit = object.spendLimit) === null || _object$spendLimit === void 0 ? void 0 : _object$spendLimit.map((e) => Coin.fromPartial(e))) || [];
    message.allowList = ((_object$allowList = object.allowList) === null || _object$allowList === void 0 ? void 0 : _object$allowList.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bank/v1beta1/genesis.js
var genesis_exports4 = {};
__export(genesis_exports4, {
  Balance: () => Balance,
  GenesisState: () => GenesisState3
});
var _m011 = __toESM(require_minimal());
function createBaseGenesisState3() {
  return {
    params: void 0,
    balances: [],
    supply: [],
    denomMetadata: [],
    sendEnabled: []
  };
}
var GenesisState3 = {
  encode(message, writer = _m011.Writer.create()) {
    if (message.params !== void 0) {
      Params2.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.balances) {
      Balance.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.supply) {
      Coin.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.denomMetadata) {
      Metadata.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.sendEnabled) {
      SendEnabled.encode(v, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m011.Reader ? input : new _m011.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params2.decode(reader, reader.uint32());
          break;
        case 2:
          message.balances.push(Balance.decode(reader, reader.uint32()));
          break;
        case 3:
          message.supply.push(Coin.decode(reader, reader.uint32()));
          break;
        case 4:
          message.denomMetadata.push(Metadata.decode(reader, reader.uint32()));
          break;
        case 5:
          message.sendEnabled.push(SendEnabled.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params2.fromJSON(object.params) : void 0,
      balances: Array.isArray(object === null || object === void 0 ? void 0 : object.balances) ? object.balances.map((e) => Balance.fromJSON(e)) : [],
      supply: Array.isArray(object === null || object === void 0 ? void 0 : object.supply) ? object.supply.map((e) => Coin.fromJSON(e)) : [],
      denomMetadata: Array.isArray(object === null || object === void 0 ? void 0 : object.denomMetadata) ? object.denomMetadata.map((e) => Metadata.fromJSON(e)) : [],
      sendEnabled: Array.isArray(object === null || object === void 0 ? void 0 : object.sendEnabled) ? object.sendEnabled.map((e) => SendEnabled.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params2.toJSON(message.params) : void 0);
    if (message.balances) {
      obj.balances = message.balances.map((e) => e ? Balance.toJSON(e) : void 0);
    } else {
      obj.balances = [];
    }
    if (message.supply) {
      obj.supply = message.supply.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.supply = [];
    }
    if (message.denomMetadata) {
      obj.denomMetadata = message.denomMetadata.map((e) => e ? Metadata.toJSON(e) : void 0);
    } else {
      obj.denomMetadata = [];
    }
    if (message.sendEnabled) {
      obj.sendEnabled = message.sendEnabled.map((e) => e ? SendEnabled.toJSON(e) : void 0);
    } else {
      obj.sendEnabled = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$balances, _object$supply, _object$denomMetadata, _object$sendEnabled;
    const message = createBaseGenesisState3();
    message.params = object.params !== void 0 && object.params !== null ? Params2.fromPartial(object.params) : void 0;
    message.balances = ((_object$balances = object.balances) === null || _object$balances === void 0 ? void 0 : _object$balances.map((e) => Balance.fromPartial(e))) || [];
    message.supply = ((_object$supply = object.supply) === null || _object$supply === void 0 ? void 0 : _object$supply.map((e) => Coin.fromPartial(e))) || [];
    message.denomMetadata = ((_object$denomMetadata = object.denomMetadata) === null || _object$denomMetadata === void 0 ? void 0 : _object$denomMetadata.map((e) => Metadata.fromPartial(e))) || [];
    message.sendEnabled = ((_object$sendEnabled = object.sendEnabled) === null || _object$sendEnabled === void 0 ? void 0 : _object$sendEnabled.map((e) => SendEnabled.fromPartial(e))) || [];
    return message;
  }
};
function createBaseBalance() {
  return {
    address: "",
    coins: []
  };
}
var Balance = {
  encode(message, writer = _m011.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.coins) {
      Coin.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m011.Reader ? input : new _m011.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.coins.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins) ? object.coins.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    if (message.coins) {
      obj.coins = message.coins.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.coins = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$address, _object$coins;
    const message = createBaseBalance();
    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : "";
    message.coins = ((_object$coins = object.coins) === null || _object$coins === void 0 ? void 0 : _object$coins.map((e) => Coin.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/kv/v1beta1/kv.js
var kv_exports = {};
__export(kv_exports, {
  Pair: () => Pair,
  Pairs: () => Pairs
});
var _m012 = __toESM(require_minimal());
function createBasePairs() {
  return {
    pairs: []
  };
}
var Pairs = {
  encode(message, writer = _m012.Writer.create()) {
    for (const v of message.pairs) {
      Pair.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m012.Reader ? input : new _m012.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePairs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pairs.push(Pair.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pairs: Array.isArray(object === null || object === void 0 ? void 0 : object.pairs) ? object.pairs.map((e) => Pair.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.pairs) {
      obj.pairs = message.pairs.map((e) => e ? Pair.toJSON(e) : void 0);
    } else {
      obj.pairs = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$pairs;
    const message = createBasePairs();
    message.pairs = ((_object$pairs = object.pairs) === null || _object$pairs === void 0 ? void 0 : _object$pairs.map((e) => Pair.fromPartial(e))) || [];
    return message;
  }
};
function createBasePair() {
  return {
    key: new Uint8Array(),
    value: new Uint8Array()
  };
}
var Pair = {
  encode(message, writer = _m012.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m012.Reader ? input : new _m012.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key, _object$value;
    const message = createBasePair();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/reflection/v1beta1/reflection.js
var reflection_exports = {};
__export(reflection_exports, {
  ListAllInterfacesRequest: () => ListAllInterfacesRequest,
  ListAllInterfacesResponse: () => ListAllInterfacesResponse,
  ListImplementationsRequest: () => ListImplementationsRequest,
  ListImplementationsResponse: () => ListImplementationsResponse
});
var _m013 = __toESM(require_minimal());
function createBaseListAllInterfacesRequest() {
  return {};
}
var ListAllInterfacesRequest = {
  encode(_, writer = _m013.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m013.Reader ? input : new _m013.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListAllInterfacesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseListAllInterfacesRequest();
    return message;
  }
};
function createBaseListAllInterfacesResponse() {
  return {
    interfaceNames: []
  };
}
var ListAllInterfacesResponse = {
  encode(message, writer = _m013.Writer.create()) {
    for (const v of message.interfaceNames) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m013.Reader ? input : new _m013.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListAllInterfacesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.interfaceNames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      interfaceNames: Array.isArray(object === null || object === void 0 ? void 0 : object.interfaceNames) ? object.interfaceNames.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.interfaceNames) {
      obj.interfaceNames = message.interfaceNames.map((e) => e);
    } else {
      obj.interfaceNames = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$interfaceName;
    const message = createBaseListAllInterfacesResponse();
    message.interfaceNames = ((_object$interfaceName = object.interfaceNames) === null || _object$interfaceName === void 0 ? void 0 : _object$interfaceName.map((e) => e)) || [];
    return message;
  }
};
function createBaseListImplementationsRequest() {
  return {
    interfaceName: ""
  };
}
var ListImplementationsRequest = {
  encode(message, writer = _m013.Writer.create()) {
    if (message.interfaceName !== "") {
      writer.uint32(10).string(message.interfaceName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m013.Reader ? input : new _m013.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListImplementationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.interfaceName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      interfaceName: isSet(object.interfaceName) ? String(object.interfaceName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.interfaceName !== void 0 && (obj.interfaceName = message.interfaceName);
    return obj;
  },
  fromPartial(object) {
    var _object$interfaceName2;
    const message = createBaseListImplementationsRequest();
    message.interfaceName = (_object$interfaceName2 = object.interfaceName) !== null && _object$interfaceName2 !== void 0 ? _object$interfaceName2 : "";
    return message;
  }
};
function createBaseListImplementationsResponse() {
  return {
    implementationMessageNames: []
  };
}
var ListImplementationsResponse = {
  encode(message, writer = _m013.Writer.create()) {
    for (const v of message.implementationMessageNames) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m013.Reader ? input : new _m013.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListImplementationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.implementationMessageNames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      implementationMessageNames: Array.isArray(object === null || object === void 0 ? void 0 : object.implementationMessageNames) ? object.implementationMessageNames.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.implementationMessageNames) {
      obj.implementationMessageNames = message.implementationMessageNames.map((e) => e);
    } else {
      obj.implementationMessageNames = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$implementatio;
    const message = createBaseListImplementationsResponse();
    message.implementationMessageNames = ((_object$implementatio = object.implementationMessageNames) === null || _object$implementatio === void 0 ? void 0 : _object$implementatio.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/reflection/v2alpha1/reflection.js
var reflection_exports2 = {};
__export(reflection_exports2, {
  AppDescriptor: () => AppDescriptor,
  AuthnDescriptor: () => AuthnDescriptor,
  ChainDescriptor: () => ChainDescriptor,
  CodecDescriptor: () => CodecDescriptor,
  ConfigurationDescriptor: () => ConfigurationDescriptor,
  GetAuthnDescriptorRequest: () => GetAuthnDescriptorRequest,
  GetAuthnDescriptorResponse: () => GetAuthnDescriptorResponse,
  GetChainDescriptorRequest: () => GetChainDescriptorRequest,
  GetChainDescriptorResponse: () => GetChainDescriptorResponse,
  GetCodecDescriptorRequest: () => GetCodecDescriptorRequest,
  GetCodecDescriptorResponse: () => GetCodecDescriptorResponse,
  GetConfigurationDescriptorRequest: () => GetConfigurationDescriptorRequest,
  GetConfigurationDescriptorResponse: () => GetConfigurationDescriptorResponse,
  GetQueryServicesDescriptorRequest: () => GetQueryServicesDescriptorRequest,
  GetQueryServicesDescriptorResponse: () => GetQueryServicesDescriptorResponse,
  GetTxDescriptorRequest: () => GetTxDescriptorRequest,
  GetTxDescriptorResponse: () => GetTxDescriptorResponse,
  InterfaceAcceptingMessageDescriptor: () => InterfaceAcceptingMessageDescriptor,
  InterfaceDescriptor: () => InterfaceDescriptor2,
  InterfaceImplementerDescriptor: () => InterfaceImplementerDescriptor,
  MsgDescriptor: () => MsgDescriptor,
  QueryMethodDescriptor: () => QueryMethodDescriptor,
  QueryServiceDescriptor: () => QueryServiceDescriptor,
  QueryServicesDescriptor: () => QueryServicesDescriptor,
  SigningModeDescriptor: () => SigningModeDescriptor,
  TxDescriptor: () => TxDescriptor
});
var _m014 = __toESM(require_minimal());
function createBaseAppDescriptor() {
  return {
    authn: void 0,
    chain: void 0,
    codec: void 0,
    configuration: void 0,
    queryServices: void 0,
    tx: void 0
  };
}
var AppDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.authn !== void 0) {
      AuthnDescriptor.encode(message.authn, writer.uint32(10).fork()).ldelim();
    }
    if (message.chain !== void 0) {
      ChainDescriptor.encode(message.chain, writer.uint32(18).fork()).ldelim();
    }
    if (message.codec !== void 0) {
      CodecDescriptor.encode(message.codec, writer.uint32(26).fork()).ldelim();
    }
    if (message.configuration !== void 0) {
      ConfigurationDescriptor.encode(message.configuration, writer.uint32(34).fork()).ldelim();
    }
    if (message.queryServices !== void 0) {
      QueryServicesDescriptor.encode(message.queryServices, writer.uint32(42).fork()).ldelim();
    }
    if (message.tx !== void 0) {
      TxDescriptor.encode(message.tx, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authn = AuthnDescriptor.decode(reader, reader.uint32());
          break;
        case 2:
          message.chain = ChainDescriptor.decode(reader, reader.uint32());
          break;
        case 3:
          message.codec = CodecDescriptor.decode(reader, reader.uint32());
          break;
        case 4:
          message.configuration = ConfigurationDescriptor.decode(reader, reader.uint32());
          break;
        case 5:
          message.queryServices = QueryServicesDescriptor.decode(reader, reader.uint32());
          break;
        case 6:
          message.tx = TxDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authn: isSet(object.authn) ? AuthnDescriptor.fromJSON(object.authn) : void 0,
      chain: isSet(object.chain) ? ChainDescriptor.fromJSON(object.chain) : void 0,
      codec: isSet(object.codec) ? CodecDescriptor.fromJSON(object.codec) : void 0,
      configuration: isSet(object.configuration) ? ConfigurationDescriptor.fromJSON(object.configuration) : void 0,
      queryServices: isSet(object.queryServices) ? QueryServicesDescriptor.fromJSON(object.queryServices) : void 0,
      tx: isSet(object.tx) ? TxDescriptor.fromJSON(object.tx) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.authn !== void 0 && (obj.authn = message.authn ? AuthnDescriptor.toJSON(message.authn) : void 0);
    message.chain !== void 0 && (obj.chain = message.chain ? ChainDescriptor.toJSON(message.chain) : void 0);
    message.codec !== void 0 && (obj.codec = message.codec ? CodecDescriptor.toJSON(message.codec) : void 0);
    message.configuration !== void 0 && (obj.configuration = message.configuration ? ConfigurationDescriptor.toJSON(message.configuration) : void 0);
    message.queryServices !== void 0 && (obj.queryServices = message.queryServices ? QueryServicesDescriptor.toJSON(message.queryServices) : void 0);
    message.tx !== void 0 && (obj.tx = message.tx ? TxDescriptor.toJSON(message.tx) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppDescriptor();
    message.authn = object.authn !== void 0 && object.authn !== null ? AuthnDescriptor.fromPartial(object.authn) : void 0;
    message.chain = object.chain !== void 0 && object.chain !== null ? ChainDescriptor.fromPartial(object.chain) : void 0;
    message.codec = object.codec !== void 0 && object.codec !== null ? CodecDescriptor.fromPartial(object.codec) : void 0;
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? ConfigurationDescriptor.fromPartial(object.configuration) : void 0;
    message.queryServices = object.queryServices !== void 0 && object.queryServices !== null ? QueryServicesDescriptor.fromPartial(object.queryServices) : void 0;
    message.tx = object.tx !== void 0 && object.tx !== null ? TxDescriptor.fromPartial(object.tx) : void 0;
    return message;
  }
};
function createBaseTxDescriptor() {
  return {
    fullname: "",
    msgs: []
  };
}
var TxDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.fullname !== "") {
      writer.uint32(10).string(message.fullname);
    }
    for (const v of message.msgs) {
      MsgDescriptor.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTxDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;
        case 2:
          message.msgs.push(MsgDescriptor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullname: isSet(object.fullname) ? String(object.fullname) : "",
      msgs: Array.isArray(object === null || object === void 0 ? void 0 : object.msgs) ? object.msgs.map((e) => MsgDescriptor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    if (message.msgs) {
      obj.msgs = message.msgs.map((e) => e ? MsgDescriptor.toJSON(e) : void 0);
    } else {
      obj.msgs = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$fullname, _object$msgs;
    const message = createBaseTxDescriptor();
    message.fullname = (_object$fullname = object.fullname) !== null && _object$fullname !== void 0 ? _object$fullname : "";
    message.msgs = ((_object$msgs = object.msgs) === null || _object$msgs === void 0 ? void 0 : _object$msgs.map((e) => MsgDescriptor.fromPartial(e))) || [];
    return message;
  }
};
function createBaseAuthnDescriptor() {
  return {
    signModes: []
  };
}
var AuthnDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    for (const v of message.signModes) {
      SigningModeDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthnDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signModes.push(SigningModeDescriptor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signModes: Array.isArray(object === null || object === void 0 ? void 0 : object.signModes) ? object.signModes.map((e) => SigningModeDescriptor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.signModes) {
      obj.signModes = message.signModes.map((e) => e ? SigningModeDescriptor.toJSON(e) : void 0);
    } else {
      obj.signModes = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$signModes;
    const message = createBaseAuthnDescriptor();
    message.signModes = ((_object$signModes = object.signModes) === null || _object$signModes === void 0 ? void 0 : _object$signModes.map((e) => SigningModeDescriptor.fromPartial(e))) || [];
    return message;
  }
};
function createBaseSigningModeDescriptor() {
  return {
    name: "",
    number: 0,
    authnInfoProviderMethodFullname: ""
  };
}
var SigningModeDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== 0) {
      writer.uint32(16).int32(message.number);
    }
    if (message.authnInfoProviderMethodFullname !== "") {
      writer.uint32(26).string(message.authnInfoProviderMethodFullname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSigningModeDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.number = reader.int32();
          break;
        case 3:
          message.authnInfoProviderMethodFullname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      number: isSet(object.number) ? Number(object.number) : 0,
      authnInfoProviderMethodFullname: isSet(object.authnInfoProviderMethodFullname) ? String(object.authnInfoProviderMethodFullname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.number !== void 0 && (obj.number = Math.round(message.number));
    message.authnInfoProviderMethodFullname !== void 0 && (obj.authnInfoProviderMethodFullname = message.authnInfoProviderMethodFullname);
    return obj;
  },
  fromPartial(object) {
    var _object$name, _object$number, _object$authnInfoProv;
    const message = createBaseSigningModeDescriptor();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.number = (_object$number = object.number) !== null && _object$number !== void 0 ? _object$number : 0;
    message.authnInfoProviderMethodFullname = (_object$authnInfoProv = object.authnInfoProviderMethodFullname) !== null && _object$authnInfoProv !== void 0 ? _object$authnInfoProv : "";
    return message;
  }
};
function createBaseChainDescriptor() {
  return {
    id: ""
  };
}
var ChainDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseChainDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? String(object.id) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    var _object$id;
    const message = createBaseChainDescriptor();
    message.id = (_object$id = object.id) !== null && _object$id !== void 0 ? _object$id : "";
    return message;
  }
};
function createBaseCodecDescriptor() {
  return {
    interfaces: []
  };
}
var CodecDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    for (const v of message.interfaces) {
      InterfaceDescriptor2.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCodecDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.interfaces.push(InterfaceDescriptor2.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      interfaces: Array.isArray(object === null || object === void 0 ? void 0 : object.interfaces) ? object.interfaces.map((e) => InterfaceDescriptor2.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.interfaces) {
      obj.interfaces = message.interfaces.map((e) => e ? InterfaceDescriptor2.toJSON(e) : void 0);
    } else {
      obj.interfaces = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$interfaces;
    const message = createBaseCodecDescriptor();
    message.interfaces = ((_object$interfaces = object.interfaces) === null || _object$interfaces === void 0 ? void 0 : _object$interfaces.map((e) => InterfaceDescriptor2.fromPartial(e))) || [];
    return message;
  }
};
function createBaseInterfaceDescriptor2() {
  return {
    fullname: "",
    interfaceAcceptingMessages: [],
    interfaceImplementers: []
  };
}
var InterfaceDescriptor2 = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.fullname !== "") {
      writer.uint32(10).string(message.fullname);
    }
    for (const v of message.interfaceAcceptingMessages) {
      InterfaceAcceptingMessageDescriptor.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.interfaceImplementers) {
      InterfaceImplementerDescriptor.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInterfaceDescriptor2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;
        case 2:
          message.interfaceAcceptingMessages.push(InterfaceAcceptingMessageDescriptor.decode(reader, reader.uint32()));
          break;
        case 3:
          message.interfaceImplementers.push(InterfaceImplementerDescriptor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullname: isSet(object.fullname) ? String(object.fullname) : "",
      interfaceAcceptingMessages: Array.isArray(object === null || object === void 0 ? void 0 : object.interfaceAcceptingMessages) ? object.interfaceAcceptingMessages.map((e) => InterfaceAcceptingMessageDescriptor.fromJSON(e)) : [],
      interfaceImplementers: Array.isArray(object === null || object === void 0 ? void 0 : object.interfaceImplementers) ? object.interfaceImplementers.map((e) => InterfaceImplementerDescriptor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    if (message.interfaceAcceptingMessages) {
      obj.interfaceAcceptingMessages = message.interfaceAcceptingMessages.map((e) => e ? InterfaceAcceptingMessageDescriptor.toJSON(e) : void 0);
    } else {
      obj.interfaceAcceptingMessages = [];
    }
    if (message.interfaceImplementers) {
      obj.interfaceImplementers = message.interfaceImplementers.map((e) => e ? InterfaceImplementerDescriptor.toJSON(e) : void 0);
    } else {
      obj.interfaceImplementers = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$fullname2, _object$interfaceAcce, _object$interfaceImpl;
    const message = createBaseInterfaceDescriptor2();
    message.fullname = (_object$fullname2 = object.fullname) !== null && _object$fullname2 !== void 0 ? _object$fullname2 : "";
    message.interfaceAcceptingMessages = ((_object$interfaceAcce = object.interfaceAcceptingMessages) === null || _object$interfaceAcce === void 0 ? void 0 : _object$interfaceAcce.map((e) => InterfaceAcceptingMessageDescriptor.fromPartial(e))) || [];
    message.interfaceImplementers = ((_object$interfaceImpl = object.interfaceImplementers) === null || _object$interfaceImpl === void 0 ? void 0 : _object$interfaceImpl.map((e) => InterfaceImplementerDescriptor.fromPartial(e))) || [];
    return message;
  }
};
function createBaseInterfaceImplementerDescriptor() {
  return {
    fullname: "",
    typeUrl: ""
  };
}
var InterfaceImplementerDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.fullname !== "") {
      writer.uint32(10).string(message.fullname);
    }
    if (message.typeUrl !== "") {
      writer.uint32(18).string(message.typeUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInterfaceImplementerDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;
        case 2:
          message.typeUrl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullname: isSet(object.fullname) ? String(object.fullname) : "",
      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
    return obj;
  },
  fromPartial(object) {
    var _object$fullname3, _object$typeUrl;
    const message = createBaseInterfaceImplementerDescriptor();
    message.fullname = (_object$fullname3 = object.fullname) !== null && _object$fullname3 !== void 0 ? _object$fullname3 : "";
    message.typeUrl = (_object$typeUrl = object.typeUrl) !== null && _object$typeUrl !== void 0 ? _object$typeUrl : "";
    return message;
  }
};
function createBaseInterfaceAcceptingMessageDescriptor() {
  return {
    fullname: "",
    fieldDescriptorNames: []
  };
}
var InterfaceAcceptingMessageDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.fullname !== "") {
      writer.uint32(10).string(message.fullname);
    }
    for (const v of message.fieldDescriptorNames) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInterfaceAcceptingMessageDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;
        case 2:
          message.fieldDescriptorNames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullname: isSet(object.fullname) ? String(object.fullname) : "",
      fieldDescriptorNames: Array.isArray(object === null || object === void 0 ? void 0 : object.fieldDescriptorNames) ? object.fieldDescriptorNames.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    if (message.fieldDescriptorNames) {
      obj.fieldDescriptorNames = message.fieldDescriptorNames.map((e) => e);
    } else {
      obj.fieldDescriptorNames = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$fullname4, _object$fieldDescript;
    const message = createBaseInterfaceAcceptingMessageDescriptor();
    message.fullname = (_object$fullname4 = object.fullname) !== null && _object$fullname4 !== void 0 ? _object$fullname4 : "";
    message.fieldDescriptorNames = ((_object$fieldDescript = object.fieldDescriptorNames) === null || _object$fieldDescript === void 0 ? void 0 : _object$fieldDescript.map((e) => e)) || [];
    return message;
  }
};
function createBaseConfigurationDescriptor() {
  return {
    bech32AccountAddressPrefix: ""
  };
}
var ConfigurationDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.bech32AccountAddressPrefix !== "") {
      writer.uint32(10).string(message.bech32AccountAddressPrefix);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigurationDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bech32AccountAddressPrefix = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bech32AccountAddressPrefix: isSet(object.bech32AccountAddressPrefix) ? String(object.bech32AccountAddressPrefix) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.bech32AccountAddressPrefix !== void 0 && (obj.bech32AccountAddressPrefix = message.bech32AccountAddressPrefix);
    return obj;
  },
  fromPartial(object) {
    var _object$bech32Account;
    const message = createBaseConfigurationDescriptor();
    message.bech32AccountAddressPrefix = (_object$bech32Account = object.bech32AccountAddressPrefix) !== null && _object$bech32Account !== void 0 ? _object$bech32Account : "";
    return message;
  }
};
function createBaseMsgDescriptor() {
  return {
    msgTypeUrl: ""
  };
}
var MsgDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.msgTypeUrl !== "") {
      writer.uint32(10).string(message.msgTypeUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgTypeUrl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
    return obj;
  },
  fromPartial(object) {
    var _object$msgTypeUrl;
    const message = createBaseMsgDescriptor();
    message.msgTypeUrl = (_object$msgTypeUrl = object.msgTypeUrl) !== null && _object$msgTypeUrl !== void 0 ? _object$msgTypeUrl : "";
    return message;
  }
};
function createBaseGetAuthnDescriptorRequest() {
  return {};
}
var GetAuthnDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAuthnDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetAuthnDescriptorRequest();
    return message;
  }
};
function createBaseGetAuthnDescriptorResponse() {
  return {
    authn: void 0
  };
}
var GetAuthnDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.authn !== void 0) {
      AuthnDescriptor.encode(message.authn, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAuthnDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authn = AuthnDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authn: isSet(object.authn) ? AuthnDescriptor.fromJSON(object.authn) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.authn !== void 0 && (obj.authn = message.authn ? AuthnDescriptor.toJSON(message.authn) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAuthnDescriptorResponse();
    message.authn = object.authn !== void 0 && object.authn !== null ? AuthnDescriptor.fromPartial(object.authn) : void 0;
    return message;
  }
};
function createBaseGetChainDescriptorRequest() {
  return {};
}
var GetChainDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetChainDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetChainDescriptorRequest();
    return message;
  }
};
function createBaseGetChainDescriptorResponse() {
  return {
    chain: void 0
  };
}
var GetChainDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.chain !== void 0) {
      ChainDescriptor.encode(message.chain, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetChainDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chain = ChainDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      chain: isSet(object.chain) ? ChainDescriptor.fromJSON(object.chain) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.chain !== void 0 && (obj.chain = message.chain ? ChainDescriptor.toJSON(message.chain) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetChainDescriptorResponse();
    message.chain = object.chain !== void 0 && object.chain !== null ? ChainDescriptor.fromPartial(object.chain) : void 0;
    return message;
  }
};
function createBaseGetCodecDescriptorRequest() {
  return {};
}
var GetCodecDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCodecDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetCodecDescriptorRequest();
    return message;
  }
};
function createBaseGetCodecDescriptorResponse() {
  return {
    codec: void 0
  };
}
var GetCodecDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.codec !== void 0) {
      CodecDescriptor.encode(message.codec, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCodecDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = CodecDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codec: isSet(object.codec) ? CodecDescriptor.fromJSON(object.codec) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.codec !== void 0 && (obj.codec = message.codec ? CodecDescriptor.toJSON(message.codec) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetCodecDescriptorResponse();
    message.codec = object.codec !== void 0 && object.codec !== null ? CodecDescriptor.fromPartial(object.codec) : void 0;
    return message;
  }
};
function createBaseGetConfigurationDescriptorRequest() {
  return {};
}
var GetConfigurationDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetConfigurationDescriptorRequest();
    return message;
  }
};
function createBaseGetConfigurationDescriptorResponse() {
  return {
    config: void 0
  };
}
var GetConfigurationDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.config !== void 0) {
      ConfigurationDescriptor.encode(message.config, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.config = ConfigurationDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      config: isSet(object.config) ? ConfigurationDescriptor.fromJSON(object.config) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.config !== void 0 && (obj.config = message.config ? ConfigurationDescriptor.toJSON(message.config) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConfigurationDescriptorResponse();
    message.config = object.config !== void 0 && object.config !== null ? ConfigurationDescriptor.fromPartial(object.config) : void 0;
    return message;
  }
};
function createBaseGetQueryServicesDescriptorRequest() {
  return {};
}
var GetQueryServicesDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetQueryServicesDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetQueryServicesDescriptorRequest();
    return message;
  }
};
function createBaseGetQueryServicesDescriptorResponse() {
  return {
    queries: void 0
  };
}
var GetQueryServicesDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.queries !== void 0) {
      QueryServicesDescriptor.encode(message.queries, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetQueryServicesDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.queries = QueryServicesDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      queries: isSet(object.queries) ? QueryServicesDescriptor.fromJSON(object.queries) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.queries !== void 0 && (obj.queries = message.queries ? QueryServicesDescriptor.toJSON(message.queries) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetQueryServicesDescriptorResponse();
    message.queries = object.queries !== void 0 && object.queries !== null ? QueryServicesDescriptor.fromPartial(object.queries) : void 0;
    return message;
  }
};
function createBaseGetTxDescriptorRequest() {
  return {};
}
var GetTxDescriptorRequest = {
  encode(_, writer = _m014.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTxDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetTxDescriptorRequest();
    return message;
  }
};
function createBaseGetTxDescriptorResponse() {
  return {
    tx: void 0
  };
}
var GetTxDescriptorResponse = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.tx !== void 0) {
      TxDescriptor.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTxDescriptorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = TxDescriptor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      tx: isSet(object.tx) ? TxDescriptor.fromJSON(object.tx) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.tx !== void 0 && (obj.tx = message.tx ? TxDescriptor.toJSON(message.tx) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetTxDescriptorResponse();
    message.tx = object.tx !== void 0 && object.tx !== null ? TxDescriptor.fromPartial(object.tx) : void 0;
    return message;
  }
};
function createBaseQueryServicesDescriptor() {
  return {
    queryServices: []
  };
}
var QueryServicesDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    for (const v of message.queryServices) {
      QueryServiceDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueryServicesDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.queryServices.push(QueryServiceDescriptor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      queryServices: Array.isArray(object === null || object === void 0 ? void 0 : object.queryServices) ? object.queryServices.map((e) => QueryServiceDescriptor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queryServices) {
      obj.queryServices = message.queryServices.map((e) => e ? QueryServiceDescriptor.toJSON(e) : void 0);
    } else {
      obj.queryServices = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$queryServices;
    const message = createBaseQueryServicesDescriptor();
    message.queryServices = ((_object$queryServices = object.queryServices) === null || _object$queryServices === void 0 ? void 0 : _object$queryServices.map((e) => QueryServiceDescriptor.fromPartial(e))) || [];
    return message;
  }
};
function createBaseQueryServiceDescriptor() {
  return {
    fullname: "",
    isModule: false,
    methods: []
  };
}
var QueryServiceDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.fullname !== "") {
      writer.uint32(10).string(message.fullname);
    }
    if (message.isModule === true) {
      writer.uint32(16).bool(message.isModule);
    }
    for (const v of message.methods) {
      QueryMethodDescriptor.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;
        case 2:
          message.isModule = reader.bool();
          break;
        case 3:
          message.methods.push(QueryMethodDescriptor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullname: isSet(object.fullname) ? String(object.fullname) : "",
      isModule: isSet(object.isModule) ? Boolean(object.isModule) : false,
      methods: Array.isArray(object === null || object === void 0 ? void 0 : object.methods) ? object.methods.map((e) => QueryMethodDescriptor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    message.isModule !== void 0 && (obj.isModule = message.isModule);
    if (message.methods) {
      obj.methods = message.methods.map((e) => e ? QueryMethodDescriptor.toJSON(e) : void 0);
    } else {
      obj.methods = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$fullname5, _object$isModule, _object$methods;
    const message = createBaseQueryServiceDescriptor();
    message.fullname = (_object$fullname5 = object.fullname) !== null && _object$fullname5 !== void 0 ? _object$fullname5 : "";
    message.isModule = (_object$isModule = object.isModule) !== null && _object$isModule !== void 0 ? _object$isModule : false;
    message.methods = ((_object$methods = object.methods) === null || _object$methods === void 0 ? void 0 : _object$methods.map((e) => QueryMethodDescriptor.fromPartial(e))) || [];
    return message;
  }
};
function createBaseQueryMethodDescriptor() {
  return {
    name: "",
    fullQueryPath: ""
  };
}
var QueryMethodDescriptor = {
  encode(message, writer = _m014.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fullQueryPath !== "") {
      writer.uint32(18).string(message.fullQueryPath);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m014.Reader ? input : new _m014.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueryMethodDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.fullQueryPath = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      fullQueryPath: isSet(object.fullQueryPath) ? String(object.fullQueryPath) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.fullQueryPath !== void 0 && (obj.fullQueryPath = message.fullQueryPath);
    return obj;
  },
  fromPartial(object) {
    var _object$name2, _object$fullQueryPath;
    const message = createBaseQueryMethodDescriptor();
    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : "";
    message.fullQueryPath = (_object$fullQueryPath = object.fullQueryPath) !== null && _object$fullQueryPath !== void 0 ? _object$fullQueryPath : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/snapshots/v1beta1/snapshot.js
var snapshot_exports = {};
__export(snapshot_exports, {
  Metadata: () => Metadata2,
  Snapshot: () => Snapshot,
  SnapshotExtensionMeta: () => SnapshotExtensionMeta,
  SnapshotExtensionPayload: () => SnapshotExtensionPayload,
  SnapshotIAVLItem: () => SnapshotIAVLItem,
  SnapshotItem: () => SnapshotItem,
  SnapshotKVItem: () => SnapshotKVItem,
  SnapshotSchema: () => SnapshotSchema,
  SnapshotStoreItem: () => SnapshotStoreItem
});
var _m015 = __toESM(require_minimal());
function createBaseSnapshot() {
  return {
    height: BigInt("0"),
    format: 0,
    chunks: 0,
    hash: new Uint8Array(),
    metadata: void 0
  };
}
var Snapshot = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.height !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.height.toString()));
    }
    if (message.format !== 0) {
      writer.uint32(16).uint32(message.format);
    }
    if (message.chunks !== 0) {
      writer.uint32(24).uint32(message.chunks);
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    if (message.metadata !== void 0) {
      Metadata2.encode(message.metadata, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.format = reader.uint32();
          break;
        case 3:
          message.chunks = reader.uint32();
          break;
        case 4:
          message.hash = reader.bytes();
          break;
        case 5:
          message.metadata = Metadata2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet(object.height) ? BigInt(object.height.toString()) : BigInt("0"),
      format: isSet(object.format) ? Number(object.format) : 0,
      chunks: isSet(object.chunks) ? Number(object.chunks) : 0,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(),
      metadata: isSet(object.metadata) ? Metadata2.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = (message.height || BigInt("0")).toString());
    message.format !== void 0 && (obj.format = Math.round(message.format));
    message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
    message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.metadata !== void 0 && (obj.metadata = message.metadata ? Metadata2.toJSON(message.metadata) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$format, _object$chunks, _object$hash;
    const message = createBaseSnapshot();
    message.height = object.height !== void 0 && object.height !== null ? BigInt(object.height.toString()) : BigInt("0");
    message.format = (_object$format = object.format) !== null && _object$format !== void 0 ? _object$format : 0;
    message.chunks = (_object$chunks = object.chunks) !== null && _object$chunks !== void 0 ? _object$chunks : 0;
    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : new Uint8Array();
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? Metadata2.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseMetadata() {
  return {
    chunkHashes: []
  };
}
var Metadata2 = {
  encode(message, writer = _m015.Writer.create()) {
    for (const v of message.chunkHashes) {
      writer.uint32(10).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chunkHashes.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      chunkHashes: Array.isArray(object === null || object === void 0 ? void 0 : object.chunkHashes) ? object.chunkHashes.map((e) => bytesFromBase64(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.chunkHashes) {
      obj.chunkHashes = message.chunkHashes.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.chunkHashes = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$chunkHashes;
    const message = createBaseMetadata();
    message.chunkHashes = ((_object$chunkHashes = object.chunkHashes) === null || _object$chunkHashes === void 0 ? void 0 : _object$chunkHashes.map((e) => e)) || [];
    return message;
  }
};
function createBaseSnapshotItem() {
  return {
    store: void 0,
    iavl: void 0,
    extension: void 0,
    extensionPayload: void 0,
    kv: void 0,
    schema: void 0
  };
}
var SnapshotItem = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.store !== void 0) {
      SnapshotStoreItem.encode(message.store, writer.uint32(10).fork()).ldelim();
    }
    if (message.iavl !== void 0) {
      SnapshotIAVLItem.encode(message.iavl, writer.uint32(18).fork()).ldelim();
    }
    if (message.extension !== void 0) {
      SnapshotExtensionMeta.encode(message.extension, writer.uint32(26).fork()).ldelim();
    }
    if (message.extensionPayload !== void 0) {
      SnapshotExtensionPayload.encode(message.extensionPayload, writer.uint32(34).fork()).ldelim();
    }
    if (message.kv !== void 0) {
      SnapshotKVItem.encode(message.kv, writer.uint32(42).fork()).ldelim();
    }
    if (message.schema !== void 0) {
      SnapshotSchema.encode(message.schema, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.store = SnapshotStoreItem.decode(reader, reader.uint32());
          break;
        case 2:
          message.iavl = SnapshotIAVLItem.decode(reader, reader.uint32());
          break;
        case 3:
          message.extension = SnapshotExtensionMeta.decode(reader, reader.uint32());
          break;
        case 4:
          message.extensionPayload = SnapshotExtensionPayload.decode(reader, reader.uint32());
          break;
        case 5:
          message.kv = SnapshotKVItem.decode(reader, reader.uint32());
          break;
        case 6:
          message.schema = SnapshotSchema.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      store: isSet(object.store) ? SnapshotStoreItem.fromJSON(object.store) : void 0,
      iavl: isSet(object.iavl) ? SnapshotIAVLItem.fromJSON(object.iavl) : void 0,
      extension: isSet(object.extension) ? SnapshotExtensionMeta.fromJSON(object.extension) : void 0,
      extensionPayload: isSet(object.extensionPayload) ? SnapshotExtensionPayload.fromJSON(object.extensionPayload) : void 0,
      kv: isSet(object.kv) ? SnapshotKVItem.fromJSON(object.kv) : void 0,
      schema: isSet(object.schema) ? SnapshotSchema.fromJSON(object.schema) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.store !== void 0 && (obj.store = message.store ? SnapshotStoreItem.toJSON(message.store) : void 0);
    message.iavl !== void 0 && (obj.iavl = message.iavl ? SnapshotIAVLItem.toJSON(message.iavl) : void 0);
    message.extension !== void 0 && (obj.extension = message.extension ? SnapshotExtensionMeta.toJSON(message.extension) : void 0);
    message.extensionPayload !== void 0 && (obj.extensionPayload = message.extensionPayload ? SnapshotExtensionPayload.toJSON(message.extensionPayload) : void 0);
    message.kv !== void 0 && (obj.kv = message.kv ? SnapshotKVItem.toJSON(message.kv) : void 0);
    message.schema !== void 0 && (obj.schema = message.schema ? SnapshotSchema.toJSON(message.schema) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSnapshotItem();
    message.store = object.store !== void 0 && object.store !== null ? SnapshotStoreItem.fromPartial(object.store) : void 0;
    message.iavl = object.iavl !== void 0 && object.iavl !== null ? SnapshotIAVLItem.fromPartial(object.iavl) : void 0;
    message.extension = object.extension !== void 0 && object.extension !== null ? SnapshotExtensionMeta.fromPartial(object.extension) : void 0;
    message.extensionPayload = object.extensionPayload !== void 0 && object.extensionPayload !== null ? SnapshotExtensionPayload.fromPartial(object.extensionPayload) : void 0;
    message.kv = object.kv !== void 0 && object.kv !== null ? SnapshotKVItem.fromPartial(object.kv) : void 0;
    message.schema = object.schema !== void 0 && object.schema !== null ? SnapshotSchema.fromPartial(object.schema) : void 0;
    return message;
  }
};
function createBaseSnapshotStoreItem() {
  return {
    name: ""
  };
}
var SnapshotStoreItem = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotStoreItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$name;
    const message = createBaseSnapshotStoreItem();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    return message;
  }
};
function createBaseSnapshotIAVLItem() {
  return {
    key: new Uint8Array(),
    value: new Uint8Array(),
    version: BigInt("0"),
    height: 0
  };
}
var SnapshotIAVLItem = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.version !== BigInt(0)) {
      writer.uint32(24).int64(import_long.default.fromString(message.version.toString()));
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotIAVLItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        case 3:
          message.version = BigInt(reader.int64().toString());
          break;
        case 4:
          message.height = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
      version: isSet(object.version) ? BigInt(object.version.toString()) : BigInt("0"),
      height: isSet(object.height) ? Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    message.version !== void 0 && (obj.version = (message.version || BigInt("0")).toString());
    message.height !== void 0 && (obj.height = Math.round(message.height));
    return obj;
  },
  fromPartial(object) {
    var _object$key, _object$value, _object$height;
    const message = createBaseSnapshotIAVLItem();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();
    message.version = object.version !== void 0 && object.version !== null ? BigInt(object.version.toString()) : BigInt("0");
    message.height = (_object$height = object.height) !== null && _object$height !== void 0 ? _object$height : 0;
    return message;
  }
};
function createBaseSnapshotExtensionMeta() {
  return {
    name: "",
    format: 0
  };
}
var SnapshotExtensionMeta = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.format !== 0) {
      writer.uint32(16).uint32(message.format);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotExtensionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.format = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      format: isSet(object.format) ? Number(object.format) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.format !== void 0 && (obj.format = Math.round(message.format));
    return obj;
  },
  fromPartial(object) {
    var _object$name2, _object$format2;
    const message = createBaseSnapshotExtensionMeta();
    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : "";
    message.format = (_object$format2 = object.format) !== null && _object$format2 !== void 0 ? _object$format2 : 0;
    return message;
  }
};
function createBaseSnapshotExtensionPayload() {
  return {
    payload: new Uint8Array()
  };
}
var SnapshotExtensionPayload = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.payload.length !== 0) {
      writer.uint32(10).bytes(message.payload);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotExtensionPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.payload = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$payload;
    const message = createBaseSnapshotExtensionPayload();
    message.payload = (_object$payload = object.payload) !== null && _object$payload !== void 0 ? _object$payload : new Uint8Array();
    return message;
  }
};
function createBaseSnapshotKVItem() {
  return {
    key: new Uint8Array(),
    value: new Uint8Array()
  };
}
var SnapshotKVItem = {
  encode(message, writer = _m015.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotKVItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key2, _object$value2;
    const message = createBaseSnapshotKVItem();
    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();
    message.value = (_object$value2 = object.value) !== null && _object$value2 !== void 0 ? _object$value2 : new Uint8Array();
    return message;
  }
};
function createBaseSnapshotSchema() {
  return {
    keys: []
  };
}
var SnapshotSchema = {
  encode(message, writer = _m015.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m015.Reader ? input : new _m015.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapshotSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys) ? object.keys.map((e) => bytesFromBase64(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys) {
      obj.keys = message.keys.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.keys = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$keys;
    const message = createBaseSnapshotSchema();
    message.keys = ((_object$keys = object.keys) === null || _object$keys === void 0 ? void 0 : _object$keys.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/store/v1beta1/commit_info.js
var commit_info_exports = {};
__export(commit_info_exports, {
  CommitID: () => CommitID,
  CommitInfo: () => CommitInfo,
  StoreInfo: () => StoreInfo
});
var _m016 = __toESM(require_minimal());
function createBaseCommitInfo() {
  return {
    version: BigInt("0"),
    storeInfos: [],
    timestamp: void 0
  };
}
var CommitInfo = {
  encode(message, writer = _m016.Writer.create()) {
    if (message.version !== BigInt(0)) {
      writer.uint32(8).int64(import_long.default.fromString(message.version.toString()));
    }
    for (const v of message.storeInfos) {
      StoreInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m016.Reader ? input : new _m016.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = BigInt(reader.int64().toString());
          break;
        case 2:
          message.storeInfos.push(StoreInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet(object.version) ? BigInt(object.version.toString()) : BigInt("0"),
      storeInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.storeInfos) ? object.storeInfos.map((e) => StoreInfo.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = (message.version || BigInt("0")).toString());
    if (message.storeInfos) {
      obj.storeInfos = message.storeInfos.map((e) => e ? StoreInfo.toJSON(e) : void 0);
    } else {
      obj.storeInfos = [];
    }
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    return obj;
  },
  fromPartial(object) {
    var _object$storeInfos, _object$timestamp;
    const message = createBaseCommitInfo();
    message.version = object.version !== void 0 && object.version !== null ? BigInt(object.version.toString()) : BigInt("0");
    message.storeInfos = ((_object$storeInfos = object.storeInfos) === null || _object$storeInfos === void 0 ? void 0 : _object$storeInfos.map((e) => StoreInfo.fromPartial(e))) || [];
    message.timestamp = (_object$timestamp = object.timestamp) !== null && _object$timestamp !== void 0 ? _object$timestamp : void 0;
    return message;
  }
};
function createBaseStoreInfo() {
  return {
    name: "",
    commitId: void 0
  };
}
var StoreInfo = {
  encode(message, writer = _m016.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.commitId !== void 0) {
      CommitID.encode(message.commitId, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m016.Reader ? input : new _m016.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoreInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.commitId = CommitID.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      commitId: isSet(object.commitId) ? CommitID.fromJSON(object.commitId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.commitId !== void 0 && (obj.commitId = message.commitId ? CommitID.toJSON(message.commitId) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name;
    const message = createBaseStoreInfo();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.commitId = object.commitId !== void 0 && object.commitId !== null ? CommitID.fromPartial(object.commitId) : void 0;
    return message;
  }
};
function createBaseCommitID() {
  return {
    version: BigInt("0"),
    hash: new Uint8Array()
  };
}
var CommitID = {
  encode(message, writer = _m016.Writer.create()) {
    if (message.version !== BigInt(0)) {
      writer.uint32(8).int64(import_long.default.fromString(message.version.toString()));
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m016.Reader ? input : new _m016.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommitID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = BigInt(reader.int64().toString());
          break;
        case 2:
          message.hash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet(object.version) ? BigInt(object.version.toString()) : BigInt("0"),
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = (message.version || BigInt("0")).toString());
    message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$hash;
    const message = createBaseCommitID();
    message.version = object.version !== void 0 && object.version !== null ? BigInt(object.version.toString()) : BigInt("0");
    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/base/store/v1beta1/listening.js
var listening_exports = {};
__export(listening_exports, {
  BlockMetadata: () => BlockMetadata,
  BlockMetadata_DeliverTx: () => BlockMetadata_DeliverTx,
  StoreKVPair: () => StoreKVPair
});
var _m017 = __toESM(require_minimal());
function createBaseStoreKVPair() {
  return {
    storeKey: "",
    delete: false,
    key: new Uint8Array(),
    value: new Uint8Array()
  };
}
var StoreKVPair = {
  encode(message, writer = _m017.Writer.create()) {
    if (message.storeKey !== "") {
      writer.uint32(10).string(message.storeKey);
    }
    if (message.delete === true) {
      writer.uint32(16).bool(message.delete);
    }
    if (message.key.length !== 0) {
      writer.uint32(26).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m017.Reader ? input : new _m017.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoreKVPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.storeKey = reader.string();
          break;
        case 2:
          message.delete = reader.bool();
          break;
        case 3:
          message.key = reader.bytes();
          break;
        case 4:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      storeKey: isSet(object.storeKey) ? String(object.storeKey) : "",
      delete: isSet(object.delete) ? Boolean(object.delete) : false,
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.storeKey !== void 0 && (obj.storeKey = message.storeKey);
    message.delete !== void 0 && (obj.delete = message.delete);
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$storeKey, _object$delete, _object$key, _object$value;
    const message = createBaseStoreKVPair();
    message.storeKey = (_object$storeKey = object.storeKey) !== null && _object$storeKey !== void 0 ? _object$storeKey : "";
    message.delete = (_object$delete = object.delete) !== null && _object$delete !== void 0 ? _object$delete : false;
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();
    return message;
  }
};
function createBaseBlockMetadata() {
  return {
    requestBeginBlock: void 0,
    responseBeginBlock: void 0,
    deliverTxs: [],
    requestEndBlock: void 0,
    responseEndBlock: void 0,
    responseCommit: void 0
  };
}
var BlockMetadata = {
  encode(message, writer = _m017.Writer.create()) {
    if (message.requestBeginBlock !== void 0) {
      RequestBeginBlock.encode(message.requestBeginBlock, writer.uint32(10).fork()).ldelim();
    }
    if (message.responseBeginBlock !== void 0) {
      ResponseBeginBlock.encode(message.responseBeginBlock, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.deliverTxs) {
      BlockMetadata_DeliverTx.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.requestEndBlock !== void 0) {
      RequestEndBlock.encode(message.requestEndBlock, writer.uint32(34).fork()).ldelim();
    }
    if (message.responseEndBlock !== void 0) {
      ResponseEndBlock.encode(message.responseEndBlock, writer.uint32(42).fork()).ldelim();
    }
    if (message.responseCommit !== void 0) {
      ResponseCommit.encode(message.responseCommit, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m017.Reader ? input : new _m017.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.requestBeginBlock = RequestBeginBlock.decode(reader, reader.uint32());
          break;
        case 2:
          message.responseBeginBlock = ResponseBeginBlock.decode(reader, reader.uint32());
          break;
        case 3:
          message.deliverTxs.push(BlockMetadata_DeliverTx.decode(reader, reader.uint32()));
          break;
        case 4:
          message.requestEndBlock = RequestEndBlock.decode(reader, reader.uint32());
          break;
        case 5:
          message.responseEndBlock = ResponseEndBlock.decode(reader, reader.uint32());
          break;
        case 6:
          message.responseCommit = ResponseCommit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestBeginBlock: isSet(object.requestBeginBlock) ? RequestBeginBlock.fromJSON(object.requestBeginBlock) : void 0,
      responseBeginBlock: isSet(object.responseBeginBlock) ? ResponseBeginBlock.fromJSON(object.responseBeginBlock) : void 0,
      deliverTxs: Array.isArray(object === null || object === void 0 ? void 0 : object.deliverTxs) ? object.deliverTxs.map((e) => BlockMetadata_DeliverTx.fromJSON(e)) : [],
      requestEndBlock: isSet(object.requestEndBlock) ? RequestEndBlock.fromJSON(object.requestEndBlock) : void 0,
      responseEndBlock: isSet(object.responseEndBlock) ? ResponseEndBlock.fromJSON(object.responseEndBlock) : void 0,
      responseCommit: isSet(object.responseCommit) ? ResponseCommit.fromJSON(object.responseCommit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.requestBeginBlock !== void 0 && (obj.requestBeginBlock = message.requestBeginBlock ? RequestBeginBlock.toJSON(message.requestBeginBlock) : void 0);
    message.responseBeginBlock !== void 0 && (obj.responseBeginBlock = message.responseBeginBlock ? ResponseBeginBlock.toJSON(message.responseBeginBlock) : void 0);
    if (message.deliverTxs) {
      obj.deliverTxs = message.deliverTxs.map((e) => e ? BlockMetadata_DeliverTx.toJSON(e) : void 0);
    } else {
      obj.deliverTxs = [];
    }
    message.requestEndBlock !== void 0 && (obj.requestEndBlock = message.requestEndBlock ? RequestEndBlock.toJSON(message.requestEndBlock) : void 0);
    message.responseEndBlock !== void 0 && (obj.responseEndBlock = message.responseEndBlock ? ResponseEndBlock.toJSON(message.responseEndBlock) : void 0);
    message.responseCommit !== void 0 && (obj.responseCommit = message.responseCommit ? ResponseCommit.toJSON(message.responseCommit) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$deliverTxs;
    const message = createBaseBlockMetadata();
    message.requestBeginBlock = object.requestBeginBlock !== void 0 && object.requestBeginBlock !== null ? RequestBeginBlock.fromPartial(object.requestBeginBlock) : void 0;
    message.responseBeginBlock = object.responseBeginBlock !== void 0 && object.responseBeginBlock !== null ? ResponseBeginBlock.fromPartial(object.responseBeginBlock) : void 0;
    message.deliverTxs = ((_object$deliverTxs = object.deliverTxs) === null || _object$deliverTxs === void 0 ? void 0 : _object$deliverTxs.map((e) => BlockMetadata_DeliverTx.fromPartial(e))) || [];
    message.requestEndBlock = object.requestEndBlock !== void 0 && object.requestEndBlock !== null ? RequestEndBlock.fromPartial(object.requestEndBlock) : void 0;
    message.responseEndBlock = object.responseEndBlock !== void 0 && object.responseEndBlock !== null ? ResponseEndBlock.fromPartial(object.responseEndBlock) : void 0;
    message.responseCommit = object.responseCommit !== void 0 && object.responseCommit !== null ? ResponseCommit.fromPartial(object.responseCommit) : void 0;
    return message;
  }
};
function createBaseBlockMetadata_DeliverTx() {
  return {
    request: void 0,
    response: void 0
  };
}
var BlockMetadata_DeliverTx = {
  encode(message, writer = _m017.Writer.create()) {
    if (message.request !== void 0) {
      RequestDeliverTx.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.response !== void 0) {
      ResponseDeliverTx.encode(message.response, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m017.Reader ? input : new _m017.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockMetadata_DeliverTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.request = RequestDeliverTx.decode(reader, reader.uint32());
          break;
        case 2:
          message.response = ResponseDeliverTx.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      request: isSet(object.request) ? RequestDeliverTx.fromJSON(object.request) : void 0,
      response: isSet(object.response) ? ResponseDeliverTx.fromJSON(object.response) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.request !== void 0 && (obj.request = message.request ? RequestDeliverTx.toJSON(message.request) : void 0);
    message.response !== void 0 && (obj.response = message.response ? ResponseDeliverTx.toJSON(message.response) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockMetadata_DeliverTx();
    message.request = object.request !== void 0 && object.request !== null ? RequestDeliverTx.fromPartial(object.request) : void 0;
    message.response = object.response !== void 0 && object.response !== null ? ResponseDeliverTx.fromPartial(object.response) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/capability/module/v1/module.js
var module_exports6 = {};
__export(module_exports6, {
  Module: () => Module5
});
var _m018 = __toESM(require_minimal());
function createBaseModule5() {
  return {
    sealKeeper: false
  };
}
var Module5 = {
  encode(message, writer = _m018.Writer.create()) {
    if (message.sealKeeper === true) {
      writer.uint32(8).bool(message.sealKeeper);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m018.Reader ? input : new _m018.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule5();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sealKeeper = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sealKeeper: isSet(object.sealKeeper) ? Boolean(object.sealKeeper) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sealKeeper !== void 0 && (obj.sealKeeper = message.sealKeeper);
    return obj;
  },
  fromPartial(object) {
    var _object$sealKeeper;
    const message = createBaseModule5();
    message.sealKeeper = (_object$sealKeeper = object.sealKeeper) !== null && _object$sealKeeper !== void 0 ? _object$sealKeeper : false;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/capability/v1beta1/capability.js
var capability_exports = {};
__export(capability_exports, {
  Capability: () => Capability,
  CapabilityOwners: () => CapabilityOwners,
  Owner: () => Owner
});
var _m019 = __toESM(require_minimal());
function createBaseCapability() {
  return {
    index: BigInt("0")
  };
}
var Capability = {
  encode(message, writer = _m019.Writer.create()) {
    if (message.index !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.index.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m019.Reader ? input : new _m019.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      index: isSet(object.index) ? BigInt(object.index.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.index !== void 0 && (obj.index = (message.index || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCapability();
    message.index = object.index !== void 0 && object.index !== null ? BigInt(object.index.toString()) : BigInt("0");
    return message;
  }
};
function createBaseOwner() {
  return {
    module: "",
    name: ""
  };
}
var Owner = {
  encode(message, writer = _m019.Writer.create()) {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m019.Reader ? input : new _m019.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.module = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      module: isSet(object.module) ? String(object.module) : "",
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.module !== void 0 && (obj.module = message.module);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$module, _object$name;
    const message = createBaseOwner();
    message.module = (_object$module = object.module) !== null && _object$module !== void 0 ? _object$module : "";
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    return message;
  }
};
function createBaseCapabilityOwners() {
  return {
    owners: []
  };
}
var CapabilityOwners = {
  encode(message, writer = _m019.Writer.create()) {
    for (const v of message.owners) {
      Owner.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m019.Reader ? input : new _m019.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCapabilityOwners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.owners.push(Owner.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      owners: Array.isArray(object === null || object === void 0 ? void 0 : object.owners) ? object.owners.map((e) => Owner.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.owners) {
      obj.owners = message.owners.map((e) => e ? Owner.toJSON(e) : void 0);
    } else {
      obj.owners = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$owners;
    const message = createBaseCapabilityOwners();
    message.owners = ((_object$owners = object.owners) === null || _object$owners === void 0 ? void 0 : _object$owners.map((e) => Owner.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/capability/v1beta1/genesis.js
var genesis_exports5 = {};
__export(genesis_exports5, {
  GenesisOwners: () => GenesisOwners,
  GenesisState: () => GenesisState4
});
var _m020 = __toESM(require_minimal());
function createBaseGenesisOwners() {
  return {
    index: BigInt("0"),
    indexOwners: void 0
  };
}
var GenesisOwners = {
  encode(message, writer = _m020.Writer.create()) {
    if (message.index !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.index.toString()));
    }
    if (message.indexOwners !== void 0) {
      CapabilityOwners.encode(message.indexOwners, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m020.Reader ? input : new _m020.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisOwners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.indexOwners = CapabilityOwners.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      index: isSet(object.index) ? BigInt(object.index.toString()) : BigInt("0"),
      indexOwners: isSet(object.indexOwners) ? CapabilityOwners.fromJSON(object.indexOwners) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.index !== void 0 && (obj.index = (message.index || BigInt("0")).toString());
    message.indexOwners !== void 0 && (obj.indexOwners = message.indexOwners ? CapabilityOwners.toJSON(message.indexOwners) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenesisOwners();
    message.index = object.index !== void 0 && object.index !== null ? BigInt(object.index.toString()) : BigInt("0");
    message.indexOwners = object.indexOwners !== void 0 && object.indexOwners !== null ? CapabilityOwners.fromPartial(object.indexOwners) : void 0;
    return message;
  }
};
function createBaseGenesisState4() {
  return {
    index: BigInt("0"),
    owners: []
  };
}
var GenesisState4 = {
  encode(message, writer = _m020.Writer.create()) {
    if (message.index !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.index.toString()));
    }
    for (const v of message.owners) {
      GenesisOwners.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m020.Reader ? input : new _m020.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.owners.push(GenesisOwners.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      index: isSet(object.index) ? BigInt(object.index.toString()) : BigInt("0"),
      owners: Array.isArray(object === null || object === void 0 ? void 0 : object.owners) ? object.owners.map((e) => GenesisOwners.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.index !== void 0 && (obj.index = (message.index || BigInt("0")).toString());
    if (message.owners) {
      obj.owners = message.owners.map((e) => e ? GenesisOwners.toJSON(e) : void 0);
    } else {
      obj.owners = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$owners;
    const message = createBaseGenesisState4();
    message.index = object.index !== void 0 && object.index !== null ? BigInt(object.index.toString()) : BigInt("0");
    message.owners = ((_object$owners = object.owners) === null || _object$owners === void 0 ? void 0 : _object$owners.map((e) => GenesisOwners.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/consensus/module/v1/module.js
var module_exports7 = {};
__export(module_exports7, {
  Module: () => Module6
});
var _m021 = __toESM(require_minimal());
function createBaseModule6() {
  return {
    authority: ""
  };
}
var Module6 = {
  encode(message, writer = _m021.Writer.create()) {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m021.Reader ? input : new _m021.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule6();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$authority;
    const message = createBaseModule6();
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crisis/module/v1/module.js
var module_exports8 = {};
__export(module_exports8, {
  Module: () => Module7
});
var _m022 = __toESM(require_minimal());
function createBaseModule7() {
  return {
    feeCollectorName: "",
    authority: ""
  };
}
var Module7 = {
  encode(message, writer = _m022.Writer.create()) {
    if (message.feeCollectorName !== "") {
      writer.uint32(10).string(message.feeCollectorName);
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m022.Reader ? input : new _m022.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule7();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feeCollectorName = reader.string();
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      feeCollectorName: isSet(object.feeCollectorName) ? String(object.feeCollectorName) : "",
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.feeCollectorName !== void 0 && (obj.feeCollectorName = message.feeCollectorName);
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$feeCollectorN, _object$authority;
    const message = createBaseModule7();
    message.feeCollectorName = (_object$feeCollectorN = object.feeCollectorName) !== null && _object$feeCollectorN !== void 0 ? _object$feeCollectorN : "";
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crisis/v1beta1/genesis.js
var genesis_exports6 = {};
__export(genesis_exports6, {
  GenesisState: () => GenesisState5
});
var _m023 = __toESM(require_minimal());
function createBaseGenesisState5() {
  return {
    constantFee: void 0
  };
}
var GenesisState5 = {
  encode(message, writer = _m023.Writer.create()) {
    if (message.constantFee !== void 0) {
      Coin.encode(message.constantFee, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m023.Reader ? input : new _m023.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState5();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          message.constantFee = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      constantFee: isSet(object.constantFee) ? Coin.fromJSON(object.constantFee) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.constantFee !== void 0 && (obj.constantFee = message.constantFee ? Coin.toJSON(message.constantFee) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenesisState5();
    message.constantFee = object.constantFee !== void 0 && object.constantFee !== null ? Coin.fromPartial(object.constantFee) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/ed25519/keys.js
var keys_exports2 = {};
__export(keys_exports2, {
  PrivKey: () => PrivKey,
  PubKey: () => PubKey
});
var _m024 = __toESM(require_minimal());
function createBasePubKey() {
  return {
    key: new Uint8Array()
  };
}
var PubKey = {
  encode(message, writer = _m024.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m024.Reader ? input : new _m024.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key;
    const message = createBasePubKey();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    return message;
  }
};
function createBasePrivKey() {
  return {
    key: new Uint8Array()
  };
}
var PrivKey = {
  encode(message, writer = _m024.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m024.Reader ? input : new _m024.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePrivKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key2;
    const message = createBasePrivKey();
    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/hd/v1/hd.js
var hd_exports = {};
__export(hd_exports, {
  BIP44Params: () => BIP44Params
});
var _m025 = __toESM(require_minimal());
function createBaseBIP44Params() {
  return {
    purpose: 0,
    coinType: 0,
    account: 0,
    change: false,
    addressIndex: 0
  };
}
var BIP44Params = {
  encode(message, writer = _m025.Writer.create()) {
    if (message.purpose !== 0) {
      writer.uint32(8).uint32(message.purpose);
    }
    if (message.coinType !== 0) {
      writer.uint32(16).uint32(message.coinType);
    }
    if (message.account !== 0) {
      writer.uint32(24).uint32(message.account);
    }
    if (message.change === true) {
      writer.uint32(32).bool(message.change);
    }
    if (message.addressIndex !== 0) {
      writer.uint32(40).uint32(message.addressIndex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m025.Reader ? input : new _m025.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBIP44Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.purpose = reader.uint32();
          break;
        case 2:
          message.coinType = reader.uint32();
          break;
        case 3:
          message.account = reader.uint32();
          break;
        case 4:
          message.change = reader.bool();
          break;
        case 5:
          message.addressIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      purpose: isSet(object.purpose) ? Number(object.purpose) : 0,
      coinType: isSet(object.coinType) ? Number(object.coinType) : 0,
      account: isSet(object.account) ? Number(object.account) : 0,
      change: isSet(object.change) ? Boolean(object.change) : false,
      addressIndex: isSet(object.addressIndex) ? Number(object.addressIndex) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.purpose !== void 0 && (obj.purpose = Math.round(message.purpose));
    message.coinType !== void 0 && (obj.coinType = Math.round(message.coinType));
    message.account !== void 0 && (obj.account = Math.round(message.account));
    message.change !== void 0 && (obj.change = message.change);
    message.addressIndex !== void 0 && (obj.addressIndex = Math.round(message.addressIndex));
    return obj;
  },
  fromPartial(object) {
    var _object$purpose, _object$coinType, _object$account, _object$change, _object$addressIndex;
    const message = createBaseBIP44Params();
    message.purpose = (_object$purpose = object.purpose) !== null && _object$purpose !== void 0 ? _object$purpose : 0;
    message.coinType = (_object$coinType = object.coinType) !== null && _object$coinType !== void 0 ? _object$coinType : 0;
    message.account = (_object$account = object.account) !== null && _object$account !== void 0 ? _object$account : 0;
    message.change = (_object$change = object.change) !== null && _object$change !== void 0 ? _object$change : false;
    message.addressIndex = (_object$addressIndex = object.addressIndex) !== null && _object$addressIndex !== void 0 ? _object$addressIndex : 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/keyring/v1/record.js
var record_exports = {};
__export(record_exports, {
  Record: () => Record,
  Record_Ledger: () => Record_Ledger,
  Record_Local: () => Record_Local,
  Record_Multi: () => Record_Multi,
  Record_Offline: () => Record_Offline
});
var _m026 = __toESM(require_minimal());
function createBaseRecord() {
  return {
    name: "",
    pubKey: void 0,
    local: void 0,
    ledger: void 0,
    multi: void 0,
    offline: void 0
  };
}
var Record = {
  encode(message, writer = _m026.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pubKey !== void 0) {
      Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
    }
    if (message.local !== void 0) {
      Record_Local.encode(message.local, writer.uint32(26).fork()).ldelim();
    }
    if (message.ledger !== void 0) {
      Record_Ledger.encode(message.ledger, writer.uint32(34).fork()).ldelim();
    }
    if (message.multi !== void 0) {
      Record_Multi.encode(message.multi, writer.uint32(42).fork()).ldelim();
    }
    if (message.offline !== void 0) {
      Record_Offline.encode(message.offline, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m026.Reader ? input : new _m026.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.pubKey = Any.decode(reader, reader.uint32());
          break;
        case 3:
          message.local = Record_Local.decode(reader, reader.uint32());
          break;
        case 4:
          message.ledger = Record_Ledger.decode(reader, reader.uint32());
          break;
        case 5:
          message.multi = Record_Multi.decode(reader, reader.uint32());
          break;
        case 6:
          message.offline = Record_Offline.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      pubKey: isSet(object.pubKey) ? Any.fromJSON(object.pubKey) : void 0,
      local: isSet(object.local) ? Record_Local.fromJSON(object.local) : void 0,
      ledger: isSet(object.ledger) ? Record_Ledger.fromJSON(object.ledger) : void 0,
      multi: isSet(object.multi) ? Record_Multi.fromJSON(object.multi) : void 0,
      offline: isSet(object.offline) ? Record_Offline.fromJSON(object.offline) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? Any.toJSON(message.pubKey) : void 0);
    message.local !== void 0 && (obj.local = message.local ? Record_Local.toJSON(message.local) : void 0);
    message.ledger !== void 0 && (obj.ledger = message.ledger ? Record_Ledger.toJSON(message.ledger) : void 0);
    message.multi !== void 0 && (obj.multi = message.multi ? Record_Multi.toJSON(message.multi) : void 0);
    message.offline !== void 0 && (obj.offline = message.offline ? Record_Offline.toJSON(message.offline) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name;
    const message = createBaseRecord();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? Any.fromPartial(object.pubKey) : void 0;
    message.local = object.local !== void 0 && object.local !== null ? Record_Local.fromPartial(object.local) : void 0;
    message.ledger = object.ledger !== void 0 && object.ledger !== null ? Record_Ledger.fromPartial(object.ledger) : void 0;
    message.multi = object.multi !== void 0 && object.multi !== null ? Record_Multi.fromPartial(object.multi) : void 0;
    message.offline = object.offline !== void 0 && object.offline !== null ? Record_Offline.fromPartial(object.offline) : void 0;
    return message;
  }
};
function createBaseRecord_Local() {
  return {
    privKey: void 0
  };
}
var Record_Local = {
  encode(message, writer = _m026.Writer.create()) {
    if (message.privKey !== void 0) {
      Any.encode(message.privKey, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m026.Reader ? input : new _m026.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecord_Local();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.privKey = Any.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      privKey: isSet(object.privKey) ? Any.fromJSON(object.privKey) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.privKey !== void 0 && (obj.privKey = message.privKey ? Any.toJSON(message.privKey) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRecord_Local();
    message.privKey = object.privKey !== void 0 && object.privKey !== null ? Any.fromPartial(object.privKey) : void 0;
    return message;
  }
};
function createBaseRecord_Ledger() {
  return {
    path: void 0
  };
}
var Record_Ledger = {
  encode(message, writer = _m026.Writer.create()) {
    if (message.path !== void 0) {
      BIP44Params.encode(message.path, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m026.Reader ? input : new _m026.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecord_Ledger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = BIP44Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? BIP44Params.fromJSON(object.path) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = message.path ? BIP44Params.toJSON(message.path) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRecord_Ledger();
    message.path = object.path !== void 0 && object.path !== null ? BIP44Params.fromPartial(object.path) : void 0;
    return message;
  }
};
function createBaseRecord_Multi() {
  return {};
}
var Record_Multi = {
  encode(_, writer = _m026.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m026.Reader ? input : new _m026.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecord_Multi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseRecord_Multi();
    return message;
  }
};
function createBaseRecord_Offline() {
  return {};
}
var Record_Offline = {
  encode(_, writer = _m026.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m026.Reader ? input : new _m026.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecord_Offline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseRecord_Offline();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/multisig/keys.js
var keys_exports3 = {};
__export(keys_exports3, {
  LegacyAminoPubKey: () => LegacyAminoPubKey
});
var _m027 = __toESM(require_minimal());
function createBaseLegacyAminoPubKey() {
  return {
    threshold: 0,
    publicKeys: []
  };
}
var LegacyAminoPubKey = {
  encode(message, writer = _m027.Writer.create()) {
    if (message.threshold !== 0) {
      writer.uint32(8).uint32(message.threshold);
    }
    for (const v of message.publicKeys) {
      Any.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m027.Reader ? input : new _m027.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegacyAminoPubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.threshold = reader.uint32();
          break;
        case 2:
          message.publicKeys.push(Any.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
      publicKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.publicKeys) ? object.publicKeys.map((e) => Any.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
    if (message.publicKeys) {
      obj.publicKeys = message.publicKeys.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.publicKeys = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$threshold, _object$publicKeys;
    const message = createBaseLegacyAminoPubKey();
    message.threshold = (_object$threshold = object.threshold) !== null && _object$threshold !== void 0 ? _object$threshold : 0;
    message.publicKeys = ((_object$publicKeys = object.publicKeys) === null || _object$publicKeys === void 0 ? void 0 : _object$publicKeys.map((e) => Any.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/secp256k1/keys.js
var keys_exports4 = {};
__export(keys_exports4, {
  PrivKey: () => PrivKey2,
  PubKey: () => PubKey2
});
var _m028 = __toESM(require_minimal());
function createBasePubKey2() {
  return {
    key: new Uint8Array()
  };
}
var PubKey2 = {
  encode(message, writer = _m028.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m028.Reader ? input : new _m028.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePubKey2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key;
    const message = createBasePubKey2();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    return message;
  }
};
function createBasePrivKey2() {
  return {
    key: new Uint8Array()
  };
}
var PrivKey2 = {
  encode(message, writer = _m028.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m028.Reader ? input : new _m028.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePrivKey2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key2;
    const message = createBasePrivKey2();
    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crypto/secp256r1/keys.js
var keys_exports5 = {};
__export(keys_exports5, {
  PrivKey: () => PrivKey3,
  PubKey: () => PubKey3
});
var _m029 = __toESM(require_minimal());
function createBasePubKey3() {
  return {
    key: new Uint8Array()
  };
}
var PubKey3 = {
  encode(message, writer = _m029.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m029.Reader ? input : new _m029.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePubKey3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key;
    const message = createBasePubKey3();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    return message;
  }
};
function createBasePrivKey3() {
  return {
    secret: new Uint8Array()
  };
}
var PrivKey3 = {
  encode(message, writer = _m029.Writer.create()) {
    if (message.secret.length !== 0) {
      writer.uint32(10).bytes(message.secret);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m029.Reader ? input : new _m029.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePrivKey3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.secret = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.secret !== void 0 && (obj.secret = base64FromBytes(message.secret !== void 0 ? message.secret : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$secret;
    const message = createBasePrivKey3();
    message.secret = (_object$secret = object.secret) !== null && _object$secret !== void 0 ? _object$secret : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/distribution/module/v1/module.js
var module_exports9 = {};
__export(module_exports9, {
  Module: () => Module8
});
var _m030 = __toESM(require_minimal());
function createBaseModule8() {
  return {
    feeCollectorName: "",
    authority: ""
  };
}
var Module8 = {
  encode(message, writer = _m030.Writer.create()) {
    if (message.feeCollectorName !== "") {
      writer.uint32(10).string(message.feeCollectorName);
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m030.Reader ? input : new _m030.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule8();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feeCollectorName = reader.string();
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      feeCollectorName: isSet(object.feeCollectorName) ? String(object.feeCollectorName) : "",
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.feeCollectorName !== void 0 && (obj.feeCollectorName = message.feeCollectorName);
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$feeCollectorN, _object$authority;
    const message = createBaseModule8();
    message.feeCollectorName = (_object$feeCollectorN = object.feeCollectorName) !== null && _object$feeCollectorN !== void 0 ? _object$feeCollectorN : "";
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/distribution/v1beta1/genesis.js
var genesis_exports7 = {};
__export(genesis_exports7, {
  DelegatorStartingInfoRecord: () => DelegatorStartingInfoRecord,
  DelegatorWithdrawInfo: () => DelegatorWithdrawInfo,
  GenesisState: () => GenesisState6,
  ValidatorAccumulatedCommissionRecord: () => ValidatorAccumulatedCommissionRecord,
  ValidatorCurrentRewardsRecord: () => ValidatorCurrentRewardsRecord,
  ValidatorHistoricalRewardsRecord: () => ValidatorHistoricalRewardsRecord,
  ValidatorOutstandingRewardsRecord: () => ValidatorOutstandingRewardsRecord,
  ValidatorSlashEventRecord: () => ValidatorSlashEventRecord
});
var _m031 = __toESM(require_minimal());
function createBaseDelegatorWithdrawInfo() {
  return {
    delegatorAddress: "",
    withdrawAddress: ""
  };
}
var DelegatorWithdrawInfo = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.withdrawAddress !== "") {
      writer.uint32(18).string(message.withdrawAddress);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDelegatorWithdrawInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;
        case 2:
          message.withdrawAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
      withdrawAddress: isSet(object.withdrawAddress) ? String(object.withdrawAddress) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
    message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
    return obj;
  },
  fromPartial(object) {
    var _object$delegatorAddr, _object$withdrawAddre;
    const message = createBaseDelegatorWithdrawInfo();
    message.delegatorAddress = (_object$delegatorAddr = object.delegatorAddress) !== null && _object$delegatorAddr !== void 0 ? _object$delegatorAddr : "";
    message.withdrawAddress = (_object$withdrawAddre = object.withdrawAddress) !== null && _object$withdrawAddre !== void 0 ? _object$withdrawAddre : "";
    return message;
  }
};
function createBaseValidatorOutstandingRewardsRecord() {
  return {
    validatorAddress: "",
    outstandingRewards: []
  };
}
var ValidatorOutstandingRewardsRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    for (const v of message.outstandingRewards) {
      DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorOutstandingRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorAddress = reader.string();
          break;
        case 2:
          message.outstandingRewards.push(DecCoin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      outstandingRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.outstandingRewards) ? object.outstandingRewards.map((e) => DecCoin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    if (message.outstandingRewards) {
      obj.outstandingRewards = message.outstandingRewards.map((e) => e ? DecCoin.toJSON(e) : void 0);
    } else {
      obj.outstandingRewards = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$validatorAddr, _object$outstandingRe;
    const message = createBaseValidatorOutstandingRewardsRecord();
    message.validatorAddress = (_object$validatorAddr = object.validatorAddress) !== null && _object$validatorAddr !== void 0 ? _object$validatorAddr : "";
    message.outstandingRewards = ((_object$outstandingRe = object.outstandingRewards) === null || _object$outstandingRe === void 0 ? void 0 : _object$outstandingRe.map((e) => DecCoin.fromPartial(e))) || [];
    return message;
  }
};
function createBaseValidatorAccumulatedCommissionRecord() {
  return {
    validatorAddress: "",
    accumulated: void 0
  };
}
var ValidatorAccumulatedCommissionRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.accumulated !== void 0) {
      ValidatorAccumulatedCommission.encode(message.accumulated, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorAccumulatedCommissionRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorAddress = reader.string();
          break;
        case 2:
          message.accumulated = ValidatorAccumulatedCommission.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      accumulated: isSet(object.accumulated) ? ValidatorAccumulatedCommission.fromJSON(object.accumulated) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    message.accumulated !== void 0 && (obj.accumulated = message.accumulated ? ValidatorAccumulatedCommission.toJSON(message.accumulated) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$validatorAddr2;
    const message = createBaseValidatorAccumulatedCommissionRecord();
    message.validatorAddress = (_object$validatorAddr2 = object.validatorAddress) !== null && _object$validatorAddr2 !== void 0 ? _object$validatorAddr2 : "";
    message.accumulated = object.accumulated !== void 0 && object.accumulated !== null ? ValidatorAccumulatedCommission.fromPartial(object.accumulated) : void 0;
    return message;
  }
};
function createBaseValidatorHistoricalRewardsRecord() {
  return {
    validatorAddress: "",
    period: BigInt("0"),
    rewards: void 0
  };
}
var ValidatorHistoricalRewardsRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.period !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.period.toString()));
    }
    if (message.rewards !== void 0) {
      ValidatorHistoricalRewards.encode(message.rewards, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorHistoricalRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorAddress = reader.string();
          break;
        case 2:
          message.period = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.rewards = ValidatorHistoricalRewards.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      period: isSet(object.period) ? BigInt(object.period.toString()) : BigInt("0"),
      rewards: isSet(object.rewards) ? ValidatorHistoricalRewards.fromJSON(object.rewards) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    message.period !== void 0 && (obj.period = (message.period || BigInt("0")).toString());
    message.rewards !== void 0 && (obj.rewards = message.rewards ? ValidatorHistoricalRewards.toJSON(message.rewards) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$validatorAddr3;
    const message = createBaseValidatorHistoricalRewardsRecord();
    message.validatorAddress = (_object$validatorAddr3 = object.validatorAddress) !== null && _object$validatorAddr3 !== void 0 ? _object$validatorAddr3 : "";
    message.period = object.period !== void 0 && object.period !== null ? BigInt(object.period.toString()) : BigInt("0");
    message.rewards = object.rewards !== void 0 && object.rewards !== null ? ValidatorHistoricalRewards.fromPartial(object.rewards) : void 0;
    return message;
  }
};
function createBaseValidatorCurrentRewardsRecord() {
  return {
    validatorAddress: "",
    rewards: void 0
  };
}
var ValidatorCurrentRewardsRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.rewards !== void 0) {
      ValidatorCurrentRewards.encode(message.rewards, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorCurrentRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorAddress = reader.string();
          break;
        case 2:
          message.rewards = ValidatorCurrentRewards.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      rewards: isSet(object.rewards) ? ValidatorCurrentRewards.fromJSON(object.rewards) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    message.rewards !== void 0 && (obj.rewards = message.rewards ? ValidatorCurrentRewards.toJSON(message.rewards) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$validatorAddr4;
    const message = createBaseValidatorCurrentRewardsRecord();
    message.validatorAddress = (_object$validatorAddr4 = object.validatorAddress) !== null && _object$validatorAddr4 !== void 0 ? _object$validatorAddr4 : "";
    message.rewards = object.rewards !== void 0 && object.rewards !== null ? ValidatorCurrentRewards.fromPartial(object.rewards) : void 0;
    return message;
  }
};
function createBaseDelegatorStartingInfoRecord() {
  return {
    delegatorAddress: "",
    validatorAddress: "",
    startingInfo: void 0
  };
}
var DelegatorStartingInfoRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.startingInfo !== void 0) {
      DelegatorStartingInfo.encode(message.startingInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDelegatorStartingInfoRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;
        case 2:
          message.validatorAddress = reader.string();
          break;
        case 3:
          message.startingInfo = DelegatorStartingInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      startingInfo: isSet(object.startingInfo) ? DelegatorStartingInfo.fromJSON(object.startingInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    message.startingInfo !== void 0 && (obj.startingInfo = message.startingInfo ? DelegatorStartingInfo.toJSON(message.startingInfo) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$delegatorAddr2, _object$validatorAddr5;
    const message = createBaseDelegatorStartingInfoRecord();
    message.delegatorAddress = (_object$delegatorAddr2 = object.delegatorAddress) !== null && _object$delegatorAddr2 !== void 0 ? _object$delegatorAddr2 : "";
    message.validatorAddress = (_object$validatorAddr5 = object.validatorAddress) !== null && _object$validatorAddr5 !== void 0 ? _object$validatorAddr5 : "";
    message.startingInfo = object.startingInfo !== void 0 && object.startingInfo !== null ? DelegatorStartingInfo.fromPartial(object.startingInfo) : void 0;
    return message;
  }
};
function createBaseValidatorSlashEventRecord() {
  return {
    validatorAddress: "",
    height: BigInt("0"),
    period: BigInt("0"),
    validatorSlashEvent: void 0
  };
}
var ValidatorSlashEventRecord = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.height !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.height.toString()));
    }
    if (message.period !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.period.toString()));
    }
    if (message.validatorSlashEvent !== void 0) {
      ValidatorSlashEvent.encode(message.validatorSlashEvent, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorSlashEventRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorAddress = reader.string();
          break;
        case 2:
          message.height = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.period = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.validatorSlashEvent = ValidatorSlashEvent.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
      height: isSet(object.height) ? BigInt(object.height.toString()) : BigInt("0"),
      period: isSet(object.period) ? BigInt(object.period.toString()) : BigInt("0"),
      validatorSlashEvent: isSet(object.validatorSlashEvent) ? ValidatorSlashEvent.fromJSON(object.validatorSlashEvent) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
    message.height !== void 0 && (obj.height = (message.height || BigInt("0")).toString());
    message.period !== void 0 && (obj.period = (message.period || BigInt("0")).toString());
    message.validatorSlashEvent !== void 0 && (obj.validatorSlashEvent = message.validatorSlashEvent ? ValidatorSlashEvent.toJSON(message.validatorSlashEvent) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$validatorAddr6;
    const message = createBaseValidatorSlashEventRecord();
    message.validatorAddress = (_object$validatorAddr6 = object.validatorAddress) !== null && _object$validatorAddr6 !== void 0 ? _object$validatorAddr6 : "";
    message.height = object.height !== void 0 && object.height !== null ? BigInt(object.height.toString()) : BigInt("0");
    message.period = object.period !== void 0 && object.period !== null ? BigInt(object.period.toString()) : BigInt("0");
    message.validatorSlashEvent = object.validatorSlashEvent !== void 0 && object.validatorSlashEvent !== null ? ValidatorSlashEvent.fromPartial(object.validatorSlashEvent) : void 0;
    return message;
  }
};
function createBaseGenesisState6() {
  return {
    params: void 0,
    feePool: void 0,
    delegatorWithdrawInfos: [],
    previousProposer: "",
    outstandingRewards: [],
    validatorAccumulatedCommissions: [],
    validatorHistoricalRewards: [],
    validatorCurrentRewards: [],
    delegatorStartingInfos: [],
    validatorSlashEvents: []
  };
}
var GenesisState6 = {
  encode(message, writer = _m031.Writer.create()) {
    if (message.params !== void 0) {
      Params3.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    if (message.feePool !== void 0) {
      FeePool.encode(message.feePool, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.delegatorWithdrawInfos) {
      DelegatorWithdrawInfo.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.previousProposer !== "") {
      writer.uint32(34).string(message.previousProposer);
    }
    for (const v of message.outstandingRewards) {
      ValidatorOutstandingRewardsRecord.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.validatorAccumulatedCommissions) {
      ValidatorAccumulatedCommissionRecord.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.validatorHistoricalRewards) {
      ValidatorHistoricalRewardsRecord.encode(v, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.validatorCurrentRewards) {
      ValidatorCurrentRewardsRecord.encode(v, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.delegatorStartingInfos) {
      DelegatorStartingInfoRecord.encode(v, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.validatorSlashEvents) {
      ValidatorSlashEventRecord.encode(v, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m031.Reader ? input : new _m031.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState6();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params3.decode(reader, reader.uint32());
          break;
        case 2:
          message.feePool = FeePool.decode(reader, reader.uint32());
          break;
        case 3:
          message.delegatorWithdrawInfos.push(DelegatorWithdrawInfo.decode(reader, reader.uint32()));
          break;
        case 4:
          message.previousProposer = reader.string();
          break;
        case 5:
          message.outstandingRewards.push(ValidatorOutstandingRewardsRecord.decode(reader, reader.uint32()));
          break;
        case 6:
          message.validatorAccumulatedCommissions.push(ValidatorAccumulatedCommissionRecord.decode(reader, reader.uint32()));
          break;
        case 7:
          message.validatorHistoricalRewards.push(ValidatorHistoricalRewardsRecord.decode(reader, reader.uint32()));
          break;
        case 8:
          message.validatorCurrentRewards.push(ValidatorCurrentRewardsRecord.decode(reader, reader.uint32()));
          break;
        case 9:
          message.delegatorStartingInfos.push(DelegatorStartingInfoRecord.decode(reader, reader.uint32()));
          break;
        case 10:
          message.validatorSlashEvents.push(ValidatorSlashEventRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params3.fromJSON(object.params) : void 0,
      feePool: isSet(object.feePool) ? FeePool.fromJSON(object.feePool) : void 0,
      delegatorWithdrawInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.delegatorWithdrawInfos) ? object.delegatorWithdrawInfos.map((e) => DelegatorWithdrawInfo.fromJSON(e)) : [],
      previousProposer: isSet(object.previousProposer) ? String(object.previousProposer) : "",
      outstandingRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.outstandingRewards) ? object.outstandingRewards.map((e) => ValidatorOutstandingRewardsRecord.fromJSON(e)) : [],
      validatorAccumulatedCommissions: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorAccumulatedCommissions) ? object.validatorAccumulatedCommissions.map((e) => ValidatorAccumulatedCommissionRecord.fromJSON(e)) : [],
      validatorHistoricalRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorHistoricalRewards) ? object.validatorHistoricalRewards.map((e) => ValidatorHistoricalRewardsRecord.fromJSON(e)) : [],
      validatorCurrentRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorCurrentRewards) ? object.validatorCurrentRewards.map((e) => ValidatorCurrentRewardsRecord.fromJSON(e)) : [],
      delegatorStartingInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.delegatorStartingInfos) ? object.delegatorStartingInfos.map((e) => DelegatorStartingInfoRecord.fromJSON(e)) : [],
      validatorSlashEvents: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorSlashEvents) ? object.validatorSlashEvents.map((e) => ValidatorSlashEventRecord.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params3.toJSON(message.params) : void 0);
    message.feePool !== void 0 && (obj.feePool = message.feePool ? FeePool.toJSON(message.feePool) : void 0);
    if (message.delegatorWithdrawInfos) {
      obj.delegatorWithdrawInfos = message.delegatorWithdrawInfos.map((e) => e ? DelegatorWithdrawInfo.toJSON(e) : void 0);
    } else {
      obj.delegatorWithdrawInfos = [];
    }
    message.previousProposer !== void 0 && (obj.previousProposer = message.previousProposer);
    if (message.outstandingRewards) {
      obj.outstandingRewards = message.outstandingRewards.map((e) => e ? ValidatorOutstandingRewardsRecord.toJSON(e) : void 0);
    } else {
      obj.outstandingRewards = [];
    }
    if (message.validatorAccumulatedCommissions) {
      obj.validatorAccumulatedCommissions = message.validatorAccumulatedCommissions.map((e) => e ? ValidatorAccumulatedCommissionRecord.toJSON(e) : void 0);
    } else {
      obj.validatorAccumulatedCommissions = [];
    }
    if (message.validatorHistoricalRewards) {
      obj.validatorHistoricalRewards = message.validatorHistoricalRewards.map((e) => e ? ValidatorHistoricalRewardsRecord.toJSON(e) : void 0);
    } else {
      obj.validatorHistoricalRewards = [];
    }
    if (message.validatorCurrentRewards) {
      obj.validatorCurrentRewards = message.validatorCurrentRewards.map((e) => e ? ValidatorCurrentRewardsRecord.toJSON(e) : void 0);
    } else {
      obj.validatorCurrentRewards = [];
    }
    if (message.delegatorStartingInfos) {
      obj.delegatorStartingInfos = message.delegatorStartingInfos.map((e) => e ? DelegatorStartingInfoRecord.toJSON(e) : void 0);
    } else {
      obj.delegatorStartingInfos = [];
    }
    if (message.validatorSlashEvents) {
      obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? ValidatorSlashEventRecord.toJSON(e) : void 0);
    } else {
      obj.validatorSlashEvents = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$delegatorWith, _object$previousPropo, _object$outstandingRe2, _object$validatorAccu, _object$validatorHist, _object$validatorCurr, _object$delegatorStar, _object$validatorSlas;
    const message = createBaseGenesisState6();
    message.params = object.params !== void 0 && object.params !== null ? Params3.fromPartial(object.params) : void 0;
    message.feePool = object.feePool !== void 0 && object.feePool !== null ? FeePool.fromPartial(object.feePool) : void 0;
    message.delegatorWithdrawInfos = ((_object$delegatorWith = object.delegatorWithdrawInfos) === null || _object$delegatorWith === void 0 ? void 0 : _object$delegatorWith.map((e) => DelegatorWithdrawInfo.fromPartial(e))) || [];
    message.previousProposer = (_object$previousPropo = object.previousProposer) !== null && _object$previousPropo !== void 0 ? _object$previousPropo : "";
    message.outstandingRewards = ((_object$outstandingRe2 = object.outstandingRewards) === null || _object$outstandingRe2 === void 0 ? void 0 : _object$outstandingRe2.map((e) => ValidatorOutstandingRewardsRecord.fromPartial(e))) || [];
    message.validatorAccumulatedCommissions = ((_object$validatorAccu = object.validatorAccumulatedCommissions) === null || _object$validatorAccu === void 0 ? void 0 : _object$validatorAccu.map((e) => ValidatorAccumulatedCommissionRecord.fromPartial(e))) || [];
    message.validatorHistoricalRewards = ((_object$validatorHist = object.validatorHistoricalRewards) === null || _object$validatorHist === void 0 ? void 0 : _object$validatorHist.map((e) => ValidatorHistoricalRewardsRecord.fromPartial(e))) || [];
    message.validatorCurrentRewards = ((_object$validatorCurr = object.validatorCurrentRewards) === null || _object$validatorCurr === void 0 ? void 0 : _object$validatorCurr.map((e) => ValidatorCurrentRewardsRecord.fromPartial(e))) || [];
    message.delegatorStartingInfos = ((_object$delegatorStar = object.delegatorStartingInfos) === null || _object$delegatorStar === void 0 ? void 0 : _object$delegatorStar.map((e) => DelegatorStartingInfoRecord.fromPartial(e))) || [];
    message.validatorSlashEvents = ((_object$validatorSlas = object.validatorSlashEvents) === null || _object$validatorSlas === void 0 ? void 0 : _object$validatorSlas.map((e) => ValidatorSlashEventRecord.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/evidence/module/v1/module.js
var module_exports10 = {};
__export(module_exports10, {
  Module: () => Module9
});
var _m032 = __toESM(require_minimal());
function createBaseModule9() {
  return {};
}
var Module9 = {
  encode(_, writer = _m032.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m032.Reader ? input : new _m032.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule9();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule9();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/evidence/v1beta1/evidence.js
var evidence_exports2 = {};
__export(evidence_exports2, {
  Equivocation: () => Equivocation
});
var _m033 = __toESM(require_minimal());
function createBaseEquivocation() {
  return {
    height: BigInt("0"),
    time: void 0,
    power: BigInt("0"),
    consensusAddress: ""
  };
}
var Equivocation = {
  encode(message, writer = _m033.Writer.create()) {
    if (message.height !== BigInt(0)) {
      writer.uint32(8).int64(import_long.default.fromString(message.height.toString()));
    }
    if (message.time !== void 0) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();
    }
    if (message.power !== BigInt(0)) {
      writer.uint32(24).int64(import_long.default.fromString(message.power.toString()));
    }
    if (message.consensusAddress !== "") {
      writer.uint32(34).string(message.consensusAddress);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m033.Reader ? input : new _m033.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEquivocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = BigInt(reader.int64().toString());
          break;
        case 2:
          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.power = BigInt(reader.int64().toString());
          break;
        case 4:
          message.consensusAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet(object.height) ? BigInt(object.height.toString()) : BigInt("0"),
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : void 0,
      power: isSet(object.power) ? BigInt(object.power.toString()) : BigInt("0"),
      consensusAddress: isSet(object.consensusAddress) ? String(object.consensusAddress) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = (message.height || BigInt("0")).toString());
    message.time !== void 0 && (obj.time = message.time.toISOString());
    message.power !== void 0 && (obj.power = (message.power || BigInt("0")).toString());
    message.consensusAddress !== void 0 && (obj.consensusAddress = message.consensusAddress);
    return obj;
  },
  fromPartial(object) {
    var _object$time, _object$consensusAddr;
    const message = createBaseEquivocation();
    message.height = object.height !== void 0 && object.height !== null ? BigInt(object.height.toString()) : BigInt("0");
    message.time = (_object$time = object.time) !== null && _object$time !== void 0 ? _object$time : void 0;
    message.power = object.power !== void 0 && object.power !== null ? BigInt(object.power.toString()) : BigInt("0");
    message.consensusAddress = (_object$consensusAddr = object.consensusAddress) !== null && _object$consensusAddr !== void 0 ? _object$consensusAddr : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/evidence/v1beta1/genesis.js
var genesis_exports8 = {};
__export(genesis_exports8, {
  GenesisState: () => GenesisState7
});
var _m034 = __toESM(require_minimal());
function createBaseGenesisState7() {
  return {
    evidence: []
  };
}
var GenesisState7 = {
  encode(message, writer = _m034.Writer.create()) {
    for (const v of message.evidence) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m034.Reader ? input : new _m034.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState7();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.evidence.push(Any.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      evidence: Array.isArray(object === null || object === void 0 ? void 0 : object.evidence) ? object.evidence.map((e) => Any.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.evidence) {
      obj.evidence = message.evidence.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.evidence = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$evidence;
    const message = createBaseGenesisState7();
    message.evidence = ((_object$evidence = object.evidence) === null || _object$evidence === void 0 ? void 0 : _object$evidence.map((e) => Any.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/feegrant/module/v1/module.js
var module_exports11 = {};
__export(module_exports11, {
  Module: () => Module10
});
var _m035 = __toESM(require_minimal());
function createBaseModule10() {
  return {};
}
var Module10 = {
  encode(_, writer = _m035.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m035.Reader ? input : new _m035.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule10();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule10();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/feegrant/v1beta1/genesis.js
var genesis_exports9 = {};
__export(genesis_exports9, {
  GenesisState: () => GenesisState8
});
var _m036 = __toESM(require_minimal());
function createBaseGenesisState8() {
  return {
    allowances: []
  };
}
var GenesisState8 = {
  encode(message, writer = _m036.Writer.create()) {
    for (const v of message.allowances) {
      Grant.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m036.Reader ? input : new _m036.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState8();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allowances.push(Grant.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowances: Array.isArray(object === null || object === void 0 ? void 0 : object.allowances) ? object.allowances.map((e) => Grant.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowances) {
      obj.allowances = message.allowances.map((e) => e ? Grant.toJSON(e) : void 0);
    } else {
      obj.allowances = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$allowances;
    const message = createBaseGenesisState8();
    message.allowances = ((_object$allowances = object.allowances) === null || _object$allowances === void 0 ? void 0 : _object$allowances.map((e) => Grant.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/genutil/module/v1/module.js
var module_exports12 = {};
__export(module_exports12, {
  Module: () => Module11
});
var _m037 = __toESM(require_minimal());
function createBaseModule11() {
  return {};
}
var Module11 = {
  encode(_, writer = _m037.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m037.Reader ? input : new _m037.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule11();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule11();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/genutil/v1beta1/genesis.js
var genesis_exports10 = {};
__export(genesis_exports10, {
  GenesisState: () => GenesisState9
});
var _m038 = __toESM(require_minimal());
function createBaseGenesisState9() {
  return {
    genTxs: []
  };
}
var GenesisState9 = {
  encode(message, writer = _m038.Writer.create()) {
    for (const v of message.genTxs) {
      writer.uint32(10).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m038.Reader ? input : new _m038.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState9();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.genTxs.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      genTxs: Array.isArray(object === null || object === void 0 ? void 0 : object.genTxs) ? object.genTxs.map((e) => bytesFromBase64(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.genTxs) {
      obj.genTxs = message.genTxs.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.genTxs = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$genTxs;
    const message = createBaseGenesisState9();
    message.genTxs = ((_object$genTxs = object.genTxs) === null || _object$genTxs === void 0 ? void 0 : _object$genTxs.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/module/v1/module.js
var module_exports13 = {};
__export(module_exports13, {
  Module: () => Module12
});
var _m039 = __toESM(require_minimal());
function createBaseModule12() {
  return {
    maxMetadataLen: BigInt("0"),
    authority: ""
  };
}
var Module12 = {
  encode(message, writer = _m039.Writer.create()) {
    if (message.maxMetadataLen !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.maxMetadataLen.toString()));
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m039.Reader ? input : new _m039.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule12();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxMetadataLen = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxMetadataLen: isSet(object.maxMetadataLen) ? BigInt(object.maxMetadataLen.toString()) : BigInt("0"),
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.maxMetadataLen !== void 0 && (obj.maxMetadataLen = (message.maxMetadataLen || BigInt("0")).toString());
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$authority;
    const message = createBaseModule12();
    message.maxMetadataLen = object.maxMetadataLen !== void 0 && object.maxMetadataLen !== null ? BigInt(object.maxMetadataLen.toString()) : BigInt("0");
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1/genesis.js
var genesis_exports11 = {};
__export(genesis_exports11, {
  GenesisState: () => GenesisState10
});
var _m040 = __toESM(require_minimal());
function createBaseGenesisState10() {
  return {
    startingProposalId: BigInt("0"),
    deposits: [],
    votes: [],
    proposals: [],
    depositParams: void 0,
    votingParams: void 0,
    tallyParams: void 0,
    params: void 0
  };
}
var GenesisState10 = {
  encode(message, writer = _m040.Writer.create()) {
    if (message.startingProposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.startingProposalId.toString()));
    }
    for (const v of message.deposits) {
      Deposit.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.votes) {
      Vote.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.proposals) {
      Proposal.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.depositParams !== void 0) {
      DepositParams.encode(message.depositParams, writer.uint32(42).fork()).ldelim();
    }
    if (message.votingParams !== void 0) {
      VotingParams.encode(message.votingParams, writer.uint32(50).fork()).ldelim();
    }
    if (message.tallyParams !== void 0) {
      TallyParams.encode(message.tallyParams, writer.uint32(58).fork()).ldelim();
    }
    if (message.params !== void 0) {
      Params4.encode(message.params, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m040.Reader ? input : new _m040.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState10();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.startingProposalId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.deposits.push(Deposit.decode(reader, reader.uint32()));
          break;
        case 3:
          message.votes.push(Vote.decode(reader, reader.uint32()));
          break;
        case 4:
          message.proposals.push(Proposal.decode(reader, reader.uint32()));
          break;
        case 5:
          message.depositParams = DepositParams.decode(reader, reader.uint32());
          break;
        case 6:
          message.votingParams = VotingParams.decode(reader, reader.uint32());
          break;
        case 7:
          message.tallyParams = TallyParams.decode(reader, reader.uint32());
          break;
        case 8:
          message.params = Params4.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      startingProposalId: isSet(object.startingProposalId) ? BigInt(object.startingProposalId.toString()) : BigInt("0"),
      deposits: Array.isArray(object === null || object === void 0 ? void 0 : object.deposits) ? object.deposits.map((e) => Deposit.fromJSON(e)) : [],
      votes: Array.isArray(object === null || object === void 0 ? void 0 : object.votes) ? object.votes.map((e) => Vote.fromJSON(e)) : [],
      proposals: Array.isArray(object === null || object === void 0 ? void 0 : object.proposals) ? object.proposals.map((e) => Proposal.fromJSON(e)) : [],
      depositParams: isSet(object.depositParams) ? DepositParams.fromJSON(object.depositParams) : void 0,
      votingParams: isSet(object.votingParams) ? VotingParams.fromJSON(object.votingParams) : void 0,
      tallyParams: isSet(object.tallyParams) ? TallyParams.fromJSON(object.tallyParams) : void 0,
      params: isSet(object.params) ? Params4.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.startingProposalId !== void 0 && (obj.startingProposalId = (message.startingProposalId || BigInt("0")).toString());
    if (message.deposits) {
      obj.deposits = message.deposits.map((e) => e ? Deposit.toJSON(e) : void 0);
    } else {
      obj.deposits = [];
    }
    if (message.votes) {
      obj.votes = message.votes.map((e) => e ? Vote.toJSON(e) : void 0);
    } else {
      obj.votes = [];
    }
    if (message.proposals) {
      obj.proposals = message.proposals.map((e) => e ? Proposal.toJSON(e) : void 0);
    } else {
      obj.proposals = [];
    }
    message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? DepositParams.toJSON(message.depositParams) : void 0);
    message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? VotingParams.toJSON(message.votingParams) : void 0);
    message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? TallyParams.toJSON(message.tallyParams) : void 0);
    message.params !== void 0 && (obj.params = message.params ? Params4.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$deposits, _object$votes, _object$proposals;
    const message = createBaseGenesisState10();
    message.startingProposalId = object.startingProposalId !== void 0 && object.startingProposalId !== null ? BigInt(object.startingProposalId.toString()) : BigInt("0");
    message.deposits = ((_object$deposits = object.deposits) === null || _object$deposits === void 0 ? void 0 : _object$deposits.map((e) => Deposit.fromPartial(e))) || [];
    message.votes = ((_object$votes = object.votes) === null || _object$votes === void 0 ? void 0 : _object$votes.map((e) => Vote.fromPartial(e))) || [];
    message.proposals = ((_object$proposals = object.proposals) === null || _object$proposals === void 0 ? void 0 : _object$proposals.map((e) => Proposal.fromPartial(e))) || [];
    message.depositParams = object.depositParams !== void 0 && object.depositParams !== null ? DepositParams.fromPartial(object.depositParams) : void 0;
    message.votingParams = object.votingParams !== void 0 && object.votingParams !== null ? VotingParams.fromPartial(object.votingParams) : void 0;
    message.tallyParams = object.tallyParams !== void 0 && object.tallyParams !== null ? TallyParams.fromPartial(object.tallyParams) : void 0;
    message.params = object.params !== void 0 && object.params !== null ? Params4.fromPartial(object.params) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1beta1/genesis.js
var genesis_exports12 = {};
__export(genesis_exports12, {
  GenesisState: () => GenesisState11
});
var _m041 = __toESM(require_minimal());
function createBaseGenesisState11() {
  return {
    startingProposalId: BigInt("0"),
    deposits: [],
    votes: [],
    proposals: [],
    depositParams: void 0,
    votingParams: void 0,
    tallyParams: void 0
  };
}
var GenesisState11 = {
  encode(message, writer = _m041.Writer.create()) {
    if (message.startingProposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.startingProposalId.toString()));
    }
    for (const v of message.deposits) {
      Deposit2.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.votes) {
      Vote2.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.proposals) {
      Proposal2.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.depositParams !== void 0) {
      DepositParams2.encode(message.depositParams, writer.uint32(42).fork()).ldelim();
    }
    if (message.votingParams !== void 0) {
      VotingParams2.encode(message.votingParams, writer.uint32(50).fork()).ldelim();
    }
    if (message.tallyParams !== void 0) {
      TallyParams2.encode(message.tallyParams, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m041.Reader ? input : new _m041.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState11();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.startingProposalId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.deposits.push(Deposit2.decode(reader, reader.uint32()));
          break;
        case 3:
          message.votes.push(Vote2.decode(reader, reader.uint32()));
          break;
        case 4:
          message.proposals.push(Proposal2.decode(reader, reader.uint32()));
          break;
        case 5:
          message.depositParams = DepositParams2.decode(reader, reader.uint32());
          break;
        case 6:
          message.votingParams = VotingParams2.decode(reader, reader.uint32());
          break;
        case 7:
          message.tallyParams = TallyParams2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      startingProposalId: isSet(object.startingProposalId) ? BigInt(object.startingProposalId.toString()) : BigInt("0"),
      deposits: Array.isArray(object === null || object === void 0 ? void 0 : object.deposits) ? object.deposits.map((e) => Deposit2.fromJSON(e)) : [],
      votes: Array.isArray(object === null || object === void 0 ? void 0 : object.votes) ? object.votes.map((e) => Vote2.fromJSON(e)) : [],
      proposals: Array.isArray(object === null || object === void 0 ? void 0 : object.proposals) ? object.proposals.map((e) => Proposal2.fromJSON(e)) : [],
      depositParams: isSet(object.depositParams) ? DepositParams2.fromJSON(object.depositParams) : void 0,
      votingParams: isSet(object.votingParams) ? VotingParams2.fromJSON(object.votingParams) : void 0,
      tallyParams: isSet(object.tallyParams) ? TallyParams2.fromJSON(object.tallyParams) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.startingProposalId !== void 0 && (obj.startingProposalId = (message.startingProposalId || BigInt("0")).toString());
    if (message.deposits) {
      obj.deposits = message.deposits.map((e) => e ? Deposit2.toJSON(e) : void 0);
    } else {
      obj.deposits = [];
    }
    if (message.votes) {
      obj.votes = message.votes.map((e) => e ? Vote2.toJSON(e) : void 0);
    } else {
      obj.votes = [];
    }
    if (message.proposals) {
      obj.proposals = message.proposals.map((e) => e ? Proposal2.toJSON(e) : void 0);
    } else {
      obj.proposals = [];
    }
    message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? DepositParams2.toJSON(message.depositParams) : void 0);
    message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? VotingParams2.toJSON(message.votingParams) : void 0);
    message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? TallyParams2.toJSON(message.tallyParams) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$deposits, _object$votes, _object$proposals;
    const message = createBaseGenesisState11();
    message.startingProposalId = object.startingProposalId !== void 0 && object.startingProposalId !== null ? BigInt(object.startingProposalId.toString()) : BigInt("0");
    message.deposits = ((_object$deposits = object.deposits) === null || _object$deposits === void 0 ? void 0 : _object$deposits.map((e) => Deposit2.fromPartial(e))) || [];
    message.votes = ((_object$votes = object.votes) === null || _object$votes === void 0 ? void 0 : _object$votes.map((e) => Vote2.fromPartial(e))) || [];
    message.proposals = ((_object$proposals = object.proposals) === null || _object$proposals === void 0 ? void 0 : _object$proposals.map((e) => Proposal2.fromPartial(e))) || [];
    message.depositParams = object.depositParams !== void 0 && object.depositParams !== null ? DepositParams2.fromPartial(object.depositParams) : void 0;
    message.votingParams = object.votingParams !== void 0 && object.votingParams !== null ? VotingParams2.fromPartial(object.votingParams) : void 0;
    message.tallyParams = object.tallyParams !== void 0 && object.tallyParams !== null ? TallyParams2.fromPartial(object.tallyParams) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/group/module/v1/module.js
var module_exports14 = {};
__export(module_exports14, {
  Module: () => Module13
});
var _m042 = __toESM(require_minimal());
function createBaseModule13() {
  return {
    maxExecutionPeriod: void 0,
    maxMetadataLen: BigInt("0")
  };
}
var Module13 = {
  encode(message, writer = _m042.Writer.create()) {
    if (message.maxExecutionPeriod !== void 0) {
      Duration.encode(message.maxExecutionPeriod, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxMetadataLen !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.maxMetadataLen.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m042.Reader ? input : new _m042.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule13();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxExecutionPeriod = Duration.decode(reader, reader.uint32());
          break;
        case 2:
          message.maxMetadataLen = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxExecutionPeriod: isSet(object.maxExecutionPeriod) ? Duration.fromJSON(object.maxExecutionPeriod) : void 0,
      maxMetadataLen: isSet(object.maxMetadataLen) ? BigInt(object.maxMetadataLen.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.maxExecutionPeriod !== void 0 && (obj.maxExecutionPeriod = message.maxExecutionPeriod ? Duration.toJSON(message.maxExecutionPeriod) : void 0);
    message.maxMetadataLen !== void 0 && (obj.maxMetadataLen = (message.maxMetadataLen || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModule13();
    message.maxExecutionPeriod = object.maxExecutionPeriod !== void 0 && object.maxExecutionPeriod !== null ? Duration.fromPartial(object.maxExecutionPeriod) : void 0;
    message.maxMetadataLen = object.maxMetadataLen !== void 0 && object.maxMetadataLen !== null ? BigInt(object.maxMetadataLen.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/group/v1/events.js
var events_exports = {};
__export(events_exports, {
  EventCreateGroup: () => EventCreateGroup,
  EventCreateGroupPolicy: () => EventCreateGroupPolicy,
  EventExec: () => EventExec,
  EventLeaveGroup: () => EventLeaveGroup,
  EventSubmitProposal: () => EventSubmitProposal,
  EventUpdateGroup: () => EventUpdateGroup,
  EventUpdateGroupPolicy: () => EventUpdateGroupPolicy,
  EventVote: () => EventVote,
  EventWithdrawProposal: () => EventWithdrawProposal
});
var _m043 = __toESM(require_minimal());
function createBaseEventCreateGroup() {
  return {
    groupId: BigInt("0")
  };
}
var EventCreateGroup = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.groupId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.groupId.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventCreateGroup();
    message.groupId = object.groupId !== void 0 && object.groupId !== null ? BigInt(object.groupId.toString()) : BigInt("0");
    return message;
  }
};
function createBaseEventUpdateGroup() {
  return {
    groupId: BigInt("0")
  };
}
var EventUpdateGroup = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.groupId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.groupId.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventUpdateGroup();
    message.groupId = object.groupId !== void 0 && object.groupId !== null ? BigInt(object.groupId.toString()) : BigInt("0");
    return message;
  }
};
function createBaseEventCreateGroupPolicy() {
  return {
    address: ""
  };
}
var EventCreateGroupPolicy = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateGroupPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    return obj;
  },
  fromPartial(object) {
    var _object$address;
    const message = createBaseEventCreateGroupPolicy();
    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : "";
    return message;
  }
};
function createBaseEventUpdateGroupPolicy() {
  return {
    address: ""
  };
}
var EventUpdateGroupPolicy = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateGroupPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    return obj;
  },
  fromPartial(object) {
    var _object$address2;
    const message = createBaseEventUpdateGroupPolicy();
    message.address = (_object$address2 = object.address) !== null && _object$address2 !== void 0 ? _object$address2 : "";
    return message;
  }
};
function createBaseEventSubmitProposal() {
  return {
    proposalId: BigInt("0")
  };
}
var EventSubmitProposal = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.proposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.proposalId.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      proposalId: isSet(object.proposalId) ? BigInt(object.proposalId.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventSubmitProposal();
    message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? BigInt(object.proposalId.toString()) : BigInt("0");
    return message;
  }
};
function createBaseEventWithdrawProposal() {
  return {
    proposalId: BigInt("0")
  };
}
var EventWithdrawProposal = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.proposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.proposalId.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventWithdrawProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      proposalId: isSet(object.proposalId) ? BigInt(object.proposalId.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventWithdrawProposal();
    message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? BigInt(object.proposalId.toString()) : BigInt("0");
    return message;
  }
};
function createBaseEventVote() {
  return {
    proposalId: BigInt("0")
  };
}
var EventVote = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.proposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.proposalId.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      proposalId: isSet(object.proposalId) ? BigInt(object.proposalId.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventVote();
    message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? BigInt(object.proposalId.toString()) : BigInt("0");
    return message;
  }
};
function createBaseEventExec() {
  return {
    proposalId: BigInt("0"),
    result: 0,
    logs: ""
  };
}
var EventExec = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.proposalId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.proposalId.toString()));
    }
    if (message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }
    if (message.logs !== "") {
      writer.uint32(26).string(message.logs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventExec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.result = reader.int32();
          break;
        case 3:
          message.logs = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      proposalId: isSet(object.proposalId) ? BigInt(object.proposalId.toString()) : BigInt("0"),
      result: isSet(object.result) ? proposalExecutorResultFromJSON(object.result) : 0,
      logs: isSet(object.logs) ? String(object.logs) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt("0")).toString());
    message.result !== void 0 && (obj.result = proposalExecutorResultToJSON(message.result));
    message.logs !== void 0 && (obj.logs = message.logs);
    return obj;
  },
  fromPartial(object) {
    var _object$result, _object$logs;
    const message = createBaseEventExec();
    message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? BigInt(object.proposalId.toString()) : BigInt("0");
    message.result = (_object$result = object.result) !== null && _object$result !== void 0 ? _object$result : 0;
    message.logs = (_object$logs = object.logs) !== null && _object$logs !== void 0 ? _object$logs : "";
    return message;
  }
};
function createBaseEventLeaveGroup() {
  return {
    groupId: BigInt("0"),
    address: ""
  };
}
var EventLeaveGroup = {
  encode(message, writer = _m043.Writer.create()) {
    if (message.groupId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.groupId.toString()));
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m043.Reader ? input : new _m043.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventLeaveGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId.toString()) : BigInt("0"),
      address: isSet(object.address) ? String(object.address) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt("0")).toString());
    message.address !== void 0 && (obj.address = message.address);
    return obj;
  },
  fromPartial(object) {
    var _object$address3;
    const message = createBaseEventLeaveGroup();
    message.groupId = object.groupId !== void 0 && object.groupId !== null ? BigInt(object.groupId.toString()) : BigInt("0");
    message.address = (_object$address3 = object.address) !== null && _object$address3 !== void 0 ? _object$address3 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/group/v1/genesis.js
var genesis_exports13 = {};
__export(genesis_exports13, {
  GenesisState: () => GenesisState12
});
var _m044 = __toESM(require_minimal());
function createBaseGenesisState12() {
  return {
    groupSeq: BigInt("0"),
    groups: [],
    groupMembers: [],
    groupPolicySeq: BigInt("0"),
    groupPolicies: [],
    proposalSeq: BigInt("0"),
    proposals: [],
    votes: []
  };
}
var GenesisState12 = {
  encode(message, writer = _m044.Writer.create()) {
    if (message.groupSeq !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.groupSeq.toString()));
    }
    for (const v of message.groups) {
      GroupInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.groupMembers) {
      GroupMember.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.groupPolicySeq !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.groupPolicySeq.toString()));
    }
    for (const v of message.groupPolicies) {
      GroupPolicyInfo.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.proposalSeq !== BigInt(0)) {
      writer.uint32(48).uint64(import_long.default.fromString(message.proposalSeq.toString()));
    }
    for (const v of message.proposals) {
      Proposal3.encode(v, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.votes) {
      Vote3.encode(v, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m044.Reader ? input : new _m044.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState12();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupSeq = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.groups.push(GroupInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.groupMembers.push(GroupMember.decode(reader, reader.uint32()));
          break;
        case 4:
          message.groupPolicySeq = BigInt(reader.uint64().toString());
          break;
        case 5:
          message.groupPolicies.push(GroupPolicyInfo.decode(reader, reader.uint32()));
          break;
        case 6:
          message.proposalSeq = BigInt(reader.uint64().toString());
          break;
        case 7:
          message.proposals.push(Proposal3.decode(reader, reader.uint32()));
          break;
        case 8:
          message.votes.push(Vote3.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      groupSeq: isSet(object.groupSeq) ? BigInt(object.groupSeq.toString()) : BigInt("0"),
      groups: Array.isArray(object === null || object === void 0 ? void 0 : object.groups) ? object.groups.map((e) => GroupInfo.fromJSON(e)) : [],
      groupMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.groupMembers) ? object.groupMembers.map((e) => GroupMember.fromJSON(e)) : [],
      groupPolicySeq: isSet(object.groupPolicySeq) ? BigInt(object.groupPolicySeq.toString()) : BigInt("0"),
      groupPolicies: Array.isArray(object === null || object === void 0 ? void 0 : object.groupPolicies) ? object.groupPolicies.map((e) => GroupPolicyInfo.fromJSON(e)) : [],
      proposalSeq: isSet(object.proposalSeq) ? BigInt(object.proposalSeq.toString()) : BigInt("0"),
      proposals: Array.isArray(object === null || object === void 0 ? void 0 : object.proposals) ? object.proposals.map((e) => Proposal3.fromJSON(e)) : [],
      votes: Array.isArray(object === null || object === void 0 ? void 0 : object.votes) ? object.votes.map((e) => Vote3.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.groupSeq !== void 0 && (obj.groupSeq = (message.groupSeq || BigInt("0")).toString());
    if (message.groups) {
      obj.groups = message.groups.map((e) => e ? GroupInfo.toJSON(e) : void 0);
    } else {
      obj.groups = [];
    }
    if (message.groupMembers) {
      obj.groupMembers = message.groupMembers.map((e) => e ? GroupMember.toJSON(e) : void 0);
    } else {
      obj.groupMembers = [];
    }
    message.groupPolicySeq !== void 0 && (obj.groupPolicySeq = (message.groupPolicySeq || BigInt("0")).toString());
    if (message.groupPolicies) {
      obj.groupPolicies = message.groupPolicies.map((e) => e ? GroupPolicyInfo.toJSON(e) : void 0);
    } else {
      obj.groupPolicies = [];
    }
    message.proposalSeq !== void 0 && (obj.proposalSeq = (message.proposalSeq || BigInt("0")).toString());
    if (message.proposals) {
      obj.proposals = message.proposals.map((e) => e ? Proposal3.toJSON(e) : void 0);
    } else {
      obj.proposals = [];
    }
    if (message.votes) {
      obj.votes = message.votes.map((e) => e ? Vote3.toJSON(e) : void 0);
    } else {
      obj.votes = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$groups, _object$groupMembers, _object$groupPolicies, _object$proposals, _object$votes;
    const message = createBaseGenesisState12();
    message.groupSeq = object.groupSeq !== void 0 && object.groupSeq !== null ? BigInt(object.groupSeq.toString()) : BigInt("0");
    message.groups = ((_object$groups = object.groups) === null || _object$groups === void 0 ? void 0 : _object$groups.map((e) => GroupInfo.fromPartial(e))) || [];
    message.groupMembers = ((_object$groupMembers = object.groupMembers) === null || _object$groupMembers === void 0 ? void 0 : _object$groupMembers.map((e) => GroupMember.fromPartial(e))) || [];
    message.groupPolicySeq = object.groupPolicySeq !== void 0 && object.groupPolicySeq !== null ? BigInt(object.groupPolicySeq.toString()) : BigInt("0");
    message.groupPolicies = ((_object$groupPolicies = object.groupPolicies) === null || _object$groupPolicies === void 0 ? void 0 : _object$groupPolicies.map((e) => GroupPolicyInfo.fromPartial(e))) || [];
    message.proposalSeq = object.proposalSeq !== void 0 && object.proposalSeq !== null ? BigInt(object.proposalSeq.toString()) : BigInt("0");
    message.proposals = ((_object$proposals = object.proposals) === null || _object$proposals === void 0 ? void 0 : _object$proposals.map((e) => Proposal3.fromPartial(e))) || [];
    message.votes = ((_object$votes = object.votes) === null || _object$votes === void 0 ? void 0 : _object$votes.map((e) => Vote3.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/mint/module/v1/module.js
var module_exports15 = {};
__export(module_exports15, {
  Module: () => Module14
});
var _m045 = __toESM(require_minimal());
function createBaseModule14() {
  return {
    feeCollectorName: "",
    authority: ""
  };
}
var Module14 = {
  encode(message, writer = _m045.Writer.create()) {
    if (message.feeCollectorName !== "") {
      writer.uint32(10).string(message.feeCollectorName);
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m045.Reader ? input : new _m045.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule14();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feeCollectorName = reader.string();
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      feeCollectorName: isSet(object.feeCollectorName) ? String(object.feeCollectorName) : "",
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.feeCollectorName !== void 0 && (obj.feeCollectorName = message.feeCollectorName);
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$feeCollectorN, _object$authority;
    const message = createBaseModule14();
    message.feeCollectorName = (_object$feeCollectorN = object.feeCollectorName) !== null && _object$feeCollectorN !== void 0 ? _object$feeCollectorN : "";
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/mint/v1beta1/genesis.js
var genesis_exports14 = {};
__export(genesis_exports14, {
  GenesisState: () => GenesisState13
});
var _m046 = __toESM(require_minimal());
function createBaseGenesisState13() {
  return {
    minter: void 0,
    params: void 0
  };
}
var GenesisState13 = {
  encode(message, writer = _m046.Writer.create()) {
    if (message.minter !== void 0) {
      Minter.encode(message.minter, writer.uint32(10).fork()).ldelim();
    }
    if (message.params !== void 0) {
      Params5.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m046.Reader ? input : new _m046.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState13();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.minter = Minter.decode(reader, reader.uint32());
          break;
        case 2:
          message.params = Params5.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      minter: isSet(object.minter) ? Minter.fromJSON(object.minter) : void 0,
      params: isSet(object.params) ? Params5.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.minter !== void 0 && (obj.minter = message.minter ? Minter.toJSON(message.minter) : void 0);
    message.params !== void 0 && (obj.params = message.params ? Params5.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenesisState13();
    message.minter = object.minter !== void 0 && object.minter !== null ? Minter.fromPartial(object.minter) : void 0;
    message.params = object.params !== void 0 && object.params !== null ? Params5.fromPartial(object.params) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/msg/v1/msg.js
var msg_exports = {};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/nft/module/v1/module.js
var module_exports16 = {};
__export(module_exports16, {
  Module: () => Module15
});
var _m047 = __toESM(require_minimal());
function createBaseModule15() {
  return {};
}
var Module15 = {
  encode(_, writer = _m047.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m047.Reader ? input : new _m047.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule15();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule15();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/nft/v1beta1/event.js
var event_exports2 = {};
__export(event_exports2, {
  EventBurn: () => EventBurn,
  EventMint: () => EventMint,
  EventSend: () => EventSend
});
var _m048 = __toESM(require_minimal());
function createBaseEventSend() {
  return {
    classId: "",
    id: "",
    sender: "",
    receiver: ""
  };
}
var EventSend = {
  encode(message, writer = _m048.Writer.create()) {
    if (message.classId !== "") {
      writer.uint32(10).string(message.classId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    if (message.receiver !== "") {
      writer.uint32(34).string(message.receiver);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m048.Reader ? input : new _m048.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.classId = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.sender = reader.string();
          break;
        case 4:
          message.receiver = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      classId: isSet(object.classId) ? String(object.classId) : "",
      id: isSet(object.id) ? String(object.id) : "",
      sender: isSet(object.sender) ? String(object.sender) : "",
      receiver: isSet(object.receiver) ? String(object.receiver) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.classId !== void 0 && (obj.classId = message.classId);
    message.id !== void 0 && (obj.id = message.id);
    message.sender !== void 0 && (obj.sender = message.sender);
    message.receiver !== void 0 && (obj.receiver = message.receiver);
    return obj;
  },
  fromPartial(object) {
    var _object$classId, _object$id, _object$sender, _object$receiver;
    const message = createBaseEventSend();
    message.classId = (_object$classId = object.classId) !== null && _object$classId !== void 0 ? _object$classId : "";
    message.id = (_object$id = object.id) !== null && _object$id !== void 0 ? _object$id : "";
    message.sender = (_object$sender = object.sender) !== null && _object$sender !== void 0 ? _object$sender : "";
    message.receiver = (_object$receiver = object.receiver) !== null && _object$receiver !== void 0 ? _object$receiver : "";
    return message;
  }
};
function createBaseEventMint() {
  return {
    classId: "",
    id: "",
    owner: ""
  };
}
var EventMint = {
  encode(message, writer = _m048.Writer.create()) {
    if (message.classId !== "") {
      writer.uint32(10).string(message.classId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m048.Reader ? input : new _m048.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventMint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.classId = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.owner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      classId: isSet(object.classId) ? String(object.classId) : "",
      id: isSet(object.id) ? String(object.id) : "",
      owner: isSet(object.owner) ? String(object.owner) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.classId !== void 0 && (obj.classId = message.classId);
    message.id !== void 0 && (obj.id = message.id);
    message.owner !== void 0 && (obj.owner = message.owner);
    return obj;
  },
  fromPartial(object) {
    var _object$classId2, _object$id2, _object$owner;
    const message = createBaseEventMint();
    message.classId = (_object$classId2 = object.classId) !== null && _object$classId2 !== void 0 ? _object$classId2 : "";
    message.id = (_object$id2 = object.id) !== null && _object$id2 !== void 0 ? _object$id2 : "";
    message.owner = (_object$owner = object.owner) !== null && _object$owner !== void 0 ? _object$owner : "";
    return message;
  }
};
function createBaseEventBurn() {
  return {
    classId: "",
    id: "",
    owner: ""
  };
}
var EventBurn = {
  encode(message, writer = _m048.Writer.create()) {
    if (message.classId !== "") {
      writer.uint32(10).string(message.classId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m048.Reader ? input : new _m048.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.classId = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.owner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      classId: isSet(object.classId) ? String(object.classId) : "",
      id: isSet(object.id) ? String(object.id) : "",
      owner: isSet(object.owner) ? String(object.owner) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.classId !== void 0 && (obj.classId = message.classId);
    message.id !== void 0 && (obj.id = message.id);
    message.owner !== void 0 && (obj.owner = message.owner);
    return obj;
  },
  fromPartial(object) {
    var _object$classId3, _object$id3, _object$owner2;
    const message = createBaseEventBurn();
    message.classId = (_object$classId3 = object.classId) !== null && _object$classId3 !== void 0 ? _object$classId3 : "";
    message.id = (_object$id3 = object.id) !== null && _object$id3 !== void 0 ? _object$id3 : "";
    message.owner = (_object$owner2 = object.owner) !== null && _object$owner2 !== void 0 ? _object$owner2 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/nft/v1beta1/genesis.js
var genesis_exports15 = {};
__export(genesis_exports15, {
  Entry: () => Entry,
  GenesisState: () => GenesisState14
});
var _m049 = __toESM(require_minimal());
function createBaseGenesisState14() {
  return {
    classes: [],
    entries: []
  };
}
var GenesisState14 = {
  encode(message, writer = _m049.Writer.create()) {
    for (const v of message.classes) {
      Class.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.entries) {
      Entry.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m049.Reader ? input : new _m049.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState14();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.classes.push(Class.decode(reader, reader.uint32()));
          break;
        case 2:
          message.entries.push(Entry.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      classes: Array.isArray(object === null || object === void 0 ? void 0 : object.classes) ? object.classes.map((e) => Class.fromJSON(e)) : [],
      entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => Entry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.classes) {
      obj.classes = message.classes.map((e) => e ? Class.toJSON(e) : void 0);
    } else {
      obj.classes = [];
    }
    if (message.entries) {
      obj.entries = message.entries.map((e) => e ? Entry.toJSON(e) : void 0);
    } else {
      obj.entries = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$classes, _object$entries;
    const message = createBaseGenesisState14();
    message.classes = ((_object$classes = object.classes) === null || _object$classes === void 0 ? void 0 : _object$classes.map((e) => Class.fromPartial(e))) || [];
    message.entries = ((_object$entries = object.entries) === null || _object$entries === void 0 ? void 0 : _object$entries.map((e) => Entry.fromPartial(e))) || [];
    return message;
  }
};
function createBaseEntry() {
  return {
    owner: "",
    nfts: []
  };
}
var Entry = {
  encode(message, writer = _m049.Writer.create()) {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    for (const v of message.nfts) {
      NFT.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m049.Reader ? input : new _m049.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.owner = reader.string();
          break;
        case 2:
          message.nfts.push(NFT.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      owner: isSet(object.owner) ? String(object.owner) : "",
      nfts: Array.isArray(object === null || object === void 0 ? void 0 : object.nfts) ? object.nfts.map((e) => NFT.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.owner !== void 0 && (obj.owner = message.owner);
    if (message.nfts) {
      obj.nfts = message.nfts.map((e) => e ? NFT.toJSON(e) : void 0);
    } else {
      obj.nfts = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$owner, _object$nfts;
    const message = createBaseEntry();
    message.owner = (_object$owner = object.owner) !== null && _object$owner !== void 0 ? _object$owner : "";
    message.nfts = ((_object$nfts = object.nfts) === null || _object$nfts === void 0 ? void 0 : _object$nfts.map((e) => NFT.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/orm/module/v1alpha1/module.js
var module_exports17 = {};
__export(module_exports17, {
  Module: () => Module16
});
var _m050 = __toESM(require_minimal());
function createBaseModule16() {
  return {};
}
var Module16 = {
  encode(_, writer = _m050.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m050.Reader ? input : new _m050.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule16();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/orm/v1/orm.js
var orm_exports = {};
__export(orm_exports, {
  PrimaryKeyDescriptor: () => PrimaryKeyDescriptor,
  SecondaryIndexDescriptor: () => SecondaryIndexDescriptor,
  SingletonDescriptor: () => SingletonDescriptor,
  TableDescriptor: () => TableDescriptor
});
var _m051 = __toESM(require_minimal());
function createBaseTableDescriptor() {
  return {
    primaryKey: void 0,
    index: [],
    id: 0
  };
}
var TableDescriptor = {
  encode(message, writer = _m051.Writer.create()) {
    if (message.primaryKey !== void 0) {
      PrimaryKeyDescriptor.encode(message.primaryKey, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.index) {
      SecondaryIndexDescriptor.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== 0) {
      writer.uint32(24).uint32(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m051.Reader ? input : new _m051.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTableDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.primaryKey = PrimaryKeyDescriptor.decode(reader, reader.uint32());
          break;
        case 2:
          message.index.push(SecondaryIndexDescriptor.decode(reader, reader.uint32()));
          break;
        case 3:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      primaryKey: isSet(object.primaryKey) ? PrimaryKeyDescriptor.fromJSON(object.primaryKey) : void 0,
      index: Array.isArray(object === null || object === void 0 ? void 0 : object.index) ? object.index.map((e) => SecondaryIndexDescriptor.fromJSON(e)) : [],
      id: isSet(object.id) ? Number(object.id) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.primaryKey !== void 0 && (obj.primaryKey = message.primaryKey ? PrimaryKeyDescriptor.toJSON(message.primaryKey) : void 0);
    if (message.index) {
      obj.index = message.index.map((e) => e ? SecondaryIndexDescriptor.toJSON(e) : void 0);
    } else {
      obj.index = [];
    }
    message.id !== void 0 && (obj.id = Math.round(message.id));
    return obj;
  },
  fromPartial(object) {
    var _object$index, _object$id;
    const message = createBaseTableDescriptor();
    message.primaryKey = object.primaryKey !== void 0 && object.primaryKey !== null ? PrimaryKeyDescriptor.fromPartial(object.primaryKey) : void 0;
    message.index = ((_object$index = object.index) === null || _object$index === void 0 ? void 0 : _object$index.map((e) => SecondaryIndexDescriptor.fromPartial(e))) || [];
    message.id = (_object$id = object.id) !== null && _object$id !== void 0 ? _object$id : 0;
    return message;
  }
};
function createBasePrimaryKeyDescriptor() {
  return {
    fields: "",
    autoIncrement: false
  };
}
var PrimaryKeyDescriptor = {
  encode(message, writer = _m051.Writer.create()) {
    if (message.fields !== "") {
      writer.uint32(10).string(message.fields);
    }
    if (message.autoIncrement === true) {
      writer.uint32(16).bool(message.autoIncrement);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m051.Reader ? input : new _m051.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePrimaryKeyDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields = reader.string();
          break;
        case 2:
          message.autoIncrement = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isSet(object.fields) ? String(object.fields) : "",
      autoIncrement: isSet(object.autoIncrement) ? Boolean(object.autoIncrement) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.fields !== void 0 && (obj.fields = message.fields);
    message.autoIncrement !== void 0 && (obj.autoIncrement = message.autoIncrement);
    return obj;
  },
  fromPartial(object) {
    var _object$fields, _object$autoIncrement;
    const message = createBasePrimaryKeyDescriptor();
    message.fields = (_object$fields = object.fields) !== null && _object$fields !== void 0 ? _object$fields : "";
    message.autoIncrement = (_object$autoIncrement = object.autoIncrement) !== null && _object$autoIncrement !== void 0 ? _object$autoIncrement : false;
    return message;
  }
};
function createBaseSecondaryIndexDescriptor() {
  return {
    fields: "",
    id: 0,
    unique: false
  };
}
var SecondaryIndexDescriptor = {
  encode(message, writer = _m051.Writer.create()) {
    if (message.fields !== "") {
      writer.uint32(10).string(message.fields);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.unique === true) {
      writer.uint32(24).bool(message.unique);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m051.Reader ? input : new _m051.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecondaryIndexDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields = reader.string();
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.unique = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isSet(object.fields) ? String(object.fields) : "",
      id: isSet(object.id) ? Number(object.id) : 0,
      unique: isSet(object.unique) ? Boolean(object.unique) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.fields !== void 0 && (obj.fields = message.fields);
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.unique !== void 0 && (obj.unique = message.unique);
    return obj;
  },
  fromPartial(object) {
    var _object$fields2, _object$id2, _object$unique;
    const message = createBaseSecondaryIndexDescriptor();
    message.fields = (_object$fields2 = object.fields) !== null && _object$fields2 !== void 0 ? _object$fields2 : "";
    message.id = (_object$id2 = object.id) !== null && _object$id2 !== void 0 ? _object$id2 : 0;
    message.unique = (_object$unique = object.unique) !== null && _object$unique !== void 0 ? _object$unique : false;
    return message;
  }
};
function createBaseSingletonDescriptor() {
  return {
    id: 0
  };
}
var SingletonDescriptor = {
  encode(message, writer = _m051.Writer.create()) {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m051.Reader ? input : new _m051.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSingletonDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? Number(object.id) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = Math.round(message.id));
    return obj;
  },
  fromPartial(object) {
    var _object$id3;
    const message = createBaseSingletonDescriptor();
    message.id = (_object$id3 = object.id) !== null && _object$id3 !== void 0 ? _object$id3 : 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/orm/v1alpha1/schema.js
var schema_exports = {};
__export(schema_exports, {
  ModuleSchemaDescriptor: () => ModuleSchemaDescriptor,
  ModuleSchemaDescriptor_FileEntry: () => ModuleSchemaDescriptor_FileEntry,
  StorageType: () => StorageType,
  StorageTypeSDKType: () => StorageTypeSDKType,
  storageTypeFromJSON: () => storageTypeFromJSON,
  storageTypeToJSON: () => storageTypeToJSON
});
var _m052 = __toESM(require_minimal());
var StorageType = function(StorageType2) {
  StorageType2[StorageType2["STORAGE_TYPE_DEFAULT_UNSPECIFIED"] = 0] = "STORAGE_TYPE_DEFAULT_UNSPECIFIED";
  StorageType2[StorageType2["STORAGE_TYPE_MEMORY"] = 1] = "STORAGE_TYPE_MEMORY";
  StorageType2[StorageType2["STORAGE_TYPE_TRANSIENT"] = 2] = "STORAGE_TYPE_TRANSIENT";
  StorageType2[StorageType2["STORAGE_TYPE_INDEX"] = 3] = "STORAGE_TYPE_INDEX";
  StorageType2[StorageType2["STORAGE_TYPE_COMMITMENT"] = 4] = "STORAGE_TYPE_COMMITMENT";
  StorageType2[StorageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return StorageType2;
}({});
var StorageTypeSDKType = StorageType;
function storageTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STORAGE_TYPE_DEFAULT_UNSPECIFIED":
      return StorageType.STORAGE_TYPE_DEFAULT_UNSPECIFIED;
    case 1:
    case "STORAGE_TYPE_MEMORY":
      return StorageType.STORAGE_TYPE_MEMORY;
    case 2:
    case "STORAGE_TYPE_TRANSIENT":
      return StorageType.STORAGE_TYPE_TRANSIENT;
    case 3:
    case "STORAGE_TYPE_INDEX":
      return StorageType.STORAGE_TYPE_INDEX;
    case 4:
    case "STORAGE_TYPE_COMMITMENT":
      return StorageType.STORAGE_TYPE_COMMITMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StorageType.UNRECOGNIZED;
  }
}
function storageTypeToJSON(object) {
  switch (object) {
    case StorageType.STORAGE_TYPE_DEFAULT_UNSPECIFIED:
      return "STORAGE_TYPE_DEFAULT_UNSPECIFIED";
    case StorageType.STORAGE_TYPE_MEMORY:
      return "STORAGE_TYPE_MEMORY";
    case StorageType.STORAGE_TYPE_TRANSIENT:
      return "STORAGE_TYPE_TRANSIENT";
    case StorageType.STORAGE_TYPE_INDEX:
      return "STORAGE_TYPE_INDEX";
    case StorageType.STORAGE_TYPE_COMMITMENT:
      return "STORAGE_TYPE_COMMITMENT";
    case StorageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseModuleSchemaDescriptor() {
  return {
    schemaFile: [],
    prefix: new Uint8Array()
  };
}
var ModuleSchemaDescriptor = {
  encode(message, writer = _m052.Writer.create()) {
    for (const v of message.schemaFile) {
      ModuleSchemaDescriptor_FileEntry.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.prefix.length !== 0) {
      writer.uint32(18).bytes(message.prefix);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m052.Reader ? input : new _m052.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModuleSchemaDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.schemaFile.push(ModuleSchemaDescriptor_FileEntry.decode(reader, reader.uint32()));
          break;
        case 2:
          message.prefix = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      schemaFile: Array.isArray(object === null || object === void 0 ? void 0 : object.schemaFile) ? object.schemaFile.map((e) => ModuleSchemaDescriptor_FileEntry.fromJSON(e)) : [],
      prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.schemaFile) {
      obj.schemaFile = message.schemaFile.map((e) => e ? ModuleSchemaDescriptor_FileEntry.toJSON(e) : void 0);
    } else {
      obj.schemaFile = [];
    }
    message.prefix !== void 0 && (obj.prefix = base64FromBytes(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$schemaFile, _object$prefix;
    const message = createBaseModuleSchemaDescriptor();
    message.schemaFile = ((_object$schemaFile = object.schemaFile) === null || _object$schemaFile === void 0 ? void 0 : _object$schemaFile.map((e) => ModuleSchemaDescriptor_FileEntry.fromPartial(e))) || [];
    message.prefix = (_object$prefix = object.prefix) !== null && _object$prefix !== void 0 ? _object$prefix : new Uint8Array();
    return message;
  }
};
function createBaseModuleSchemaDescriptor_FileEntry() {
  return {
    id: 0,
    protoFileName: "",
    storageType: 0
  };
}
var ModuleSchemaDescriptor_FileEntry = {
  encode(message, writer = _m052.Writer.create()) {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.protoFileName !== "") {
      writer.uint32(18).string(message.protoFileName);
    }
    if (message.storageType !== 0) {
      writer.uint32(24).int32(message.storageType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m052.Reader ? input : new _m052.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModuleSchemaDescriptor_FileEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.protoFileName = reader.string();
          break;
        case 3:
          message.storageType = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      protoFileName: isSet(object.protoFileName) ? String(object.protoFileName) : "",
      storageType: isSet(object.storageType) ? storageTypeFromJSON(object.storageType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.protoFileName !== void 0 && (obj.protoFileName = message.protoFileName);
    message.storageType !== void 0 && (obj.storageType = storageTypeToJSON(message.storageType));
    return obj;
  },
  fromPartial(object) {
    var _object$id, _object$protoFileName, _object$storageType;
    const message = createBaseModuleSchemaDescriptor_FileEntry();
    message.id = (_object$id = object.id) !== null && _object$id !== void 0 ? _object$id : 0;
    message.protoFileName = (_object$protoFileName = object.protoFileName) !== null && _object$protoFileName !== void 0 ? _object$protoFileName : "";
    message.storageType = (_object$storageType = object.storageType) !== null && _object$storageType !== void 0 ? _object$storageType : 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/params/module/v1/module.js
var module_exports18 = {};
__export(module_exports18, {
  Module: () => Module17
});
var _m053 = __toESM(require_minimal());
function createBaseModule17() {
  return {};
}
var Module17 = {
  encode(_, writer = _m053.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m053.Reader ? input : new _m053.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule17();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule17();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/query/v1/query.js
var query_exports33 = {};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/reflection/v1/reflection.js
var reflection_exports3 = {};
__export(reflection_exports3, {
  FileDescriptorsRequest: () => FileDescriptorsRequest,
  FileDescriptorsResponse: () => FileDescriptorsResponse
});

// node_modules/@empower-plastic/empowerjs/module/codegen/google/protobuf/descriptor.js
var descriptor_exports = {};
__export(descriptor_exports, {
  DescriptorProto: () => DescriptorProto,
  DescriptorProto_ExtensionRange: () => DescriptorProto_ExtensionRange,
  DescriptorProto_ReservedRange: () => DescriptorProto_ReservedRange,
  EnumDescriptorProto: () => EnumDescriptorProto,
  EnumDescriptorProto_EnumReservedRange: () => EnumDescriptorProto_EnumReservedRange,
  EnumOptions: () => EnumOptions,
  EnumValueDescriptorProto: () => EnumValueDescriptorProto,
  EnumValueOptions: () => EnumValueOptions,
  ExtensionRangeOptions: () => ExtensionRangeOptions,
  FieldDescriptorProto: () => FieldDescriptorProto,
  FieldDescriptorProto_Label: () => FieldDescriptorProto_Label,
  FieldDescriptorProto_LabelSDKType: () => FieldDescriptorProto_LabelSDKType,
  FieldDescriptorProto_Type: () => FieldDescriptorProto_Type,
  FieldDescriptorProto_TypeSDKType: () => FieldDescriptorProto_TypeSDKType,
  FieldOptions: () => FieldOptions,
  FieldOptions_CType: () => FieldOptions_CType,
  FieldOptions_CTypeSDKType: () => FieldOptions_CTypeSDKType,
  FieldOptions_JSType: () => FieldOptions_JSType,
  FieldOptions_JSTypeSDKType: () => FieldOptions_JSTypeSDKType,
  FileDescriptorProto: () => FileDescriptorProto,
  FileDescriptorSet: () => FileDescriptorSet,
  FileOptions: () => FileOptions,
  FileOptions_OptimizeMode: () => FileOptions_OptimizeMode,
  FileOptions_OptimizeModeSDKType: () => FileOptions_OptimizeModeSDKType,
  GeneratedCodeInfo: () => GeneratedCodeInfo,
  GeneratedCodeInfo_Annotation: () => GeneratedCodeInfo_Annotation,
  MessageOptions: () => MessageOptions,
  MethodDescriptorProto: () => MethodDescriptorProto,
  MethodOptions: () => MethodOptions,
  MethodOptions_IdempotencyLevel: () => MethodOptions_IdempotencyLevel,
  MethodOptions_IdempotencyLevelSDKType: () => MethodOptions_IdempotencyLevelSDKType,
  OneofDescriptorProto: () => OneofDescriptorProto,
  OneofOptions: () => OneofOptions,
  ServiceDescriptorProto: () => ServiceDescriptorProto,
  ServiceOptions: () => ServiceOptions,
  SourceCodeInfo: () => SourceCodeInfo,
  SourceCodeInfo_Location: () => SourceCodeInfo_Location,
  UninterpretedOption: () => UninterpretedOption,
  UninterpretedOption_NamePart: () => UninterpretedOption_NamePart,
  fieldDescriptorProto_LabelFromJSON: () => fieldDescriptorProto_LabelFromJSON,
  fieldDescriptorProto_LabelToJSON: () => fieldDescriptorProto_LabelToJSON,
  fieldDescriptorProto_TypeFromJSON: () => fieldDescriptorProto_TypeFromJSON,
  fieldDescriptorProto_TypeToJSON: () => fieldDescriptorProto_TypeToJSON,
  fieldOptions_CTypeFromJSON: () => fieldOptions_CTypeFromJSON,
  fieldOptions_CTypeToJSON: () => fieldOptions_CTypeToJSON,
  fieldOptions_JSTypeFromJSON: () => fieldOptions_JSTypeFromJSON,
  fieldOptions_JSTypeToJSON: () => fieldOptions_JSTypeToJSON,
  fileOptions_OptimizeModeFromJSON: () => fileOptions_OptimizeModeFromJSON,
  fileOptions_OptimizeModeToJSON: () => fileOptions_OptimizeModeToJSON,
  methodOptions_IdempotencyLevelFromJSON: () => methodOptions_IdempotencyLevelFromJSON,
  methodOptions_IdempotencyLevelToJSON: () => methodOptions_IdempotencyLevelToJSON
});
var _m054 = __toESM(require_minimal());
var FieldDescriptorProto_Type = function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT64"] = 3] = "TYPE_INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT32"] = 5] = "TYPE_INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_STRING"] = 9] = "TYPE_STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return FieldDescriptorProto_Type2;
}({});
var FieldDescriptorProto_TypeSDKType = FieldDescriptorProto_Type;
function fieldDescriptorProto_TypeFromJSON(object) {
  switch (object) {
    case 1:
    case "TYPE_DOUBLE":
      return FieldDescriptorProto_Type.TYPE_DOUBLE;
    case 2:
    case "TYPE_FLOAT":
      return FieldDescriptorProto_Type.TYPE_FLOAT;
    case 3:
    case "TYPE_INT64":
      return FieldDescriptorProto_Type.TYPE_INT64;
    case 4:
    case "TYPE_UINT64":
      return FieldDescriptorProto_Type.TYPE_UINT64;
    case 5:
    case "TYPE_INT32":
      return FieldDescriptorProto_Type.TYPE_INT32;
    case 6:
    case "TYPE_FIXED64":
      return FieldDescriptorProto_Type.TYPE_FIXED64;
    case 7:
    case "TYPE_FIXED32":
      return FieldDescriptorProto_Type.TYPE_FIXED32;
    case 8:
    case "TYPE_BOOL":
      return FieldDescriptorProto_Type.TYPE_BOOL;
    case 9:
    case "TYPE_STRING":
      return FieldDescriptorProto_Type.TYPE_STRING;
    case 10:
    case "TYPE_GROUP":
      return FieldDescriptorProto_Type.TYPE_GROUP;
    case 11:
    case "TYPE_MESSAGE":
      return FieldDescriptorProto_Type.TYPE_MESSAGE;
    case 12:
    case "TYPE_BYTES":
      return FieldDescriptorProto_Type.TYPE_BYTES;
    case 13:
    case "TYPE_UINT32":
      return FieldDescriptorProto_Type.TYPE_UINT32;
    case 14:
    case "TYPE_ENUM":
      return FieldDescriptorProto_Type.TYPE_ENUM;
    case 15:
    case "TYPE_SFIXED32":
      return FieldDescriptorProto_Type.TYPE_SFIXED32;
    case 16:
    case "TYPE_SFIXED64":
      return FieldDescriptorProto_Type.TYPE_SFIXED64;
    case 17:
    case "TYPE_SINT32":
      return FieldDescriptorProto_Type.TYPE_SINT32;
    case 18:
    case "TYPE_SINT64":
      return FieldDescriptorProto_Type.TYPE_SINT64;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Type.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_TypeToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Type.TYPE_DOUBLE:
      return "TYPE_DOUBLE";
    case FieldDescriptorProto_Type.TYPE_FLOAT:
      return "TYPE_FLOAT";
    case FieldDescriptorProto_Type.TYPE_INT64:
      return "TYPE_INT64";
    case FieldDescriptorProto_Type.TYPE_UINT64:
      return "TYPE_UINT64";
    case FieldDescriptorProto_Type.TYPE_INT32:
      return "TYPE_INT32";
    case FieldDescriptorProto_Type.TYPE_FIXED64:
      return "TYPE_FIXED64";
    case FieldDescriptorProto_Type.TYPE_FIXED32:
      return "TYPE_FIXED32";
    case FieldDescriptorProto_Type.TYPE_BOOL:
      return "TYPE_BOOL";
    case FieldDescriptorProto_Type.TYPE_STRING:
      return "TYPE_STRING";
    case FieldDescriptorProto_Type.TYPE_GROUP:
      return "TYPE_GROUP";
    case FieldDescriptorProto_Type.TYPE_MESSAGE:
      return "TYPE_MESSAGE";
    case FieldDescriptorProto_Type.TYPE_BYTES:
      return "TYPE_BYTES";
    case FieldDescriptorProto_Type.TYPE_UINT32:
      return "TYPE_UINT32";
    case FieldDescriptorProto_Type.TYPE_ENUM:
      return "TYPE_ENUM";
    case FieldDescriptorProto_Type.TYPE_SFIXED32:
      return "TYPE_SFIXED32";
    case FieldDescriptorProto_Type.TYPE_SFIXED64:
      return "TYPE_SFIXED64";
    case FieldDescriptorProto_Type.TYPE_SINT32:
      return "TYPE_SINT32";
    case FieldDescriptorProto_Type.TYPE_SINT64:
      return "TYPE_SINT64";
    case FieldDescriptorProto_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var FieldDescriptorProto_Label = function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_OPTIONAL"] = 1] = "LABEL_OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REQUIRED"] = 2] = "LABEL_REQUIRED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REPEATED"] = 3] = "LABEL_REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return FieldDescriptorProto_Label2;
}({});
var FieldDescriptorProto_LabelSDKType = FieldDescriptorProto_Label;
function fieldDescriptorProto_LabelFromJSON(object) {
  switch (object) {
    case 1:
    case "LABEL_OPTIONAL":
      return FieldDescriptorProto_Label.LABEL_OPTIONAL;
    case 2:
    case "LABEL_REQUIRED":
      return FieldDescriptorProto_Label.LABEL_REQUIRED;
    case 3:
    case "LABEL_REPEATED":
      return FieldDescriptorProto_Label.LABEL_REPEATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Label.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_LabelToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Label.LABEL_OPTIONAL:
      return "LABEL_OPTIONAL";
    case FieldDescriptorProto_Label.LABEL_REQUIRED:
      return "LABEL_REQUIRED";
    case FieldDescriptorProto_Label.LABEL_REPEATED:
      return "LABEL_REPEATED";
    case FieldDescriptorProto_Label.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var FileOptions_OptimizeMode = function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return FileOptions_OptimizeMode2;
}({});
var FileOptions_OptimizeModeSDKType = FileOptions_OptimizeMode;
function fileOptions_OptimizeModeFromJSON(object) {
  switch (object) {
    case 1:
    case "SPEED":
      return FileOptions_OptimizeMode.SPEED;
    case 2:
    case "CODE_SIZE":
      return FileOptions_OptimizeMode.CODE_SIZE;
    case 3:
    case "LITE_RUNTIME":
      return FileOptions_OptimizeMode.LITE_RUNTIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileOptions_OptimizeMode.UNRECOGNIZED;
  }
}
function fileOptions_OptimizeModeToJSON(object) {
  switch (object) {
    case FileOptions_OptimizeMode.SPEED:
      return "SPEED";
    case FileOptions_OptimizeMode.CODE_SIZE:
      return "CODE_SIZE";
    case FileOptions_OptimizeMode.LITE_RUNTIME:
      return "LITE_RUNTIME";
    case FileOptions_OptimizeMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var FieldOptions_CType = function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
  FieldOptions_CType2[FieldOptions_CType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return FieldOptions_CType2;
}({});
var FieldOptions_CTypeSDKType = FieldOptions_CType;
function fieldOptions_CTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return FieldOptions_CType.STRING;
    case 1:
    case "CORD":
      return FieldOptions_CType.CORD;
    case 2:
    case "STRING_PIECE":
      return FieldOptions_CType.STRING_PIECE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_CType.UNRECOGNIZED;
  }
}
function fieldOptions_CTypeToJSON(object) {
  switch (object) {
    case FieldOptions_CType.STRING:
      return "STRING";
    case FieldOptions_CType.CORD:
      return "CORD";
    case FieldOptions_CType.STRING_PIECE:
      return "STRING_PIECE";
    case FieldOptions_CType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var FieldOptions_JSType = function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
  FieldOptions_JSType2[FieldOptions_JSType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return FieldOptions_JSType2;
}({});
var FieldOptions_JSTypeSDKType = FieldOptions_JSType;
function fieldOptions_JSTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "JS_NORMAL":
      return FieldOptions_JSType.JS_NORMAL;
    case 1:
    case "JS_STRING":
      return FieldOptions_JSType.JS_STRING;
    case 2:
    case "JS_NUMBER":
      return FieldOptions_JSType.JS_NUMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_JSType.UNRECOGNIZED;
  }
}
function fieldOptions_JSTypeToJSON(object) {
  switch (object) {
    case FieldOptions_JSType.JS_NORMAL:
      return "JS_NORMAL";
    case FieldOptions_JSType.JS_STRING:
      return "JS_STRING";
    case FieldOptions_JSType.JS_NUMBER:
      return "JS_NUMBER";
    case FieldOptions_JSType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var MethodOptions_IdempotencyLevel = function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return MethodOptions_IdempotencyLevel2;
}({});
var MethodOptions_IdempotencyLevelSDKType = MethodOptions_IdempotencyLevel;
function methodOptions_IdempotencyLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "IDEMPOTENCY_UNKNOWN":
      return MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN;
    case 1:
    case "NO_SIDE_EFFECTS":
      return MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;
    case 2:
    case "IDEMPOTENT":
      return MethodOptions_IdempotencyLevel.IDEMPOTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MethodOptions_IdempotencyLevel.UNRECOGNIZED;
  }
}
function methodOptions_IdempotencyLevelToJSON(object) {
  switch (object) {
    case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
      return "IDEMPOTENCY_UNKNOWN";
    case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
      return "NO_SIDE_EFFECTS";
    case MethodOptions_IdempotencyLevel.IDEMPOTENT:
      return "IDEMPOTENT";
    case MethodOptions_IdempotencyLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseFileDescriptorSet() {
  return {
    file: []
  };
}
var FileDescriptorSet = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.file) {
      FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.file.push(FileDescriptorProto.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      file: Array.isArray(object === null || object === void 0 ? void 0 : object.file) ? object.file.map((e) => FileDescriptorProto.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.file) {
      obj.file = message.file.map((e) => e ? FileDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.file = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$file;
    const message = createBaseFileDescriptorSet();
    message.file = ((_object$file = object.file) === null || _object$file === void 0 ? void 0 : _object$file.map((e) => FileDescriptorProto.fromPartial(e))) || [];
    return message;
  }
};
function createBaseFileDescriptorProto() {
  return {
    name: "",
    package: "",
    dependency: [],
    publicDependency: [],
    weakDependency: [],
    messageType: [],
    enumType: [],
    service: [],
    extension: [],
    options: void 0,
    sourceCodeInfo: void 0,
    syntax: ""
  };
}
var FileDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.package !== "") {
      writer.uint32(18).string(message.package);
    }
    for (const v of message.dependency) {
      writer.uint32(26).string(v);
    }
    writer.uint32(82).fork();
    for (const v of message.publicDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(90).fork();
    for (const v of message.weakDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.messageType) {
      DescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.service) {
      ServiceDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.options !== void 0) {
      FileOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    if (message.sourceCodeInfo !== void 0) {
      SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.syntax !== "") {
      writer.uint32(98).string(message.syntax);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.package = reader.string();
          break;
        case 3:
          message.dependency.push(reader.string());
          break;
        case 10:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.publicDependency.push(reader.int32());
            }
          } else {
            message.publicDependency.push(reader.int32());
          }
          break;
        case 11:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weakDependency.push(reader.int32());
            }
          } else {
            message.weakDependency.push(reader.int32());
          }
          break;
        case 4:
          message.messageType.push(DescriptorProto.decode(reader, reader.uint32()));
          break;
        case 5:
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 6:
          message.service.push(ServiceDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 7:
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 8:
          message.options = FileOptions.decode(reader, reader.uint32());
          break;
        case 9:
          message.sourceCodeInfo = SourceCodeInfo.decode(reader, reader.uint32());
          break;
        case 12:
          message.syntax = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      package: isSet(object.package) ? String(object.package) : "",
      dependency: Array.isArray(object === null || object === void 0 ? void 0 : object.dependency) ? object.dependency.map((e) => String(e)) : [],
      publicDependency: Array.isArray(object === null || object === void 0 ? void 0 : object.publicDependency) ? object.publicDependency.map((e) => Number(e)) : [],
      weakDependency: Array.isArray(object === null || object === void 0 ? void 0 : object.weakDependency) ? object.weakDependency.map((e) => Number(e)) : [],
      messageType: Array.isArray(object === null || object === void 0 ? void 0 : object.messageType) ? object.messageType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: Array.isArray(object === null || object === void 0 ? void 0 : object.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      service: Array.isArray(object === null || object === void 0 ? void 0 : object.service) ? object.service.map((e) => ServiceDescriptorProto.fromJSON(e)) : [],
      extension: Array.isArray(object === null || object === void 0 ? void 0 : object.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      options: isSet(object.options) ? FileOptions.fromJSON(object.options) : void 0,
      sourceCodeInfo: isSet(object.sourceCodeInfo) ? SourceCodeInfo.fromJSON(object.sourceCodeInfo) : void 0,
      syntax: isSet(object.syntax) ? String(object.syntax) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.package !== void 0 && (obj.package = message.package);
    if (message.dependency) {
      obj.dependency = message.dependency.map((e) => e);
    } else {
      obj.dependency = [];
    }
    if (message.publicDependency) {
      obj.publicDependency = message.publicDependency.map((e) => Math.round(e));
    } else {
      obj.publicDependency = [];
    }
    if (message.weakDependency) {
      obj.weakDependency = message.weakDependency.map((e) => Math.round(e));
    } else {
      obj.weakDependency = [];
    }
    if (message.messageType) {
      obj.messageType = message.messageType.map((e) => e ? DescriptorProto.toJSON(e) : void 0);
    } else {
      obj.messageType = [];
    }
    if (message.enumType) {
      obj.enumType = message.enumType.map((e) => e ? EnumDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.enumType = [];
    }
    if (message.service) {
      obj.service = message.service.map((e) => e ? ServiceDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.service = [];
    }
    if (message.extension) {
      obj.extension = message.extension.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.extension = [];
    }
    message.options !== void 0 && (obj.options = message.options ? FileOptions.toJSON(message.options) : void 0);
    message.sourceCodeInfo !== void 0 && (obj.sourceCodeInfo = message.sourceCodeInfo ? SourceCodeInfo.toJSON(message.sourceCodeInfo) : void 0);
    message.syntax !== void 0 && (obj.syntax = message.syntax);
    return obj;
  },
  fromPartial(object) {
    var _object$name, _object$package, _object$dependency, _object$publicDepende, _object$weakDependenc, _object$messageType, _object$enumType, _object$service, _object$extension, _object$syntax;
    const message = createBaseFileDescriptorProto();
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.package = (_object$package = object.package) !== null && _object$package !== void 0 ? _object$package : "";
    message.dependency = ((_object$dependency = object.dependency) === null || _object$dependency === void 0 ? void 0 : _object$dependency.map((e) => e)) || [];
    message.publicDependency = ((_object$publicDepende = object.publicDependency) === null || _object$publicDepende === void 0 ? void 0 : _object$publicDepende.map((e) => e)) || [];
    message.weakDependency = ((_object$weakDependenc = object.weakDependency) === null || _object$weakDependenc === void 0 ? void 0 : _object$weakDependenc.map((e) => e)) || [];
    message.messageType = ((_object$messageType = object.messageType) === null || _object$messageType === void 0 ? void 0 : _object$messageType.map((e) => DescriptorProto.fromPartial(e))) || [];
    message.enumType = ((_object$enumType = object.enumType) === null || _object$enumType === void 0 ? void 0 : _object$enumType.map((e) => EnumDescriptorProto.fromPartial(e))) || [];
    message.service = ((_object$service = object.service) === null || _object$service === void 0 ? void 0 : _object$service.map((e) => ServiceDescriptorProto.fromPartial(e))) || [];
    message.extension = ((_object$extension = object.extension) === null || _object$extension === void 0 ? void 0 : _object$extension.map((e) => FieldDescriptorProto.fromPartial(e))) || [];
    message.options = object.options !== void 0 && object.options !== null ? FileOptions.fromPartial(object.options) : void 0;
    message.sourceCodeInfo = object.sourceCodeInfo !== void 0 && object.sourceCodeInfo !== null ? SourceCodeInfo.fromPartial(object.sourceCodeInfo) : void 0;
    message.syntax = (_object$syntax = object.syntax) !== null && _object$syntax !== void 0 ? _object$syntax : "";
    return message;
  }
};
function createBaseDescriptorProto() {
  return {
    name: "",
    field: [],
    extension: [],
    nestedType: [],
    enumType: [],
    extensionRange: [],
    oneofDecl: [],
    options: void 0,
    reservedRange: [],
    reservedName: []
  };
}
var DescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.field) {
      FieldDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.nestedType) {
      DescriptorProto.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.extensionRange) {
      DescriptorProto_ExtensionRange.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.oneofDecl) {
      OneofDescriptorProto.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.options !== void 0) {
      MessageOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      DescriptorProto_ReservedRange.encode(v, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(82).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.field.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 6:
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.nestedType.push(DescriptorProto.decode(reader, reader.uint32()));
          break;
        case 4:
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 5:
          message.extensionRange.push(DescriptorProto_ExtensionRange.decode(reader, reader.uint32()));
          break;
        case 8:
          message.oneofDecl.push(OneofDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 7:
          message.options = MessageOptions.decode(reader, reader.uint32());
          break;
        case 9:
          message.reservedRange.push(DescriptorProto_ReservedRange.decode(reader, reader.uint32()));
          break;
        case 10:
          message.reservedName.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      field: Array.isArray(object === null || object === void 0 ? void 0 : object.field) ? object.field.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      extension: Array.isArray(object === null || object === void 0 ? void 0 : object.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      nestedType: Array.isArray(object === null || object === void 0 ? void 0 : object.nestedType) ? object.nestedType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: Array.isArray(object === null || object === void 0 ? void 0 : object.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      extensionRange: Array.isArray(object === null || object === void 0 ? void 0 : object.extensionRange) ? object.extensionRange.map((e) => DescriptorProto_ExtensionRange.fromJSON(e)) : [],
      oneofDecl: Array.isArray(object === null || object === void 0 ? void 0 : object.oneofDecl) ? object.oneofDecl.map((e) => OneofDescriptorProto.fromJSON(e)) : [],
      options: isSet(object.options) ? MessageOptions.fromJSON(object.options) : void 0,
      reservedRange: Array.isArray(object === null || object === void 0 ? void 0 : object.reservedRange) ? object.reservedRange.map((e) => DescriptorProto_ReservedRange.fromJSON(e)) : [],
      reservedName: Array.isArray(object === null || object === void 0 ? void 0 : object.reservedName) ? object.reservedName.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.field) {
      obj.field = message.field.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.field = [];
    }
    if (message.extension) {
      obj.extension = message.extension.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.extension = [];
    }
    if (message.nestedType) {
      obj.nestedType = message.nestedType.map((e) => e ? DescriptorProto.toJSON(e) : void 0);
    } else {
      obj.nestedType = [];
    }
    if (message.enumType) {
      obj.enumType = message.enumType.map((e) => e ? EnumDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.enumType = [];
    }
    if (message.extensionRange) {
      obj.extensionRange = message.extensionRange.map((e) => e ? DescriptorProto_ExtensionRange.toJSON(e) : void 0);
    } else {
      obj.extensionRange = [];
    }
    if (message.oneofDecl) {
      obj.oneofDecl = message.oneofDecl.map((e) => e ? OneofDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.oneofDecl = [];
    }
    message.options !== void 0 && (obj.options = message.options ? MessageOptions.toJSON(message.options) : void 0);
    if (message.reservedRange) {
      obj.reservedRange = message.reservedRange.map((e) => e ? DescriptorProto_ReservedRange.toJSON(e) : void 0);
    } else {
      obj.reservedRange = [];
    }
    if (message.reservedName) {
      obj.reservedName = message.reservedName.map((e) => e);
    } else {
      obj.reservedName = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$name2, _object$field, _object$extension2, _object$nestedType, _object$enumType2, _object$extensionRang, _object$oneofDecl, _object$reservedRange, _object$reservedName;
    const message = createBaseDescriptorProto();
    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : "";
    message.field = ((_object$field = object.field) === null || _object$field === void 0 ? void 0 : _object$field.map((e) => FieldDescriptorProto.fromPartial(e))) || [];
    message.extension = ((_object$extension2 = object.extension) === null || _object$extension2 === void 0 ? void 0 : _object$extension2.map((e) => FieldDescriptorProto.fromPartial(e))) || [];
    message.nestedType = ((_object$nestedType = object.nestedType) === null || _object$nestedType === void 0 ? void 0 : _object$nestedType.map((e) => DescriptorProto.fromPartial(e))) || [];
    message.enumType = ((_object$enumType2 = object.enumType) === null || _object$enumType2 === void 0 ? void 0 : _object$enumType2.map((e) => EnumDescriptorProto.fromPartial(e))) || [];
    message.extensionRange = ((_object$extensionRang = object.extensionRange) === null || _object$extensionRang === void 0 ? void 0 : _object$extensionRang.map((e) => DescriptorProto_ExtensionRange.fromPartial(e))) || [];
    message.oneofDecl = ((_object$oneofDecl = object.oneofDecl) === null || _object$oneofDecl === void 0 ? void 0 : _object$oneofDecl.map((e) => OneofDescriptorProto.fromPartial(e))) || [];
    message.options = object.options !== void 0 && object.options !== null ? MessageOptions.fromPartial(object.options) : void 0;
    message.reservedRange = ((_object$reservedRange = object.reservedRange) === null || _object$reservedRange === void 0 ? void 0 : _object$reservedRange.map((e) => DescriptorProto_ReservedRange.fromPartial(e))) || [];
    message.reservedName = ((_object$reservedName = object.reservedName) === null || _object$reservedName === void 0 ? void 0 : _object$reservedName.map((e) => e)) || [];
    return message;
  }
};
function createBaseDescriptorProto_ExtensionRange() {
  return {
    start: 0,
    end: 0,
    options: void 0
  };
}
var DescriptorProto_ExtensionRange = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.options !== void 0) {
      ExtensionRangeOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ExtensionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        case 3:
          message.options = ExtensionRangeOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet(object.start) ? Number(object.start) : 0,
      end: isSet(object.end) ? Number(object.end) : 0,
      options: isSet(object.options) ? ExtensionRangeOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    message.options !== void 0 && (obj.options = message.options ? ExtensionRangeOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$start, _object$end;
    const message = createBaseDescriptorProto_ExtensionRange();
    message.start = (_object$start = object.start) !== null && _object$start !== void 0 ? _object$start : 0;
    message.end = (_object$end = object.end) !== null && _object$end !== void 0 ? _object$end : 0;
    message.options = object.options !== void 0 && object.options !== null ? ExtensionRangeOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBaseDescriptorProto_ReservedRange() {
  return {
    start: 0,
    end: 0
  };
}
var DescriptorProto_ReservedRange = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet(object.start) ? Number(object.start) : 0,
      end: isSet(object.end) ? Number(object.end) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    return obj;
  },
  fromPartial(object) {
    var _object$start2, _object$end2;
    const message = createBaseDescriptorProto_ReservedRange();
    message.start = (_object$start2 = object.start) !== null && _object$start2 !== void 0 ? _object$start2 : 0;
    message.end = (_object$end2 = object.end) !== null && _object$end2 !== void 0 ? _object$end2 : 0;
    return message;
  }
};
function createBaseExtensionRangeOptions() {
  return {
    uninterpretedOption: []
  };
}
var ExtensionRangeOptions = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRangeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$uninterpreted;
    const message = createBaseExtensionRangeOptions();
    message.uninterpretedOption = ((_object$uninterpreted = object.uninterpretedOption) === null || _object$uninterpreted === void 0 ? void 0 : _object$uninterpreted.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseFieldDescriptorProto() {
  return {
    name: "",
    number: 0,
    label: 1,
    type: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    options: void 0
  };
}
var FieldDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== 0) {
      writer.uint32(24).int32(message.number);
    }
    if (message.label !== 1) {
      writer.uint32(32).int32(message.label);
    }
    if (message.type !== 1) {
      writer.uint32(40).int32(message.type);
    }
    if (message.typeName !== "") {
      writer.uint32(50).string(message.typeName);
    }
    if (message.extendee !== "") {
      writer.uint32(18).string(message.extendee);
    }
    if (message.defaultValue !== "") {
      writer.uint32(58).string(message.defaultValue);
    }
    if (message.oneofIndex !== 0) {
      writer.uint32(72).int32(message.oneofIndex);
    }
    if (message.jsonName !== "") {
      writer.uint32(82).string(message.jsonName);
    }
    if (message.options !== void 0) {
      FieldOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 3:
          message.number = reader.int32();
          break;
        case 4:
          message.label = reader.int32();
          break;
        case 5:
          message.type = reader.int32();
          break;
        case 6:
          message.typeName = reader.string();
          break;
        case 2:
          message.extendee = reader.string();
          break;
        case 7:
          message.defaultValue = reader.string();
          break;
        case 9:
          message.oneofIndex = reader.int32();
          break;
        case 10:
          message.jsonName = reader.string();
          break;
        case 8:
          message.options = FieldOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      number: isSet(object.number) ? Number(object.number) : 0,
      label: isSet(object.label) ? fieldDescriptorProto_LabelFromJSON(object.label) : 0,
      type: isSet(object.type) ? fieldDescriptorProto_TypeFromJSON(object.type) : 0,
      typeName: isSet(object.typeName) ? String(object.typeName) : "",
      extendee: isSet(object.extendee) ? String(object.extendee) : "",
      defaultValue: isSet(object.defaultValue) ? String(object.defaultValue) : "",
      oneofIndex: isSet(object.oneofIndex) ? Number(object.oneofIndex) : 0,
      jsonName: isSet(object.jsonName) ? String(object.jsonName) : "",
      options: isSet(object.options) ? FieldOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.number !== void 0 && (obj.number = Math.round(message.number));
    message.label !== void 0 && (obj.label = fieldDescriptorProto_LabelToJSON(message.label));
    message.type !== void 0 && (obj.type = fieldDescriptorProto_TypeToJSON(message.type));
    message.typeName !== void 0 && (obj.typeName = message.typeName);
    message.extendee !== void 0 && (obj.extendee = message.extendee);
    message.defaultValue !== void 0 && (obj.defaultValue = message.defaultValue);
    message.oneofIndex !== void 0 && (obj.oneofIndex = Math.round(message.oneofIndex));
    message.jsonName !== void 0 && (obj.jsonName = message.jsonName);
    message.options !== void 0 && (obj.options = message.options ? FieldOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name3, _object$number, _object$label, _object$type, _object$typeName, _object$extendee, _object$defaultValue, _object$oneofIndex, _object$jsonName;
    const message = createBaseFieldDescriptorProto();
    message.name = (_object$name3 = object.name) !== null && _object$name3 !== void 0 ? _object$name3 : "";
    message.number = (_object$number = object.number) !== null && _object$number !== void 0 ? _object$number : 0;
    message.label = (_object$label = object.label) !== null && _object$label !== void 0 ? _object$label : 1;
    message.type = (_object$type = object.type) !== null && _object$type !== void 0 ? _object$type : 1;
    message.typeName = (_object$typeName = object.typeName) !== null && _object$typeName !== void 0 ? _object$typeName : "";
    message.extendee = (_object$extendee = object.extendee) !== null && _object$extendee !== void 0 ? _object$extendee : "";
    message.defaultValue = (_object$defaultValue = object.defaultValue) !== null && _object$defaultValue !== void 0 ? _object$defaultValue : "";
    message.oneofIndex = (_object$oneofIndex = object.oneofIndex) !== null && _object$oneofIndex !== void 0 ? _object$oneofIndex : 0;
    message.jsonName = (_object$jsonName = object.jsonName) !== null && _object$jsonName !== void 0 ? _object$jsonName : "";
    message.options = object.options !== void 0 && object.options !== null ? FieldOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBaseOneofDescriptorProto() {
  return {
    name: "",
    options: void 0
  };
}
var OneofDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.options !== void 0) {
      OneofOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.options = OneofOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      options: isSet(object.options) ? OneofOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.options !== void 0 && (obj.options = message.options ? OneofOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name4;
    const message = createBaseOneofDescriptorProto();
    message.name = (_object$name4 = object.name) !== null && _object$name4 !== void 0 ? _object$name4 : "";
    message.options = object.options !== void 0 && object.options !== null ? OneofOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBaseEnumDescriptorProto() {
  return {
    name: "",
    value: [],
    options: void 0,
    reservedRange: [],
    reservedName: []
  };
}
var EnumDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.value) {
      EnumValueDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      EnumOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      EnumDescriptorProto_EnumReservedRange.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(42).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.value.push(EnumValueDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.options = EnumOptions.decode(reader, reader.uint32());
          break;
        case 4:
          message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.decode(reader, reader.uint32()));
          break;
        case 5:
          message.reservedName.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      value: Array.isArray(object === null || object === void 0 ? void 0 : object.value) ? object.value.map((e) => EnumValueDescriptorProto.fromJSON(e)) : [],
      options: isSet(object.options) ? EnumOptions.fromJSON(object.options) : void 0,
      reservedRange: Array.isArray(object === null || object === void 0 ? void 0 : object.reservedRange) ? object.reservedRange.map((e) => EnumDescriptorProto_EnumReservedRange.fromJSON(e)) : [],
      reservedName: Array.isArray(object === null || object === void 0 ? void 0 : object.reservedName) ? object.reservedName.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.value) {
      obj.value = message.value.map((e) => e ? EnumValueDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.value = [];
    }
    message.options !== void 0 && (obj.options = message.options ? EnumOptions.toJSON(message.options) : void 0);
    if (message.reservedRange) {
      obj.reservedRange = message.reservedRange.map((e) => e ? EnumDescriptorProto_EnumReservedRange.toJSON(e) : void 0);
    } else {
      obj.reservedRange = [];
    }
    if (message.reservedName) {
      obj.reservedName = message.reservedName.map((e) => e);
    } else {
      obj.reservedName = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$name5, _object$value, _object$reservedRange2, _object$reservedName2;
    const message = createBaseEnumDescriptorProto();
    message.name = (_object$name5 = object.name) !== null && _object$name5 !== void 0 ? _object$name5 : "";
    message.value = ((_object$value = object.value) === null || _object$value === void 0 ? void 0 : _object$value.map((e) => EnumValueDescriptorProto.fromPartial(e))) || [];
    message.options = object.options !== void 0 && object.options !== null ? EnumOptions.fromPartial(object.options) : void 0;
    message.reservedRange = ((_object$reservedRange2 = object.reservedRange) === null || _object$reservedRange2 === void 0 ? void 0 : _object$reservedRange2.map((e) => EnumDescriptorProto_EnumReservedRange.fromPartial(e))) || [];
    message.reservedName = ((_object$reservedName2 = object.reservedName) === null || _object$reservedName2 === void 0 ? void 0 : _object$reservedName2.map((e) => e)) || [];
    return message;
  }
};
function createBaseEnumDescriptorProto_EnumReservedRange() {
  return {
    start: 0,
    end: 0
  };
}
var EnumDescriptorProto_EnumReservedRange = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet(object.start) ? Number(object.start) : 0,
      end: isSet(object.end) ? Number(object.end) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    return obj;
  },
  fromPartial(object) {
    var _object$start3, _object$end3;
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    message.start = (_object$start3 = object.start) !== null && _object$start3 !== void 0 ? _object$start3 : 0;
    message.end = (_object$end3 = object.end) !== null && _object$end3 !== void 0 ? _object$end3 : 0;
    return message;
  }
};
function createBaseEnumValueDescriptorProto() {
  return {
    name: "",
    number: 0,
    options: void 0
  };
}
var EnumValueDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== 0) {
      writer.uint32(16).int32(message.number);
    }
    if (message.options !== void 0) {
      EnumValueOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.number = reader.int32();
          break;
        case 3:
          message.options = EnumValueOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      number: isSet(object.number) ? Number(object.number) : 0,
      options: isSet(object.options) ? EnumValueOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.number !== void 0 && (obj.number = Math.round(message.number));
    message.options !== void 0 && (obj.options = message.options ? EnumValueOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name6, _object$number2;
    const message = createBaseEnumValueDescriptorProto();
    message.name = (_object$name6 = object.name) !== null && _object$name6 !== void 0 ? _object$name6 : "";
    message.number = (_object$number2 = object.number) !== null && _object$number2 !== void 0 ? _object$number2 : 0;
    message.options = object.options !== void 0 && object.options !== null ? EnumValueOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBaseServiceDescriptorProto() {
  return {
    name: "",
    method: [],
    options: void 0
  };
}
var ServiceDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.method) {
      MethodDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      ServiceOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.method.push(MethodDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.options = ServiceOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      method: Array.isArray(object === null || object === void 0 ? void 0 : object.method) ? object.method.map((e) => MethodDescriptorProto.fromJSON(e)) : [],
      options: isSet(object.options) ? ServiceOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.method) {
      obj.method = message.method.map((e) => e ? MethodDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.method = [];
    }
    message.options !== void 0 && (obj.options = message.options ? ServiceOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$name7, _object$method;
    const message = createBaseServiceDescriptorProto();
    message.name = (_object$name7 = object.name) !== null && _object$name7 !== void 0 ? _object$name7 : "";
    message.method = ((_object$method = object.method) === null || _object$method === void 0 ? void 0 : _object$method.map((e) => MethodDescriptorProto.fromPartial(e))) || [];
    message.options = object.options !== void 0 && object.options !== null ? ServiceOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBaseMethodDescriptorProto() {
  return {
    name: "",
    inputType: "",
    outputType: "",
    options: void 0,
    clientStreaming: false,
    serverStreaming: false
  };
}
var MethodDescriptorProto = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.inputType !== "") {
      writer.uint32(18).string(message.inputType);
    }
    if (message.outputType !== "") {
      writer.uint32(26).string(message.outputType);
    }
    if (message.options !== void 0) {
      MethodOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    if (message.clientStreaming === true) {
      writer.uint32(40).bool(message.clientStreaming);
    }
    if (message.serverStreaming === true) {
      writer.uint32(48).bool(message.serverStreaming);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.inputType = reader.string();
          break;
        case 3:
          message.outputType = reader.string();
          break;
        case 4:
          message.options = MethodOptions.decode(reader, reader.uint32());
          break;
        case 5:
          message.clientStreaming = reader.bool();
          break;
        case 6:
          message.serverStreaming = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      inputType: isSet(object.inputType) ? String(object.inputType) : "",
      outputType: isSet(object.outputType) ? String(object.outputType) : "",
      options: isSet(object.options) ? MethodOptions.fromJSON(object.options) : void 0,
      clientStreaming: isSet(object.clientStreaming) ? Boolean(object.clientStreaming) : false,
      serverStreaming: isSet(object.serverStreaming) ? Boolean(object.serverStreaming) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.inputType !== void 0 && (obj.inputType = message.inputType);
    message.outputType !== void 0 && (obj.outputType = message.outputType);
    message.options !== void 0 && (obj.options = message.options ? MethodOptions.toJSON(message.options) : void 0);
    message.clientStreaming !== void 0 && (obj.clientStreaming = message.clientStreaming);
    message.serverStreaming !== void 0 && (obj.serverStreaming = message.serverStreaming);
    return obj;
  },
  fromPartial(object) {
    var _object$name8, _object$inputType, _object$outputType, _object$clientStreami, _object$serverStreami;
    const message = createBaseMethodDescriptorProto();
    message.name = (_object$name8 = object.name) !== null && _object$name8 !== void 0 ? _object$name8 : "";
    message.inputType = (_object$inputType = object.inputType) !== null && _object$inputType !== void 0 ? _object$inputType : "";
    message.outputType = (_object$outputType = object.outputType) !== null && _object$outputType !== void 0 ? _object$outputType : "";
    message.options = object.options !== void 0 && object.options !== null ? MethodOptions.fromPartial(object.options) : void 0;
    message.clientStreaming = (_object$clientStreami = object.clientStreaming) !== null && _object$clientStreami !== void 0 ? _object$clientStreami : false;
    message.serverStreaming = (_object$serverStreami = object.serverStreaming) !== null && _object$serverStreami !== void 0 ? _object$serverStreami : false;
    return message;
  }
};
function createBaseFileOptions() {
  return {
    javaPackage: "",
    javaOuterClassname: "",
    javaMultipleFiles: false,
    javaGenerateEqualsAndHash: false,
    javaStringCheckUtf8: false,
    optimizeFor: 1,
    goPackage: "",
    ccGenericServices: false,
    javaGenericServices: false,
    pyGenericServices: false,
    phpGenericServices: false,
    deprecated: false,
    ccEnableArenas: false,
    objcClassPrefix: "",
    csharpNamespace: "",
    swiftPrefix: "",
    phpClassPrefix: "",
    phpNamespace: "",
    phpMetadataNamespace: "",
    rubyPackage: "",
    uninterpretedOption: []
  };
}
var FileOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.javaPackage !== "") {
      writer.uint32(10).string(message.javaPackage);
    }
    if (message.javaOuterClassname !== "") {
      writer.uint32(66).string(message.javaOuterClassname);
    }
    if (message.javaMultipleFiles === true) {
      writer.uint32(80).bool(message.javaMultipleFiles);
    }
    if (message.javaGenerateEqualsAndHash === true) {
      writer.uint32(160).bool(message.javaGenerateEqualsAndHash);
    }
    if (message.javaStringCheckUtf8 === true) {
      writer.uint32(216).bool(message.javaStringCheckUtf8);
    }
    if (message.optimizeFor !== 1) {
      writer.uint32(72).int32(message.optimizeFor);
    }
    if (message.goPackage !== "") {
      writer.uint32(90).string(message.goPackage);
    }
    if (message.ccGenericServices === true) {
      writer.uint32(128).bool(message.ccGenericServices);
    }
    if (message.javaGenericServices === true) {
      writer.uint32(136).bool(message.javaGenericServices);
    }
    if (message.pyGenericServices === true) {
      writer.uint32(144).bool(message.pyGenericServices);
    }
    if (message.phpGenericServices === true) {
      writer.uint32(336).bool(message.phpGenericServices);
    }
    if (message.deprecated === true) {
      writer.uint32(184).bool(message.deprecated);
    }
    if (message.ccEnableArenas === true) {
      writer.uint32(248).bool(message.ccEnableArenas);
    }
    if (message.objcClassPrefix !== "") {
      writer.uint32(290).string(message.objcClassPrefix);
    }
    if (message.csharpNamespace !== "") {
      writer.uint32(298).string(message.csharpNamespace);
    }
    if (message.swiftPrefix !== "") {
      writer.uint32(314).string(message.swiftPrefix);
    }
    if (message.phpClassPrefix !== "") {
      writer.uint32(322).string(message.phpClassPrefix);
    }
    if (message.phpNamespace !== "") {
      writer.uint32(330).string(message.phpNamespace);
    }
    if (message.phpMetadataNamespace !== "") {
      writer.uint32(354).string(message.phpMetadataNamespace);
    }
    if (message.rubyPackage !== "") {
      writer.uint32(362).string(message.rubyPackage);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.javaPackage = reader.string();
          break;
        case 8:
          message.javaOuterClassname = reader.string();
          break;
        case 10:
          message.javaMultipleFiles = reader.bool();
          break;
        case 20:
          message.javaGenerateEqualsAndHash = reader.bool();
          break;
        case 27:
          message.javaStringCheckUtf8 = reader.bool();
          break;
        case 9:
          message.optimizeFor = reader.int32();
          break;
        case 11:
          message.goPackage = reader.string();
          break;
        case 16:
          message.ccGenericServices = reader.bool();
          break;
        case 17:
          message.javaGenericServices = reader.bool();
          break;
        case 18:
          message.pyGenericServices = reader.bool();
          break;
        case 42:
          message.phpGenericServices = reader.bool();
          break;
        case 23:
          message.deprecated = reader.bool();
          break;
        case 31:
          message.ccEnableArenas = reader.bool();
          break;
        case 36:
          message.objcClassPrefix = reader.string();
          break;
        case 37:
          message.csharpNamespace = reader.string();
          break;
        case 39:
          message.swiftPrefix = reader.string();
          break;
        case 40:
          message.phpClassPrefix = reader.string();
          break;
        case 41:
          message.phpNamespace = reader.string();
          break;
        case 44:
          message.phpMetadataNamespace = reader.string();
          break;
        case 45:
          message.rubyPackage = reader.string();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      javaPackage: isSet(object.javaPackage) ? String(object.javaPackage) : "",
      javaOuterClassname: isSet(object.javaOuterClassname) ? String(object.javaOuterClassname) : "",
      javaMultipleFiles: isSet(object.javaMultipleFiles) ? Boolean(object.javaMultipleFiles) : false,
      javaGenerateEqualsAndHash: isSet(object.javaGenerateEqualsAndHash) ? Boolean(object.javaGenerateEqualsAndHash) : false,
      javaStringCheckUtf8: isSet(object.javaStringCheckUtf8) ? Boolean(object.javaStringCheckUtf8) : false,
      optimizeFor: isSet(object.optimizeFor) ? fileOptions_OptimizeModeFromJSON(object.optimizeFor) : 0,
      goPackage: isSet(object.goPackage) ? String(object.goPackage) : "",
      ccGenericServices: isSet(object.ccGenericServices) ? Boolean(object.ccGenericServices) : false,
      javaGenericServices: isSet(object.javaGenericServices) ? Boolean(object.javaGenericServices) : false,
      pyGenericServices: isSet(object.pyGenericServices) ? Boolean(object.pyGenericServices) : false,
      phpGenericServices: isSet(object.phpGenericServices) ? Boolean(object.phpGenericServices) : false,
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      ccEnableArenas: isSet(object.ccEnableArenas) ? Boolean(object.ccEnableArenas) : false,
      objcClassPrefix: isSet(object.objcClassPrefix) ? String(object.objcClassPrefix) : "",
      csharpNamespace: isSet(object.csharpNamespace) ? String(object.csharpNamespace) : "",
      swiftPrefix: isSet(object.swiftPrefix) ? String(object.swiftPrefix) : "",
      phpClassPrefix: isSet(object.phpClassPrefix) ? String(object.phpClassPrefix) : "",
      phpNamespace: isSet(object.phpNamespace) ? String(object.phpNamespace) : "",
      phpMetadataNamespace: isSet(object.phpMetadataNamespace) ? String(object.phpMetadataNamespace) : "",
      rubyPackage: isSet(object.rubyPackage) ? String(object.rubyPackage) : "",
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.javaPackage !== void 0 && (obj.javaPackage = message.javaPackage);
    message.javaOuterClassname !== void 0 && (obj.javaOuterClassname = message.javaOuterClassname);
    message.javaMultipleFiles !== void 0 && (obj.javaMultipleFiles = message.javaMultipleFiles);
    message.javaGenerateEqualsAndHash !== void 0 && (obj.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash);
    message.javaStringCheckUtf8 !== void 0 && (obj.javaStringCheckUtf8 = message.javaStringCheckUtf8);
    message.optimizeFor !== void 0 && (obj.optimizeFor = fileOptions_OptimizeModeToJSON(message.optimizeFor));
    message.goPackage !== void 0 && (obj.goPackage = message.goPackage);
    message.ccGenericServices !== void 0 && (obj.ccGenericServices = message.ccGenericServices);
    message.javaGenericServices !== void 0 && (obj.javaGenericServices = message.javaGenericServices);
    message.pyGenericServices !== void 0 && (obj.pyGenericServices = message.pyGenericServices);
    message.phpGenericServices !== void 0 && (obj.phpGenericServices = message.phpGenericServices);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.ccEnableArenas !== void 0 && (obj.ccEnableArenas = message.ccEnableArenas);
    message.objcClassPrefix !== void 0 && (obj.objcClassPrefix = message.objcClassPrefix);
    message.csharpNamespace !== void 0 && (obj.csharpNamespace = message.csharpNamespace);
    message.swiftPrefix !== void 0 && (obj.swiftPrefix = message.swiftPrefix);
    message.phpClassPrefix !== void 0 && (obj.phpClassPrefix = message.phpClassPrefix);
    message.phpNamespace !== void 0 && (obj.phpNamespace = message.phpNamespace);
    message.phpMetadataNamespace !== void 0 && (obj.phpMetadataNamespace = message.phpMetadataNamespace);
    message.rubyPackage !== void 0 && (obj.rubyPackage = message.rubyPackage);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$javaPackage, _object$javaOuterClas, _object$javaMultipleF, _object$javaGenerateE, _object$javaStringChe, _object$optimizeFor, _object$goPackage, _object$ccGenericServ, _object$javaGenericSe, _object$pyGenericServ, _object$phpGenericSer, _object$deprecated, _object$ccEnableArena, _object$objcClassPref, _object$csharpNamespa, _object$swiftPrefix, _object$phpClassPrefi, _object$phpNamespace, _object$phpMetadataNa, _object$rubyPackage, _object$uninterpreted2;
    const message = createBaseFileOptions();
    message.javaPackage = (_object$javaPackage = object.javaPackage) !== null && _object$javaPackage !== void 0 ? _object$javaPackage : "";
    message.javaOuterClassname = (_object$javaOuterClas = object.javaOuterClassname) !== null && _object$javaOuterClas !== void 0 ? _object$javaOuterClas : "";
    message.javaMultipleFiles = (_object$javaMultipleF = object.javaMultipleFiles) !== null && _object$javaMultipleF !== void 0 ? _object$javaMultipleF : false;
    message.javaGenerateEqualsAndHash = (_object$javaGenerateE = object.javaGenerateEqualsAndHash) !== null && _object$javaGenerateE !== void 0 ? _object$javaGenerateE : false;
    message.javaStringCheckUtf8 = (_object$javaStringChe = object.javaStringCheckUtf8) !== null && _object$javaStringChe !== void 0 ? _object$javaStringChe : false;
    message.optimizeFor = (_object$optimizeFor = object.optimizeFor) !== null && _object$optimizeFor !== void 0 ? _object$optimizeFor : 1;
    message.goPackage = (_object$goPackage = object.goPackage) !== null && _object$goPackage !== void 0 ? _object$goPackage : "";
    message.ccGenericServices = (_object$ccGenericServ = object.ccGenericServices) !== null && _object$ccGenericServ !== void 0 ? _object$ccGenericServ : false;
    message.javaGenericServices = (_object$javaGenericSe = object.javaGenericServices) !== null && _object$javaGenericSe !== void 0 ? _object$javaGenericSe : false;
    message.pyGenericServices = (_object$pyGenericServ = object.pyGenericServices) !== null && _object$pyGenericServ !== void 0 ? _object$pyGenericServ : false;
    message.phpGenericServices = (_object$phpGenericSer = object.phpGenericServices) !== null && _object$phpGenericSer !== void 0 ? _object$phpGenericSer : false;
    message.deprecated = (_object$deprecated = object.deprecated) !== null && _object$deprecated !== void 0 ? _object$deprecated : false;
    message.ccEnableArenas = (_object$ccEnableArena = object.ccEnableArenas) !== null && _object$ccEnableArena !== void 0 ? _object$ccEnableArena : false;
    message.objcClassPrefix = (_object$objcClassPref = object.objcClassPrefix) !== null && _object$objcClassPref !== void 0 ? _object$objcClassPref : "";
    message.csharpNamespace = (_object$csharpNamespa = object.csharpNamespace) !== null && _object$csharpNamespa !== void 0 ? _object$csharpNamespa : "";
    message.swiftPrefix = (_object$swiftPrefix = object.swiftPrefix) !== null && _object$swiftPrefix !== void 0 ? _object$swiftPrefix : "";
    message.phpClassPrefix = (_object$phpClassPrefi = object.phpClassPrefix) !== null && _object$phpClassPrefi !== void 0 ? _object$phpClassPrefi : "";
    message.phpNamespace = (_object$phpNamespace = object.phpNamespace) !== null && _object$phpNamespace !== void 0 ? _object$phpNamespace : "";
    message.phpMetadataNamespace = (_object$phpMetadataNa = object.phpMetadataNamespace) !== null && _object$phpMetadataNa !== void 0 ? _object$phpMetadataNa : "";
    message.rubyPackage = (_object$rubyPackage = object.rubyPackage) !== null && _object$rubyPackage !== void 0 ? _object$rubyPackage : "";
    message.uninterpretedOption = ((_object$uninterpreted2 = object.uninterpretedOption) === null || _object$uninterpreted2 === void 0 ? void 0 : _object$uninterpreted2.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMessageOptions() {
  return {
    messageSetWireFormat: false,
    noStandardDescriptorAccessor: false,
    deprecated: false,
    mapEntry: false,
    uninterpretedOption: []
  };
}
var MessageOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.messageSetWireFormat === true) {
      writer.uint32(8).bool(message.messageSetWireFormat);
    }
    if (message.noStandardDescriptorAccessor === true) {
      writer.uint32(16).bool(message.noStandardDescriptorAccessor);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.mapEntry === true) {
      writer.uint32(56).bool(message.mapEntry);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messageSetWireFormat = reader.bool();
          break;
        case 2:
          message.noStandardDescriptorAccessor = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 7:
          message.mapEntry = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      messageSetWireFormat: isSet(object.messageSetWireFormat) ? Boolean(object.messageSetWireFormat) : false,
      noStandardDescriptorAccessor: isSet(object.noStandardDescriptorAccessor) ? Boolean(object.noStandardDescriptorAccessor) : false,
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      mapEntry: isSet(object.mapEntry) ? Boolean(object.mapEntry) : false,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.messageSetWireFormat !== void 0 && (obj.messageSetWireFormat = message.messageSetWireFormat);
    message.noStandardDescriptorAccessor !== void 0 && (obj.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.mapEntry !== void 0 && (obj.mapEntry = message.mapEntry);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$messageSetWir, _object$noStandardDes, _object$deprecated2, _object$mapEntry, _object$uninterpreted3;
    const message = createBaseMessageOptions();
    message.messageSetWireFormat = (_object$messageSetWir = object.messageSetWireFormat) !== null && _object$messageSetWir !== void 0 ? _object$messageSetWir : false;
    message.noStandardDescriptorAccessor = (_object$noStandardDes = object.noStandardDescriptorAccessor) !== null && _object$noStandardDes !== void 0 ? _object$noStandardDes : false;
    message.deprecated = (_object$deprecated2 = object.deprecated) !== null && _object$deprecated2 !== void 0 ? _object$deprecated2 : false;
    message.mapEntry = (_object$mapEntry = object.mapEntry) !== null && _object$mapEntry !== void 0 ? _object$mapEntry : false;
    message.uninterpretedOption = ((_object$uninterpreted3 = object.uninterpretedOption) === null || _object$uninterpreted3 === void 0 ? void 0 : _object$uninterpreted3.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseFieldOptions() {
  return {
    ctype: 1,
    packed: false,
    jstype: 1,
    lazy: false,
    deprecated: false,
    weak: false,
    uninterpretedOption: []
  };
}
var FieldOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.ctype !== 1) {
      writer.uint32(8).int32(message.ctype);
    }
    if (message.packed === true) {
      writer.uint32(16).bool(message.packed);
    }
    if (message.jstype !== 1) {
      writer.uint32(48).int32(message.jstype);
    }
    if (message.lazy === true) {
      writer.uint32(40).bool(message.lazy);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.weak === true) {
      writer.uint32(80).bool(message.weak);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ctype = reader.int32();
          break;
        case 2:
          message.packed = reader.bool();
          break;
        case 6:
          message.jstype = reader.int32();
          break;
        case 5:
          message.lazy = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 10:
          message.weak = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      ctype: isSet(object.ctype) ? fieldOptions_CTypeFromJSON(object.ctype) : 0,
      packed: isSet(object.packed) ? Boolean(object.packed) : false,
      jstype: isSet(object.jstype) ? fieldOptions_JSTypeFromJSON(object.jstype) : 0,
      lazy: isSet(object.lazy) ? Boolean(object.lazy) : false,
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      weak: isSet(object.weak) ? Boolean(object.weak) : false,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.ctype !== void 0 && (obj.ctype = fieldOptions_CTypeToJSON(message.ctype));
    message.packed !== void 0 && (obj.packed = message.packed);
    message.jstype !== void 0 && (obj.jstype = fieldOptions_JSTypeToJSON(message.jstype));
    message.lazy !== void 0 && (obj.lazy = message.lazy);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.weak !== void 0 && (obj.weak = message.weak);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$ctype, _object$packed, _object$jstype, _object$lazy, _object$deprecated3, _object$weak, _object$uninterpreted4;
    const message = createBaseFieldOptions();
    message.ctype = (_object$ctype = object.ctype) !== null && _object$ctype !== void 0 ? _object$ctype : 1;
    message.packed = (_object$packed = object.packed) !== null && _object$packed !== void 0 ? _object$packed : false;
    message.jstype = (_object$jstype = object.jstype) !== null && _object$jstype !== void 0 ? _object$jstype : 1;
    message.lazy = (_object$lazy = object.lazy) !== null && _object$lazy !== void 0 ? _object$lazy : false;
    message.deprecated = (_object$deprecated3 = object.deprecated) !== null && _object$deprecated3 !== void 0 ? _object$deprecated3 : false;
    message.weak = (_object$weak = object.weak) !== null && _object$weak !== void 0 ? _object$weak : false;
    message.uninterpretedOption = ((_object$uninterpreted4 = object.uninterpretedOption) === null || _object$uninterpreted4 === void 0 ? void 0 : _object$uninterpreted4.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseOneofOptions() {
  return {
    uninterpretedOption: []
  };
}
var OneofOptions = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$uninterpreted5;
    const message = createBaseOneofOptions();
    message.uninterpretedOption = ((_object$uninterpreted5 = object.uninterpretedOption) === null || _object$uninterpreted5 === void 0 ? void 0 : _object$uninterpreted5.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseEnumOptions() {
  return {
    allowAlias: false,
    deprecated: false,
    uninterpretedOption: []
  };
}
var EnumOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.allowAlias === true) {
      writer.uint32(16).bool(message.allowAlias);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.allowAlias = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowAlias: isSet(object.allowAlias) ? Boolean(object.allowAlias) : false,
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.allowAlias !== void 0 && (obj.allowAlias = message.allowAlias);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$allowAlias, _object$deprecated4, _object$uninterpreted6;
    const message = createBaseEnumOptions();
    message.allowAlias = (_object$allowAlias = object.allowAlias) !== null && _object$allowAlias !== void 0 ? _object$allowAlias : false;
    message.deprecated = (_object$deprecated4 = object.deprecated) !== null && _object$deprecated4 !== void 0 ? _object$deprecated4 : false;
    message.uninterpretedOption = ((_object$uninterpreted6 = object.uninterpretedOption) === null || _object$uninterpreted6 === void 0 ? void 0 : _object$uninterpreted6.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseEnumValueOptions() {
  return {
    deprecated: false,
    uninterpretedOption: []
  };
}
var EnumValueOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(8).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.deprecated = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$deprecated5, _object$uninterpreted7;
    const message = createBaseEnumValueOptions();
    message.deprecated = (_object$deprecated5 = object.deprecated) !== null && _object$deprecated5 !== void 0 ? _object$deprecated5 : false;
    message.uninterpretedOption = ((_object$uninterpreted7 = object.uninterpretedOption) === null || _object$uninterpreted7 === void 0 ? void 0 : _object$uninterpreted7.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseServiceOptions() {
  return {
    deprecated: false,
    uninterpretedOption: []
  };
}
var ServiceOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(264).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          message.deprecated = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$deprecated6, _object$uninterpreted8;
    const message = createBaseServiceOptions();
    message.deprecated = (_object$deprecated6 = object.deprecated) !== null && _object$deprecated6 !== void 0 ? _object$deprecated6 : false;
    message.uninterpretedOption = ((_object$uninterpreted8 = object.uninterpretedOption) === null || _object$uninterpreted8 === void 0 ? void 0 : _object$uninterpreted8.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMethodOptions() {
  return {
    deprecated: false,
    idempotencyLevel: 1,
    uninterpretedOption: []
  };
}
var MethodOptions = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(264).bool(message.deprecated);
    }
    if (message.idempotencyLevel !== 1) {
      writer.uint32(272).int32(message.idempotencyLevel);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          message.deprecated = reader.bool();
          break;
        case 34:
          message.idempotencyLevel = reader.int32();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet(object.deprecated) ? Boolean(object.deprecated) : false,
      idempotencyLevel: isSet(object.idempotencyLevel) ? methodOptions_IdempotencyLevelFromJSON(object.idempotencyLevel) : 0,
      uninterpretedOption: Array.isArray(object === null || object === void 0 ? void 0 : object.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.idempotencyLevel !== void 0 && (obj.idempotencyLevel = methodOptions_IdempotencyLevelToJSON(message.idempotencyLevel));
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$deprecated7, _object$idempotencyLe, _object$uninterpreted9;
    const message = createBaseMethodOptions();
    message.deprecated = (_object$deprecated7 = object.deprecated) !== null && _object$deprecated7 !== void 0 ? _object$deprecated7 : false;
    message.idempotencyLevel = (_object$idempotencyLe = object.idempotencyLevel) !== null && _object$idempotencyLe !== void 0 ? _object$idempotencyLe : 1;
    message.uninterpretedOption = ((_object$uninterpreted9 = object.uninterpretedOption) === null || _object$uninterpreted9 === void 0 ? void 0 : _object$uninterpreted9.map((e) => UninterpretedOption.fromPartial(e))) || [];
    return message;
  }
};
function createBaseUninterpretedOption() {
  return {
    name: [],
    identifierValue: "",
    positiveIntValue: BigInt("0"),
    negativeIntValue: BigInt("0"),
    doubleValue: 0,
    stringValue: new Uint8Array(),
    aggregateValue: ""
  };
}
var UninterpretedOption = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.name) {
      UninterpretedOption_NamePart.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.identifierValue !== "") {
      writer.uint32(26).string(message.identifierValue);
    }
    if (message.positiveIntValue !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.positiveIntValue.toString()));
    }
    if (message.negativeIntValue !== BigInt(0)) {
      writer.uint32(40).int64(import_long.default.fromString(message.negativeIntValue.toString()));
    }
    if (message.doubleValue !== 0) {
      writer.uint32(49).double(message.doubleValue);
    }
    if (message.stringValue.length !== 0) {
      writer.uint32(58).bytes(message.stringValue);
    }
    if (message.aggregateValue !== "") {
      writer.uint32(66).string(message.aggregateValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.name.push(UninterpretedOption_NamePart.decode(reader, reader.uint32()));
          break;
        case 3:
          message.identifierValue = reader.string();
          break;
        case 4:
          message.positiveIntValue = BigInt(reader.uint64().toString());
          break;
        case 5:
          message.negativeIntValue = BigInt(reader.int64().toString());
          break;
        case 6:
          message.doubleValue = reader.double();
          break;
        case 7:
          message.stringValue = reader.bytes();
          break;
        case 8:
          message.aggregateValue = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: Array.isArray(object === null || object === void 0 ? void 0 : object.name) ? object.name.map((e) => UninterpretedOption_NamePart.fromJSON(e)) : [],
      identifierValue: isSet(object.identifierValue) ? String(object.identifierValue) : "",
      positiveIntValue: isSet(object.positiveIntValue) ? BigInt(object.positiveIntValue.toString()) : BigInt("0"),
      negativeIntValue: isSet(object.negativeIntValue) ? BigInt(object.negativeIntValue.toString()) : BigInt("0"),
      doubleValue: isSet(object.doubleValue) ? Number(object.doubleValue) : 0,
      stringValue: isSet(object.stringValue) ? bytesFromBase64(object.stringValue) : new Uint8Array(),
      aggregateValue: isSet(object.aggregateValue) ? String(object.aggregateValue) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name) {
      obj.name = message.name.map((e) => e ? UninterpretedOption_NamePart.toJSON(e) : void 0);
    } else {
      obj.name = [];
    }
    message.identifierValue !== void 0 && (obj.identifierValue = message.identifierValue);
    message.positiveIntValue !== void 0 && (obj.positiveIntValue = (message.positiveIntValue || BigInt("0")).toString());
    message.negativeIntValue !== void 0 && (obj.negativeIntValue = (message.negativeIntValue || BigInt("0")).toString());
    message.doubleValue !== void 0 && (obj.doubleValue = message.doubleValue);
    message.stringValue !== void 0 && (obj.stringValue = base64FromBytes(message.stringValue !== void 0 ? message.stringValue : new Uint8Array()));
    message.aggregateValue !== void 0 && (obj.aggregateValue = message.aggregateValue);
    return obj;
  },
  fromPartial(object) {
    var _object$name9, _object$identifierVal, _object$doubleValue, _object$stringValue, _object$aggregateValu;
    const message = createBaseUninterpretedOption();
    message.name = ((_object$name9 = object.name) === null || _object$name9 === void 0 ? void 0 : _object$name9.map((e) => UninterpretedOption_NamePart.fromPartial(e))) || [];
    message.identifierValue = (_object$identifierVal = object.identifierValue) !== null && _object$identifierVal !== void 0 ? _object$identifierVal : "";
    message.positiveIntValue = object.positiveIntValue !== void 0 && object.positiveIntValue !== null ? BigInt(object.positiveIntValue.toString()) : BigInt("0");
    message.negativeIntValue = object.negativeIntValue !== void 0 && object.negativeIntValue !== null ? BigInt(object.negativeIntValue.toString()) : BigInt("0");
    message.doubleValue = (_object$doubleValue = object.doubleValue) !== null && _object$doubleValue !== void 0 ? _object$doubleValue : 0;
    message.stringValue = (_object$stringValue = object.stringValue) !== null && _object$stringValue !== void 0 ? _object$stringValue : new Uint8Array();
    message.aggregateValue = (_object$aggregateValu = object.aggregateValue) !== null && _object$aggregateValu !== void 0 ? _object$aggregateValu : "";
    return message;
  }
};
function createBaseUninterpretedOption_NamePart() {
  return {
    namePart: "",
    isExtension: false
  };
}
var UninterpretedOption_NamePart = {
  encode(message, writer = _m054.Writer.create()) {
    if (message.namePart !== "") {
      writer.uint32(10).string(message.namePart);
    }
    if (message.isExtension === true) {
      writer.uint32(16).bool(message.isExtension);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption_NamePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.namePart = reader.string();
          break;
        case 2:
          message.isExtension = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      namePart: isSet(object.namePart) ? String(object.namePart) : "",
      isExtension: isSet(object.isExtension) ? Boolean(object.isExtension) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.namePart !== void 0 && (obj.namePart = message.namePart);
    message.isExtension !== void 0 && (obj.isExtension = message.isExtension);
    return obj;
  },
  fromPartial(object) {
    var _object$namePart, _object$isExtension;
    const message = createBaseUninterpretedOption_NamePart();
    message.namePart = (_object$namePart = object.namePart) !== null && _object$namePart !== void 0 ? _object$namePart : "";
    message.isExtension = (_object$isExtension = object.isExtension) !== null && _object$isExtension !== void 0 ? _object$isExtension : false;
    return message;
  }
};
function createBaseSourceCodeInfo() {
  return {
    location: []
  };
}
var SourceCodeInfo = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.location) {
      SourceCodeInfo_Location.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location.push(SourceCodeInfo_Location.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: Array.isArray(object === null || object === void 0 ? void 0 : object.location) ? object.location.map((e) => SourceCodeInfo_Location.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.location) {
      obj.location = message.location.map((e) => e ? SourceCodeInfo_Location.toJSON(e) : void 0);
    } else {
      obj.location = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$location;
    const message = createBaseSourceCodeInfo();
    message.location = ((_object$location = object.location) === null || _object$location === void 0 ? void 0 : _object$location.map((e) => SourceCodeInfo_Location.fromPartial(e))) || [];
    return message;
  }
};
function createBaseSourceCodeInfo_Location() {
  return {
    path: [],
    span: [],
    leadingComments: "",
    trailingComments: "",
    leadingDetachedComments: []
  };
}
var SourceCodeInfo_Location = {
  encode(message, writer = _m054.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.span) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.leadingComments !== "") {
      writer.uint32(26).string(message.leadingComments);
    }
    if (message.trailingComments !== "") {
      writer.uint32(34).string(message.trailingComments);
    }
    for (const v of message.leadingDetachedComments) {
      writer.uint32(50).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
          } else {
            message.path.push(reader.int32());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.span.push(reader.int32());
            }
          } else {
            message.span.push(reader.int32());
          }
          break;
        case 3:
          message.leadingComments = reader.string();
          break;
        case 4:
          message.trailingComments = reader.string();
          break;
        case 6:
          message.leadingDetachedComments.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map((e) => Number(e)) : [],
      span: Array.isArray(object === null || object === void 0 ? void 0 : object.span) ? object.span.map((e) => Number(e)) : [],
      leadingComments: isSet(object.leadingComments) ? String(object.leadingComments) : "",
      trailingComments: isSet(object.trailingComments) ? String(object.trailingComments) : "",
      leadingDetachedComments: Array.isArray(object === null || object === void 0 ? void 0 : object.leadingDetachedComments) ? object.leadingDetachedComments.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path) {
      obj.path = message.path.map((e) => Math.round(e));
    } else {
      obj.path = [];
    }
    if (message.span) {
      obj.span = message.span.map((e) => Math.round(e));
    } else {
      obj.span = [];
    }
    message.leadingComments !== void 0 && (obj.leadingComments = message.leadingComments);
    message.trailingComments !== void 0 && (obj.trailingComments = message.trailingComments);
    if (message.leadingDetachedComments) {
      obj.leadingDetachedComments = message.leadingDetachedComments.map((e) => e);
    } else {
      obj.leadingDetachedComments = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$path, _object$span, _object$leadingCommen, _object$trailingComme, _object$leadingDetach;
    const message = createBaseSourceCodeInfo_Location();
    message.path = ((_object$path = object.path) === null || _object$path === void 0 ? void 0 : _object$path.map((e) => e)) || [];
    message.span = ((_object$span = object.span) === null || _object$span === void 0 ? void 0 : _object$span.map((e) => e)) || [];
    message.leadingComments = (_object$leadingCommen = object.leadingComments) !== null && _object$leadingCommen !== void 0 ? _object$leadingCommen : "";
    message.trailingComments = (_object$trailingComme = object.trailingComments) !== null && _object$trailingComme !== void 0 ? _object$trailingComme : "";
    message.leadingDetachedComments = ((_object$leadingDetach = object.leadingDetachedComments) === null || _object$leadingDetach === void 0 ? void 0 : _object$leadingDetach.map((e) => e)) || [];
    return message;
  }
};
function createBaseGeneratedCodeInfo() {
  return {
    annotation: []
  };
}
var GeneratedCodeInfo = {
  encode(message, writer = _m054.Writer.create()) {
    for (const v of message.annotation) {
      GeneratedCodeInfo_Annotation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.annotation.push(GeneratedCodeInfo_Annotation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      annotation: Array.isArray(object === null || object === void 0 ? void 0 : object.annotation) ? object.annotation.map((e) => GeneratedCodeInfo_Annotation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.annotation) {
      obj.annotation = message.annotation.map((e) => e ? GeneratedCodeInfo_Annotation.toJSON(e) : void 0);
    } else {
      obj.annotation = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$annotation;
    const message = createBaseGeneratedCodeInfo();
    message.annotation = ((_object$annotation = object.annotation) === null || _object$annotation === void 0 ? void 0 : _object$annotation.map((e) => GeneratedCodeInfo_Annotation.fromPartial(e))) || [];
    return message;
  }
};
function createBaseGeneratedCodeInfo_Annotation() {
  return {
    path: [],
    sourceFile: "",
    begin: 0,
    end: 0
  };
}
var GeneratedCodeInfo_Annotation = {
  encode(message, writer = _m054.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.sourceFile !== "") {
      writer.uint32(18).string(message.sourceFile);
    }
    if (message.begin !== 0) {
      writer.uint32(24).int32(message.begin);
    }
    if (message.end !== 0) {
      writer.uint32(32).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m054.Reader ? input : new _m054.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo_Annotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
          } else {
            message.path.push(reader.int32());
          }
          break;
        case 2:
          message.sourceFile = reader.string();
          break;
        case 3:
          message.begin = reader.int32();
          break;
        case 4:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map((e) => Number(e)) : [],
      sourceFile: isSet(object.sourceFile) ? String(object.sourceFile) : "",
      begin: isSet(object.begin) ? Number(object.begin) : 0,
      end: isSet(object.end) ? Number(object.end) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path) {
      obj.path = message.path.map((e) => Math.round(e));
    } else {
      obj.path = [];
    }
    message.sourceFile !== void 0 && (obj.sourceFile = message.sourceFile);
    message.begin !== void 0 && (obj.begin = Math.round(message.begin));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    return obj;
  },
  fromPartial(object) {
    var _object$path2, _object$sourceFile, _object$begin, _object$end4;
    const message = createBaseGeneratedCodeInfo_Annotation();
    message.path = ((_object$path2 = object.path) === null || _object$path2 === void 0 ? void 0 : _object$path2.map((e) => e)) || [];
    message.sourceFile = (_object$sourceFile = object.sourceFile) !== null && _object$sourceFile !== void 0 ? _object$sourceFile : "";
    message.begin = (_object$begin = object.begin) !== null && _object$begin !== void 0 ? _object$begin : 0;
    message.end = (_object$end4 = object.end) !== null && _object$end4 !== void 0 ? _object$end4 : 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/reflection/v1/reflection.js
var _m055 = __toESM(require_minimal());
function createBaseFileDescriptorsRequest() {
  return {};
}
var FileDescriptorsRequest = {
  encode(_, writer = _m055.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m055.Reader ? input : new _m055.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseFileDescriptorsRequest();
    return message;
  }
};
function createBaseFileDescriptorsResponse() {
  return {
    files: []
  };
}
var FileDescriptorsResponse = {
  encode(message, writer = _m055.Writer.create()) {
    for (const v of message.files) {
      FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m055.Reader ? input : new _m055.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.files.push(FileDescriptorProto.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      files: Array.isArray(object === null || object === void 0 ? void 0 : object.files) ? object.files.map((e) => FileDescriptorProto.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.files) {
      obj.files = message.files.map((e) => e ? FileDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.files = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$files;
    const message = createBaseFileDescriptorsResponse();
    message.files = ((_object$files = object.files) === null || _object$files === void 0 ? void 0 : _object$files.map((e) => FileDescriptorProto.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/slashing/module/v1/module.js
var module_exports19 = {};
__export(module_exports19, {
  Module: () => Module18
});
var _m056 = __toESM(require_minimal());
function createBaseModule18() {
  return {
    authority: ""
  };
}
var Module18 = {
  encode(message, writer = _m056.Writer.create()) {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m056.Reader ? input : new _m056.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule18();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$authority;
    const message = createBaseModule18();
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/slashing/v1beta1/genesis.js
var genesis_exports16 = {};
__export(genesis_exports16, {
  GenesisState: () => GenesisState15,
  MissedBlock: () => MissedBlock,
  SigningInfo: () => SigningInfo,
  ValidatorMissedBlocks: () => ValidatorMissedBlocks
});
var _m057 = __toESM(require_minimal());
function createBaseGenesisState15() {
  return {
    params: void 0,
    signingInfos: [],
    missedBlocks: []
  };
}
var GenesisState15 = {
  encode(message, writer = _m057.Writer.create()) {
    if (message.params !== void 0) {
      Params6.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.signingInfos) {
      SigningInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.missedBlocks) {
      ValidatorMissedBlocks.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m057.Reader ? input : new _m057.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState15();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params6.decode(reader, reader.uint32());
          break;
        case 2:
          message.signingInfos.push(SigningInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.missedBlocks.push(ValidatorMissedBlocks.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params6.fromJSON(object.params) : void 0,
      signingInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.signingInfos) ? object.signingInfos.map((e) => SigningInfo.fromJSON(e)) : [],
      missedBlocks: Array.isArray(object === null || object === void 0 ? void 0 : object.missedBlocks) ? object.missedBlocks.map((e) => ValidatorMissedBlocks.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params6.toJSON(message.params) : void 0);
    if (message.signingInfos) {
      obj.signingInfos = message.signingInfos.map((e) => e ? SigningInfo.toJSON(e) : void 0);
    } else {
      obj.signingInfos = [];
    }
    if (message.missedBlocks) {
      obj.missedBlocks = message.missedBlocks.map((e) => e ? ValidatorMissedBlocks.toJSON(e) : void 0);
    } else {
      obj.missedBlocks = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$signingInfos, _object$missedBlocks;
    const message = createBaseGenesisState15();
    message.params = object.params !== void 0 && object.params !== null ? Params6.fromPartial(object.params) : void 0;
    message.signingInfos = ((_object$signingInfos = object.signingInfos) === null || _object$signingInfos === void 0 ? void 0 : _object$signingInfos.map((e) => SigningInfo.fromPartial(e))) || [];
    message.missedBlocks = ((_object$missedBlocks = object.missedBlocks) === null || _object$missedBlocks === void 0 ? void 0 : _object$missedBlocks.map((e) => ValidatorMissedBlocks.fromPartial(e))) || [];
    return message;
  }
};
function createBaseSigningInfo() {
  return {
    address: "",
    validatorSigningInfo: void 0
  };
}
var SigningInfo = {
  encode(message, writer = _m057.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.validatorSigningInfo !== void 0) {
      ValidatorSigningInfo.encode(message.validatorSigningInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m057.Reader ? input : new _m057.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSigningInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.validatorSigningInfo = ValidatorSigningInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      validatorSigningInfo: isSet(object.validatorSigningInfo) ? ValidatorSigningInfo.fromJSON(object.validatorSigningInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.validatorSigningInfo !== void 0 && (obj.validatorSigningInfo = message.validatorSigningInfo ? ValidatorSigningInfo.toJSON(message.validatorSigningInfo) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$address;
    const message = createBaseSigningInfo();
    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : "";
    message.validatorSigningInfo = object.validatorSigningInfo !== void 0 && object.validatorSigningInfo !== null ? ValidatorSigningInfo.fromPartial(object.validatorSigningInfo) : void 0;
    return message;
  }
};
function createBaseValidatorMissedBlocks() {
  return {
    address: "",
    missedBlocks: []
  };
}
var ValidatorMissedBlocks = {
  encode(message, writer = _m057.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.missedBlocks) {
      MissedBlock.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m057.Reader ? input : new _m057.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorMissedBlocks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.missedBlocks.push(MissedBlock.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      missedBlocks: Array.isArray(object === null || object === void 0 ? void 0 : object.missedBlocks) ? object.missedBlocks.map((e) => MissedBlock.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    if (message.missedBlocks) {
      obj.missedBlocks = message.missedBlocks.map((e) => e ? MissedBlock.toJSON(e) : void 0);
    } else {
      obj.missedBlocks = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$address2, _object$missedBlocks2;
    const message = createBaseValidatorMissedBlocks();
    message.address = (_object$address2 = object.address) !== null && _object$address2 !== void 0 ? _object$address2 : "";
    message.missedBlocks = ((_object$missedBlocks2 = object.missedBlocks) === null || _object$missedBlocks2 === void 0 ? void 0 : _object$missedBlocks2.map((e) => MissedBlock.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMissedBlock() {
  return {
    index: BigInt("0"),
    missed: false
  };
}
var MissedBlock = {
  encode(message, writer = _m057.Writer.create()) {
    if (message.index !== BigInt(0)) {
      writer.uint32(8).int64(import_long.default.fromString(message.index.toString()));
    }
    if (message.missed === true) {
      writer.uint32(16).bool(message.missed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m057.Reader ? input : new _m057.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMissedBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = BigInt(reader.int64().toString());
          break;
        case 2:
          message.missed = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      index: isSet(object.index) ? BigInt(object.index.toString()) : BigInt("0"),
      missed: isSet(object.missed) ? Boolean(object.missed) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.index !== void 0 && (obj.index = (message.index || BigInt("0")).toString());
    message.missed !== void 0 && (obj.missed = message.missed);
    return obj;
  },
  fromPartial(object) {
    var _object$missed;
    const message = createBaseMissedBlock();
    message.index = object.index !== void 0 && object.index !== null ? BigInt(object.index.toString()) : BigInt("0");
    message.missed = (_object$missed = object.missed) !== null && _object$missed !== void 0 ? _object$missed : false;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/staking/module/v1/module.js
var module_exports20 = {};
__export(module_exports20, {
  Module: () => Module19
});
var _m058 = __toESM(require_minimal());
function createBaseModule19() {
  return {
    hooksOrder: [],
    authority: ""
  };
}
var Module19 = {
  encode(message, writer = _m058.Writer.create()) {
    for (const v of message.hooksOrder) {
      writer.uint32(10).string(v);
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m058.Reader ? input : new _m058.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule19();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hooksOrder.push(reader.string());
          break;
        case 2:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hooksOrder: Array.isArray(object === null || object === void 0 ? void 0 : object.hooksOrder) ? object.hooksOrder.map((e) => String(e)) : [],
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.hooksOrder) {
      obj.hooksOrder = message.hooksOrder.map((e) => e);
    } else {
      obj.hooksOrder = [];
    }
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$hooksOrder, _object$authority;
    const message = createBaseModule19();
    message.hooksOrder = ((_object$hooksOrder = object.hooksOrder) === null || _object$hooksOrder === void 0 ? void 0 : _object$hooksOrder.map((e) => e)) || [];
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/staking/v1beta1/authz.js
var authz_exports3 = {};
__export(authz_exports3, {
  AuthorizationType: () => AuthorizationType,
  AuthorizationTypeSDKType: () => AuthorizationTypeSDKType,
  StakeAuthorization: () => StakeAuthorization,
  StakeAuthorization_Validators: () => StakeAuthorization_Validators,
  authorizationTypeFromJSON: () => authorizationTypeFromJSON,
  authorizationTypeToJSON: () => authorizationTypeToJSON
});
var _m059 = __toESM(require_minimal());
var AuthorizationType = function(AuthorizationType2) {
  AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNSPECIFIED"] = 0] = "AUTHORIZATION_TYPE_UNSPECIFIED";
  AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_DELEGATE"] = 1] = "AUTHORIZATION_TYPE_DELEGATE";
  AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNDELEGATE"] = 2] = "AUTHORIZATION_TYPE_UNDELEGATE";
  AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_REDELEGATE"] = 3] = "AUTHORIZATION_TYPE_REDELEGATE";
  AuthorizationType2[AuthorizationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return AuthorizationType2;
}({});
var AuthorizationTypeSDKType = AuthorizationType;
function authorizationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "AUTHORIZATION_TYPE_UNSPECIFIED":
      return AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED;
    case 1:
    case "AUTHORIZATION_TYPE_DELEGATE":
      return AuthorizationType.AUTHORIZATION_TYPE_DELEGATE;
    case 2:
    case "AUTHORIZATION_TYPE_UNDELEGATE":
      return AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE;
    case 3:
    case "AUTHORIZATION_TYPE_REDELEGATE":
      return AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthorizationType.UNRECOGNIZED;
  }
}
function authorizationTypeToJSON(object) {
  switch (object) {
    case AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED:
      return "AUTHORIZATION_TYPE_UNSPECIFIED";
    case AuthorizationType.AUTHORIZATION_TYPE_DELEGATE:
      return "AUTHORIZATION_TYPE_DELEGATE";
    case AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE:
      return "AUTHORIZATION_TYPE_UNDELEGATE";
    case AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE:
      return "AUTHORIZATION_TYPE_REDELEGATE";
    case AuthorizationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseStakeAuthorization() {
  return {
    maxTokens: void 0,
    allowList: void 0,
    denyList: void 0,
    authorizationType: 0
  };
}
var StakeAuthorization = {
  encode(message, writer = _m059.Writer.create()) {
    if (message.maxTokens !== void 0) {
      Coin.encode(message.maxTokens, writer.uint32(10).fork()).ldelim();
    }
    if (message.allowList !== void 0) {
      StakeAuthorization_Validators.encode(message.allowList, writer.uint32(18).fork()).ldelim();
    }
    if (message.denyList !== void 0) {
      StakeAuthorization_Validators.encode(message.denyList, writer.uint32(26).fork()).ldelim();
    }
    if (message.authorizationType !== 0) {
      writer.uint32(32).int32(message.authorizationType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m059.Reader ? input : new _m059.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStakeAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxTokens = Coin.decode(reader, reader.uint32());
          break;
        case 2:
          message.allowList = StakeAuthorization_Validators.decode(reader, reader.uint32());
          break;
        case 3:
          message.denyList = StakeAuthorization_Validators.decode(reader, reader.uint32());
          break;
        case 4:
          message.authorizationType = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxTokens: isSet(object.maxTokens) ? Coin.fromJSON(object.maxTokens) : void 0,
      allowList: isSet(object.allowList) ? StakeAuthorization_Validators.fromJSON(object.allowList) : void 0,
      denyList: isSet(object.denyList) ? StakeAuthorization_Validators.fromJSON(object.denyList) : void 0,
      authorizationType: isSet(object.authorizationType) ? authorizationTypeFromJSON(object.authorizationType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.maxTokens !== void 0 && (obj.maxTokens = message.maxTokens ? Coin.toJSON(message.maxTokens) : void 0);
    message.allowList !== void 0 && (obj.allowList = message.allowList ? StakeAuthorization_Validators.toJSON(message.allowList) : void 0);
    message.denyList !== void 0 && (obj.denyList = message.denyList ? StakeAuthorization_Validators.toJSON(message.denyList) : void 0);
    message.authorizationType !== void 0 && (obj.authorizationType = authorizationTypeToJSON(message.authorizationType));
    return obj;
  },
  fromPartial(object) {
    var _object$authorization;
    const message = createBaseStakeAuthorization();
    message.maxTokens = object.maxTokens !== void 0 && object.maxTokens !== null ? Coin.fromPartial(object.maxTokens) : void 0;
    message.allowList = object.allowList !== void 0 && object.allowList !== null ? StakeAuthorization_Validators.fromPartial(object.allowList) : void 0;
    message.denyList = object.denyList !== void 0 && object.denyList !== null ? StakeAuthorization_Validators.fromPartial(object.denyList) : void 0;
    message.authorizationType = (_object$authorization = object.authorizationType) !== null && _object$authorization !== void 0 ? _object$authorization : 0;
    return message;
  }
};
function createBaseStakeAuthorization_Validators() {
  return {
    address: []
  };
}
var StakeAuthorization_Validators = {
  encode(message, writer = _m059.Writer.create()) {
    for (const v of message.address) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m059.Reader ? input : new _m059.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStakeAuthorization_Validators();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: Array.isArray(object === null || object === void 0 ? void 0 : object.address) ? object.address.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.address) {
      obj.address = message.address.map((e) => e);
    } else {
      obj.address = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$address;
    const message = createBaseStakeAuthorization_Validators();
    message.address = ((_object$address = object.address) === null || _object$address === void 0 ? void 0 : _object$address.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/staking/v1beta1/genesis.js
var genesis_exports17 = {};
__export(genesis_exports17, {
  GenesisState: () => GenesisState16,
  LastValidatorPower: () => LastValidatorPower
});
var _m060 = __toESM(require_minimal());
function createBaseGenesisState16() {
  return {
    params: void 0,
    lastTotalPower: new Uint8Array(),
    lastValidatorPowers: [],
    validators: [],
    delegations: [],
    unbondingDelegations: [],
    redelegations: [],
    exported: false
  };
}
var GenesisState16 = {
  encode(message, writer = _m060.Writer.create()) {
    if (message.params !== void 0) {
      Params7.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastTotalPower.length !== 0) {
      writer.uint32(18).bytes(message.lastTotalPower);
    }
    for (const v of message.lastValidatorPowers) {
      LastValidatorPower.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.validators) {
      Validator.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.delegations) {
      Delegation.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.unbondingDelegations) {
      UnbondingDelegation.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.redelegations) {
      Redelegation.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.exported === true) {
      writer.uint32(64).bool(message.exported);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m060.Reader ? input : new _m060.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params7.decode(reader, reader.uint32());
          break;
        case 2:
          message.lastTotalPower = reader.bytes();
          break;
        case 3:
          message.lastValidatorPowers.push(LastValidatorPower.decode(reader, reader.uint32()));
          break;
        case 4:
          message.validators.push(Validator.decode(reader, reader.uint32()));
          break;
        case 5:
          message.delegations.push(Delegation.decode(reader, reader.uint32()));
          break;
        case 6:
          message.unbondingDelegations.push(UnbondingDelegation.decode(reader, reader.uint32()));
          break;
        case 7:
          message.redelegations.push(Redelegation.decode(reader, reader.uint32()));
          break;
        case 8:
          message.exported = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params7.fromJSON(object.params) : void 0,
      lastTotalPower: isSet(object.lastTotalPower) ? bytesFromBase64(object.lastTotalPower) : new Uint8Array(),
      lastValidatorPowers: Array.isArray(object === null || object === void 0 ? void 0 : object.lastValidatorPowers) ? object.lastValidatorPowers.map((e) => LastValidatorPower.fromJSON(e)) : [],
      validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => Validator.fromJSON(e)) : [],
      delegations: Array.isArray(object === null || object === void 0 ? void 0 : object.delegations) ? object.delegations.map((e) => Delegation.fromJSON(e)) : [],
      unbondingDelegations: Array.isArray(object === null || object === void 0 ? void 0 : object.unbondingDelegations) ? object.unbondingDelegations.map((e) => UnbondingDelegation.fromJSON(e)) : [],
      redelegations: Array.isArray(object === null || object === void 0 ? void 0 : object.redelegations) ? object.redelegations.map((e) => Redelegation.fromJSON(e)) : [],
      exported: isSet(object.exported) ? Boolean(object.exported) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params7.toJSON(message.params) : void 0);
    message.lastTotalPower !== void 0 && (obj.lastTotalPower = base64FromBytes(message.lastTotalPower !== void 0 ? message.lastTotalPower : new Uint8Array()));
    if (message.lastValidatorPowers) {
      obj.lastValidatorPowers = message.lastValidatorPowers.map((e) => e ? LastValidatorPower.toJSON(e) : void 0);
    } else {
      obj.lastValidatorPowers = [];
    }
    if (message.validators) {
      obj.validators = message.validators.map((e) => e ? Validator.toJSON(e) : void 0);
    } else {
      obj.validators = [];
    }
    if (message.delegations) {
      obj.delegations = message.delegations.map((e) => e ? Delegation.toJSON(e) : void 0);
    } else {
      obj.delegations = [];
    }
    if (message.unbondingDelegations) {
      obj.unbondingDelegations = message.unbondingDelegations.map((e) => e ? UnbondingDelegation.toJSON(e) : void 0);
    } else {
      obj.unbondingDelegations = [];
    }
    if (message.redelegations) {
      obj.redelegations = message.redelegations.map((e) => e ? Redelegation.toJSON(e) : void 0);
    } else {
      obj.redelegations = [];
    }
    message.exported !== void 0 && (obj.exported = message.exported);
    return obj;
  },
  fromPartial(object) {
    var _object$lastTotalPowe, _object$lastValidator, _object$validators, _object$delegations, _object$unbondingDele, _object$redelegations, _object$exported;
    const message = createBaseGenesisState16();
    message.params = object.params !== void 0 && object.params !== null ? Params7.fromPartial(object.params) : void 0;
    message.lastTotalPower = (_object$lastTotalPowe = object.lastTotalPower) !== null && _object$lastTotalPowe !== void 0 ? _object$lastTotalPowe : new Uint8Array();
    message.lastValidatorPowers = ((_object$lastValidator = object.lastValidatorPowers) === null || _object$lastValidator === void 0 ? void 0 : _object$lastValidator.map((e) => LastValidatorPower.fromPartial(e))) || [];
    message.validators = ((_object$validators = object.validators) === null || _object$validators === void 0 ? void 0 : _object$validators.map((e) => Validator.fromPartial(e))) || [];
    message.delegations = ((_object$delegations = object.delegations) === null || _object$delegations === void 0 ? void 0 : _object$delegations.map((e) => Delegation.fromPartial(e))) || [];
    message.unbondingDelegations = ((_object$unbondingDele = object.unbondingDelegations) === null || _object$unbondingDele === void 0 ? void 0 : _object$unbondingDele.map((e) => UnbondingDelegation.fromPartial(e))) || [];
    message.redelegations = ((_object$redelegations = object.redelegations) === null || _object$redelegations === void 0 ? void 0 : _object$redelegations.map((e) => Redelegation.fromPartial(e))) || [];
    message.exported = (_object$exported = object.exported) !== null && _object$exported !== void 0 ? _object$exported : false;
    return message;
  }
};
function createBaseLastValidatorPower() {
  return {
    address: "",
    power: BigInt("0")
  };
}
var LastValidatorPower = {
  encode(message, writer = _m060.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.power !== BigInt(0)) {
      writer.uint32(16).int64(import_long.default.fromString(message.power.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m060.Reader ? input : new _m060.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLastValidatorPower();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.power = BigInt(reader.int64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      power: isSet(object.power) ? BigInt(object.power.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.power !== void 0 && (obj.power = (message.power || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$address;
    const message = createBaseLastValidatorPower();
    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : "";
    message.power = object.power !== void 0 && object.power !== null ? BigInt(object.power.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/tx/config/v1/config.js
var config_exports2 = {};
__export(config_exports2, {
  Config: () => Config
});
var _m061 = __toESM(require_minimal());
function createBaseConfig() {
  return {
    skipAnteHandler: false,
    skipPostHandler: false
  };
}
var Config = {
  encode(message, writer = _m061.Writer.create()) {
    if (message.skipAnteHandler === true) {
      writer.uint32(8).bool(message.skipAnteHandler);
    }
    if (message.skipPostHandler === true) {
      writer.uint32(16).bool(message.skipPostHandler);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m061.Reader ? input : new _m061.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.skipAnteHandler = reader.bool();
          break;
        case 2:
          message.skipPostHandler = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      skipAnteHandler: isSet(object.skipAnteHandler) ? Boolean(object.skipAnteHandler) : false,
      skipPostHandler: isSet(object.skipPostHandler) ? Boolean(object.skipPostHandler) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.skipAnteHandler !== void 0 && (obj.skipAnteHandler = message.skipAnteHandler);
    message.skipPostHandler !== void 0 && (obj.skipPostHandler = message.skipPostHandler);
    return obj;
  },
  fromPartial(object) {
    var _object$skipAnteHandl, _object$skipPostHandl;
    const message = createBaseConfig();
    message.skipAnteHandler = (_object$skipAnteHandl = object.skipAnteHandler) !== null && _object$skipAnteHandl !== void 0 ? _object$skipAnteHandl : false;
    message.skipPostHandler = (_object$skipPostHandl = object.skipPostHandler) !== null && _object$skipPostHandl !== void 0 ? _object$skipPostHandl : false;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/upgrade/module/v1/module.js
var module_exports21 = {};
__export(module_exports21, {
  Module: () => Module20
});
var _m062 = __toESM(require_minimal());
function createBaseModule20() {
  return {
    authority: ""
  };
}
var Module20 = {
  encode(message, writer = _m062.Writer.create()) {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m062.Reader ? input : new _m062.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule20();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authority: isSet(object.authority) ? String(object.authority) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.authority !== void 0 && (obj.authority = message.authority);
    return obj;
  },
  fromPartial(object) {
    var _object$authority;
    const message = createBaseModule20();
    message.authority = (_object$authority = object.authority) !== null && _object$authority !== void 0 ? _object$authority : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/vesting/module/v1/module.js
var module_exports22 = {};
__export(module_exports22, {
  Module: () => Module21
});
var _m063 = __toESM(require_minimal());
function createBaseModule21() {
  return {};
}
var Module21 = {
  encode(_, writer = _m063.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m063.Reader ? input : new _m063.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModule21();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseModule21();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/auth/v1beta1/tx.amino.js
var tx_amino_exports = {};
__export(tx_amino_exports, {
  AminoConverter: () => AminoConverter
});
var AminoConverter = {
  "/cosmos.auth.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/auth/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          max_memo_characters: params.maxMemoCharacters.toString(),
          tx_sig_limit: params.txSigLimit.toString(),
          tx_size_cost_per_byte: params.txSizeCostPerByte.toString(),
          sig_verify_cost_ed25519: params.sigVerifyCostEd25519.toString(),
          sig_verify_cost_secp256k1: params.sigVerifyCostSecp256k1.toString()
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          maxMemoCharacters: BigInt(params.max_memo_characters),
          txSigLimit: BigInt(params.tx_sig_limit),
          txSizeCostPerByte: BigInt(params.tx_size_cost_per_byte),
          sigVerifyCostEd25519: BigInt(params.sig_verify_cost_ed25519),
          sigVerifyCostSecp256k1: BigInt(params.sig_verify_cost_secp256k1)
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/authz/v1beta1/tx.amino.js
var tx_amino_exports2 = {};
__export(tx_amino_exports2, {
  AminoConverter: () => AminoConverter2
});
var AminoConverter2 = {
  "/cosmos.authz.v1beta1.MsgGrant": {
    aminoType: "cosmos-sdk/MsgGrant",
    toAmino: ({
      granter,
      grantee,
      grant
    }) => {
      return {
        granter,
        grantee,
        grant: {
          authorization: {
            type_url: grant.authorization.typeUrl,
            value: grant.authorization.value
          },
          expiration: grant.expiration
        }
      };
    },
    fromAmino: ({
      granter,
      grantee,
      grant
    }) => {
      return {
        granter,
        grantee,
        grant: {
          authorization: {
            typeUrl: grant.authorization.type_url,
            value: grant.authorization.value
          },
          expiration: grant.expiration
        }
      };
    }
  },
  "/cosmos.authz.v1beta1.MsgExec": {
    aminoType: "cosmos-sdk/MsgExec",
    toAmino: ({
      grantee,
      msgs
    }) => {
      return {
        grantee,
        msgs: msgs.map((el0) => ({
          type_url: el0.typeUrl,
          value: el0.value
        }))
      };
    },
    fromAmino: ({
      grantee,
      msgs
    }) => {
      return {
        grantee,
        msgs: msgs.map((el0) => ({
          typeUrl: el0.type_url,
          value: el0.value
        }))
      };
    }
  },
  "/cosmos.authz.v1beta1.MsgRevoke": {
    aminoType: "cosmos-sdk/MsgRevoke",
    toAmino: ({
      granter,
      grantee,
      msgTypeUrl
    }) => {
      return {
        granter,
        grantee,
        msg_type_url: msgTypeUrl
      };
    },
    fromAmino: ({
      granter,
      grantee,
      msg_type_url
    }) => {
      return {
        granter,
        grantee,
        msgTypeUrl: msg_type_url
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bank/v1beta1/tx.amino.js
var tx_amino_exports3 = {};
__export(tx_amino_exports3, {
  AminoConverter: () => AminoConverter3
});
var AminoConverter3 = {
  "/cosmos.bank.v1beta1.MsgSend": {
    aminoType: "cosmos-sdk/MsgSend",
    toAmino: ({
      fromAddress,
      toAddress,
      amount
    }) => {
      return {
        from_address: fromAddress,
        to_address: toAddress,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      from_address,
      to_address,
      amount
    }) => {
      return {
        fromAddress: from_address,
        toAddress: to_address,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  },
  "/cosmos.bank.v1beta1.MsgMultiSend": {
    aminoType: "cosmos-sdk/MsgMultiSend",
    toAmino: ({
      inputs,
      outputs
    }) => {
      return {
        inputs: inputs.map((el0) => ({
          address: el0.address,
          coins: el0.coins.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        })),
        outputs: outputs.map((el0) => ({
          address: el0.address,
          coins: el0.coins.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        }))
      };
    },
    fromAmino: ({
      inputs,
      outputs
    }) => {
      return {
        inputs: inputs.map((el0) => ({
          address: el0.address,
          coins: el0.coins.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        })),
        outputs: outputs.map((el0) => ({
          address: el0.address,
          coins: el0.coins.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        }))
      };
    }
  },
  "/cosmos.bank.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/bank/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          send_enabled: params.sendEnabled.map((el0) => ({
            denom: el0.denom,
            enabled: el0.enabled
          })),
          default_send_enabled: params.defaultSendEnabled
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          sendEnabled: params.send_enabled.map((el1) => ({
            denom: el1.denom,
            enabled: el1.enabled
          })),
          defaultSendEnabled: params.default_send_enabled
        }
      };
    }
  },
  "/cosmos.bank.v1beta1.MsgSetSendEnabled": {
    aminoType: "cosmos-sdk/MsgSetSendEnabled",
    toAmino: ({
      authority,
      sendEnabled,
      useDefaultFor
    }) => {
      return {
        authority,
        send_enabled: sendEnabled.map((el0) => ({
          denom: el0.denom,
          enabled: el0.enabled
        })),
        use_default_for: useDefaultFor
      };
    },
    fromAmino: ({
      authority,
      send_enabled,
      use_default_for
    }) => {
      return {
        authority,
        sendEnabled: send_enabled.map((el0) => ({
          denom: el0.denom,
          enabled: el0.enabled
        })),
        useDefaultFor: use_default_for
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/consensus/v1/tx.amino.js
var tx_amino_exports4 = {};
__export(tx_amino_exports4, {
  AminoConverter: () => AminoConverter4
});
var AminoConverter4 = {
  "/cosmos.consensus.v1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/MsgUpdateParams",
    toAmino: ({
      authority,
      block,
      evidence,
      validator
    }) => {
      return {
        authority,
        block: {
          max_bytes: block.maxBytes.toString(),
          max_gas: block.maxGas.toString()
        },
        evidence: {
          max_age_num_blocks: evidence.maxAgeNumBlocks.toString(),
          max_age_duration: (evidence.maxAgeDuration * 1e9).toString(),
          max_bytes: evidence.maxBytes.toString()
        },
        validator: {
          pub_key_types: validator.pubKeyTypes
        }
      };
    },
    fromAmino: ({
      authority,
      block,
      evidence,
      validator
    }) => {
      return {
        authority,
        block: {
          maxBytes: BigInt(block.max_bytes),
          maxGas: BigInt(block.max_gas)
        },
        evidence: {
          maxAgeNumBlocks: BigInt(evidence.max_age_num_blocks),
          maxAgeDuration: {
            seconds: BigInt(Math.floor(parseInt(evidence.max_age_duration) / 1e9)),
            nanos: parseInt(evidence.max_age_duration) % 1e9
          },
          maxBytes: BigInt(evidence.max_bytes)
        },
        validator: {
          pubKeyTypes: validator.pub_key_types
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crisis/v1beta1/tx.amino.js
var tx_amino_exports5 = {};
__export(tx_amino_exports5, {
  AminoConverter: () => AminoConverter5
});
var AminoConverter5 = {
  "/cosmos.crisis.v1beta1.MsgVerifyInvariant": {
    aminoType: "cosmos-sdk/MsgVerifyInvariant",
    toAmino: ({
      sender,
      invariantModuleName,
      invariantRoute
    }) => {
      return {
        sender,
        invariant_module_name: invariantModuleName,
        invariant_route: invariantRoute
      };
    },
    fromAmino: ({
      sender,
      invariant_module_name,
      invariant_route
    }) => {
      return {
        sender,
        invariantModuleName: invariant_module_name,
        invariantRoute: invariant_route
      };
    }
  },
  "/cosmos.crisis.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/crisis/MsgUpdateParams",
    toAmino: ({
      authority,
      constantFee
    }) => {
      return {
        authority,
        constant_fee: {
          denom: constantFee.denom,
          amount: constantFee.amount
        }
      };
    },
    fromAmino: ({
      authority,
      constant_fee
    }) => {
      return {
        authority,
        constantFee: {
          denom: constant_fee.denom,
          amount: constant_fee.amount
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/distribution/v1beta1/tx.amino.js
var tx_amino_exports6 = {};
__export(tx_amino_exports6, {
  AminoConverter: () => AminoConverter6
});
var AminoConverter6 = {
  "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
    aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
    toAmino: ({
      delegatorAddress,
      withdrawAddress
    }) => {
      return {
        delegator_address: delegatorAddress,
        withdraw_address: withdrawAddress
      };
    },
    fromAmino: ({
      delegator_address,
      withdraw_address
    }) => {
      return {
        delegatorAddress: delegator_address,
        withdrawAddress: withdraw_address
      };
    }
  },
  "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
    aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
    toAmino: ({
      delegatorAddress,
      validatorAddress
    }) => {
      return {
        delegator_address: delegatorAddress,
        validator_address: validatorAddress
      };
    },
    fromAmino: ({
      delegator_address,
      validator_address
    }) => {
      return {
        delegatorAddress: delegator_address,
        validatorAddress: validator_address
      };
    }
  },
  "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
    aminoType: "cosmos-sdk/MsgWithdrawValCommission",
    toAmino: ({
      validatorAddress
    }) => {
      return {
        validator_address: validatorAddress
      };
    },
    fromAmino: ({
      validator_address
    }) => {
      return {
        validatorAddress: validator_address
      };
    }
  },
  "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
    aminoType: "cosmos-sdk/MsgFundCommunityPool",
    toAmino: ({
      amount,
      depositor
    }) => {
      return {
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        depositor
      };
    },
    fromAmino: ({
      amount,
      depositor
    }) => {
      return {
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        depositor
      };
    }
  },
  "/cosmos.distribution.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/distribution/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          community_tax: params.communityTax,
          base_proposer_reward: params.baseProposerReward,
          bonus_proposer_reward: params.bonusProposerReward,
          withdraw_addr_enabled: params.withdrawAddrEnabled
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          communityTax: params.community_tax,
          baseProposerReward: params.base_proposer_reward,
          bonusProposerReward: params.bonus_proposer_reward,
          withdrawAddrEnabled: params.withdraw_addr_enabled
        }
      };
    }
  },
  "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend": {
    aminoType: "cosmos-sdk/distr/MsgCommunityPoolSpend",
    toAmino: ({
      authority,
      recipient,
      amount
    }) => {
      return {
        authority,
        recipient,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      authority,
      recipient,
      amount
    }) => {
      return {
        authority,
        recipient,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/evidence/v1beta1/tx.amino.js
var tx_amino_exports7 = {};
__export(tx_amino_exports7, {
  AminoConverter: () => AminoConverter7
});
var AminoConverter7 = {
  "/cosmos.evidence.v1beta1.MsgSubmitEvidence": {
    aminoType: "cosmos-sdk/MsgSubmitEvidence",
    toAmino: ({
      submitter,
      evidence
    }) => {
      return {
        submitter,
        evidence: {
          type_url: evidence.typeUrl,
          value: evidence.value
        }
      };
    },
    fromAmino: ({
      submitter,
      evidence
    }) => {
      return {
        submitter,
        evidence: {
          typeUrl: evidence.type_url,
          value: evidence.value
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/feegrant/v1beta1/tx.amino.js
var tx_amino_exports8 = {};
__export(tx_amino_exports8, {
  AminoConverter: () => AminoConverter8
});
var AminoConverter8 = {
  "/cosmos.feegrant.v1beta1.MsgGrantAllowance": {
    aminoType: "cosmos-sdk/MsgGrantAllowance",
    toAmino: ({
      granter,
      grantee,
      allowance
    }) => {
      return {
        granter,
        grantee,
        allowance: {
          type_url: allowance.typeUrl,
          value: allowance.value
        }
      };
    },
    fromAmino: ({
      granter,
      grantee,
      allowance
    }) => {
      return {
        granter,
        grantee,
        allowance: {
          typeUrl: allowance.type_url,
          value: allowance.value
        }
      };
    }
  },
  "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": {
    aminoType: "cosmos-sdk/MsgRevokeAllowance",
    toAmino: ({
      granter,
      grantee
    }) => {
      return {
        granter,
        grantee
      };
    },
    fromAmino: ({
      granter,
      grantee
    }) => {
      return {
        granter,
        grantee
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1/tx.amino.js
var tx_amino_exports9 = {};
__export(tx_amino_exports9, {
  AminoConverter: () => AminoConverter9
});
var AminoConverter9 = {
  "/cosmos.gov.v1.MsgSubmitProposal": {
    aminoType: "cosmos-sdk/v1/MsgSubmitProposal",
    toAmino: ({
      messages,
      initialDeposit,
      proposer,
      metadata,
      title,
      summary
    }) => {
      return {
        messages: messages.map((el0) => ({
          type_url: el0.typeUrl,
          value: el0.value
        })),
        initial_deposit: initialDeposit.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        proposer,
        metadata,
        title,
        summary
      };
    },
    fromAmino: ({
      messages,
      initial_deposit,
      proposer,
      metadata,
      title,
      summary
    }) => {
      return {
        messages: messages.map((el0) => ({
          typeUrl: el0.type_url,
          value: el0.value
        })),
        initialDeposit: initial_deposit.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        proposer,
        metadata,
        title,
        summary
      };
    }
  },
  "/cosmos.gov.v1.MsgExecLegacyContent": {
    aminoType: "cosmos-sdk/v1/MsgExecLegacyContent",
    toAmino: ({
      content,
      authority
    }) => {
      return {
        content: {
          type_url: content.typeUrl,
          value: content.value
        },
        authority
      };
    },
    fromAmino: ({
      content,
      authority
    }) => {
      return {
        content: {
          typeUrl: content.type_url,
          value: content.value
        },
        authority
      };
    }
  },
  "/cosmos.gov.v1.MsgVote": {
    aminoType: "cosmos-sdk/v1/MsgVote",
    toAmino: ({
      proposalId,
      voter,
      option,
      metadata
    }) => {
      return {
        proposal_id: proposalId.toString(),
        voter,
        option,
        metadata
      };
    },
    fromAmino: ({
      proposal_id,
      voter,
      option,
      metadata
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        voter,
        option: voteOptionFromJSON(option),
        metadata
      };
    }
  },
  "/cosmos.gov.v1.MsgVoteWeighted": {
    aminoType: "cosmos-sdk/v1/MsgVoteWeighted",
    toAmino: ({
      proposalId,
      voter,
      options,
      metadata
    }) => {
      return {
        proposal_id: proposalId.toString(),
        voter,
        options: options.map((el0) => ({
          option: el0.option,
          weight: el0.weight
        })),
        metadata
      };
    },
    fromAmino: ({
      proposal_id,
      voter,
      options,
      metadata
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        voter,
        options: options.map((el0) => ({
          option: voteOptionFromJSON(el0.option),
          weight: el0.weight
        })),
        metadata
      };
    }
  },
  "/cosmos.gov.v1.MsgDeposit": {
    aminoType: "cosmos-sdk/v1/MsgDeposit",
    toAmino: ({
      proposalId,
      depositor,
      amount
    }) => {
      return {
        proposal_id: proposalId.toString(),
        depositor,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      proposal_id,
      depositor,
      amount
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        depositor,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  },
  "/cosmos.gov.v1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/gov/v1/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          min_deposit: params.minDeposit.map((el0) => ({
            denom: el0.denom,
            amount: el0.amount
          })),
          max_deposit_period: (params.maxDepositPeriod * 1e9).toString(),
          voting_period: (params.votingPeriod * 1e9).toString(),
          quorum: params.quorum,
          threshold: params.threshold,
          veto_threshold: params.vetoThreshold,
          min_initial_deposit_ratio: params.minInitialDepositRatio,
          burn_vote_quorum: params.burnVoteQuorum,
          burn_proposal_deposit_prevote: params.burnProposalDepositPrevote,
          burn_vote_veto: params.burnVoteVeto
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          minDeposit: params.min_deposit.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          })),
          maxDepositPeriod: {
            seconds: BigInt(Math.floor(parseInt(params.max_deposit_period) / 1e9)),
            nanos: parseInt(params.max_deposit_period) % 1e9
          },
          votingPeriod: {
            seconds: BigInt(Math.floor(parseInt(params.voting_period) / 1e9)),
            nanos: parseInt(params.voting_period) % 1e9
          },
          quorum: params.quorum,
          threshold: params.threshold,
          vetoThreshold: params.veto_threshold,
          minInitialDepositRatio: params.min_initial_deposit_ratio,
          burnVoteQuorum: params.burn_vote_quorum,
          burnProposalDepositPrevote: params.burn_proposal_deposit_prevote,
          burnVoteVeto: params.burn_vote_veto
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1beta1/tx.amino.js
var tx_amino_exports10 = {};
__export(tx_amino_exports10, {
  AminoConverter: () => AminoConverter10
});
var AminoConverter10 = {
  "/cosmos.gov.v1beta1.MsgSubmitProposal": {
    aminoType: "cosmos-sdk/MsgSubmitProposal",
    toAmino: ({
      content,
      initialDeposit,
      proposer
    }) => {
      return {
        content: {
          type_url: content.typeUrl,
          value: content.value
        },
        initial_deposit: initialDeposit.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        proposer
      };
    },
    fromAmino: ({
      content,
      initial_deposit,
      proposer
    }) => {
      return {
        content: {
          typeUrl: content.type_url,
          value: content.value
        },
        initialDeposit: initial_deposit.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        proposer
      };
    }
  },
  "/cosmos.gov.v1beta1.MsgVote": {
    aminoType: "cosmos-sdk/MsgVote",
    toAmino: ({
      proposalId,
      voter,
      option
    }) => {
      return {
        proposal_id: proposalId.toString(),
        voter,
        option
      };
    },
    fromAmino: ({
      proposal_id,
      voter,
      option
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        voter,
        option: voteOptionFromJSON2(option)
      };
    }
  },
  "/cosmos.gov.v1beta1.MsgVoteWeighted": {
    aminoType: "cosmos-sdk/MsgVoteWeighted",
    toAmino: ({
      proposalId,
      voter,
      options
    }) => {
      return {
        proposal_id: proposalId.toString(),
        voter,
        options: options.map((el0) => ({
          option: el0.option,
          weight: el0.weight
        }))
      };
    },
    fromAmino: ({
      proposal_id,
      voter,
      options
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        voter,
        options: options.map((el0) => ({
          option: voteOptionFromJSON2(el0.option),
          weight: el0.weight
        }))
      };
    }
  },
  "/cosmos.gov.v1beta1.MsgDeposit": {
    aminoType: "cosmos-sdk/MsgDeposit",
    toAmino: ({
      proposalId,
      depositor,
      amount
    }) => {
      return {
        proposal_id: proposalId.toString(),
        depositor,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      proposal_id,
      depositor,
      amount
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        depositor,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/group/v1/tx.amino.js
var tx_amino_exports11 = {};
__export(tx_amino_exports11, {
  AminoConverter: () => AminoConverter11
});
var AminoConverter11 = {
  "/cosmos.group.v1.MsgCreateGroup": {
    aminoType: "cosmos-sdk/MsgCreateGroup",
    toAmino: ({
      admin,
      members,
      metadata
    }) => {
      return {
        admin,
        members: members.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        })),
        metadata
      };
    },
    fromAmino: ({
      admin,
      members,
      metadata
    }) => {
      return {
        admin,
        members: members.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        })),
        metadata
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupMembers": {
    aminoType: "cosmos-sdk/MsgUpdateGroupMembers",
    toAmino: ({
      admin,
      groupId,
      memberUpdates
    }) => {
      return {
        admin,
        group_id: groupId.toString(),
        member_updates: memberUpdates.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        }))
      };
    },
    fromAmino: ({
      admin,
      group_id,
      member_updates
    }) => {
      return {
        admin,
        groupId: BigInt(group_id),
        memberUpdates: member_updates.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        }))
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupAdmin": {
    aminoType: "cosmos-sdk/MsgUpdateGroupAdmin",
    toAmino: ({
      admin,
      groupId,
      newAdmin
    }) => {
      return {
        admin,
        group_id: groupId.toString(),
        new_admin: newAdmin
      };
    },
    fromAmino: ({
      admin,
      group_id,
      new_admin
    }) => {
      return {
        admin,
        groupId: BigInt(group_id),
        newAdmin: new_admin
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupMetadata": {
    aminoType: "cosmos-sdk/MsgUpdateGroupMetadata",
    toAmino: ({
      admin,
      groupId,
      metadata
    }) => {
      return {
        admin,
        group_id: groupId.toString(),
        metadata
      };
    },
    fromAmino: ({
      admin,
      group_id,
      metadata
    }) => {
      return {
        admin,
        groupId: BigInt(group_id),
        metadata
      };
    }
  },
  "/cosmos.group.v1.MsgCreateGroupPolicy": {
    aminoType: "cosmos-sdk/MsgCreateGroupPolicy",
    toAmino: ({
      admin,
      groupId,
      metadata,
      decisionPolicy
    }) => {
      return {
        admin,
        group_id: groupId.toString(),
        metadata,
        decision_policy: {
          type_url: decisionPolicy.typeUrl,
          value: decisionPolicy.value
        }
      };
    },
    fromAmino: ({
      admin,
      group_id,
      metadata,
      decision_policy
    }) => {
      return {
        admin,
        groupId: BigInt(group_id),
        metadata,
        decisionPolicy: {
          typeUrl: decision_policy.type_url,
          value: decision_policy.value
        }
      };
    }
  },
  "/cosmos.group.v1.MsgCreateGroupWithPolicy": {
    aminoType: "cosmos-sdk/MsgCreateGroupWithPolicy",
    toAmino: ({
      admin,
      members,
      groupMetadata,
      groupPolicyMetadata,
      groupPolicyAsAdmin,
      decisionPolicy
    }) => {
      return {
        admin,
        members: members.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        })),
        group_metadata: groupMetadata,
        group_policy_metadata: groupPolicyMetadata,
        group_policy_as_admin: groupPolicyAsAdmin,
        decision_policy: {
          type_url: decisionPolicy.typeUrl,
          value: decisionPolicy.value
        }
      };
    },
    fromAmino: ({
      admin,
      members,
      group_metadata,
      group_policy_metadata,
      group_policy_as_admin,
      decision_policy
    }) => {
      return {
        admin,
        members: members.map((el0) => ({
          address: el0.address,
          weight: el0.weight,
          metadata: el0.metadata
        })),
        groupMetadata: group_metadata,
        groupPolicyMetadata: group_policy_metadata,
        groupPolicyAsAdmin: group_policy_as_admin,
        decisionPolicy: {
          typeUrl: decision_policy.type_url,
          value: decision_policy.value
        }
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin": {
    aminoType: "cosmos-sdk/MsgUpdateGroupPolicyAdmin",
    toAmino: ({
      admin,
      groupPolicyAddress,
      newAdmin
    }) => {
      return {
        admin,
        group_policy_address: groupPolicyAddress,
        new_admin: newAdmin
      };
    },
    fromAmino: ({
      admin,
      group_policy_address,
      new_admin
    }) => {
      return {
        admin,
        groupPolicyAddress: group_policy_address,
        newAdmin: new_admin
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy": {
    aminoType: "cosmos-sdk/MsgUpdateGroupDecisionPolicy",
    toAmino: ({
      admin,
      groupPolicyAddress,
      decisionPolicy
    }) => {
      return {
        admin,
        group_policy_address: groupPolicyAddress,
        decision_policy: {
          type_url: decisionPolicy.typeUrl,
          value: decisionPolicy.value
        }
      };
    },
    fromAmino: ({
      admin,
      group_policy_address,
      decision_policy
    }) => {
      return {
        admin,
        groupPolicyAddress: group_policy_address,
        decisionPolicy: {
          typeUrl: decision_policy.type_url,
          value: decision_policy.value
        }
      };
    }
  },
  "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata": {
    aminoType: "cosmos-sdk/MsgUpdateGroupPolicyMetadata",
    toAmino: ({
      admin,
      groupPolicyAddress,
      metadata
    }) => {
      return {
        admin,
        group_policy_address: groupPolicyAddress,
        metadata
      };
    },
    fromAmino: ({
      admin,
      group_policy_address,
      metadata
    }) => {
      return {
        admin,
        groupPolicyAddress: group_policy_address,
        metadata
      };
    }
  },
  "/cosmos.group.v1.MsgSubmitProposal": {
    aminoType: "cosmos-sdk/group/MsgSubmitProposal",
    toAmino: ({
      groupPolicyAddress,
      proposers,
      metadata,
      messages,
      exec,
      title,
      summary
    }) => {
      return {
        group_policy_address: groupPolicyAddress,
        proposers,
        metadata,
        messages: messages.map((el0) => ({
          type_url: el0.typeUrl,
          value: el0.value
        })),
        exec,
        title,
        summary
      };
    },
    fromAmino: ({
      group_policy_address,
      proposers,
      metadata,
      messages,
      exec,
      title,
      summary
    }) => {
      return {
        groupPolicyAddress: group_policy_address,
        proposers,
        metadata,
        messages: messages.map((el0) => ({
          typeUrl: el0.type_url,
          value: el0.value
        })),
        exec: execFromJSON(exec),
        title,
        summary
      };
    }
  },
  "/cosmos.group.v1.MsgWithdrawProposal": {
    aminoType: "cosmos-sdk/group/MsgWithdrawProposal",
    toAmino: ({
      proposalId,
      address
    }) => {
      return {
        proposal_id: proposalId.toString(),
        address
      };
    },
    fromAmino: ({
      proposal_id,
      address
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        address
      };
    }
  },
  "/cosmos.group.v1.MsgVote": {
    aminoType: "cosmos-sdk/group/MsgVote",
    toAmino: ({
      proposalId,
      voter,
      option,
      metadata,
      exec
    }) => {
      return {
        proposal_id: proposalId.toString(),
        voter,
        option,
        metadata,
        exec
      };
    },
    fromAmino: ({
      proposal_id,
      voter,
      option,
      metadata,
      exec
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        voter,
        option: voteOptionFromJSON3(option),
        metadata,
        exec: execFromJSON(exec)
      };
    }
  },
  "/cosmos.group.v1.MsgExec": {
    aminoType: "cosmos-sdk/group/MsgExec",
    toAmino: ({
      proposalId,
      executor
    }) => {
      return {
        proposal_id: proposalId.toString(),
        executor
      };
    },
    fromAmino: ({
      proposal_id,
      executor
    }) => {
      return {
        proposalId: BigInt(proposal_id),
        executor
      };
    }
  },
  "/cosmos.group.v1.MsgLeaveGroup": {
    aminoType: "cosmos-sdk/group/MsgLeaveGroup",
    toAmino: ({
      address,
      groupId
    }) => {
      return {
        address,
        group_id: groupId.toString()
      };
    },
    fromAmino: ({
      address,
      group_id
    }) => {
      return {
        address,
        groupId: BigInt(group_id)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/mint/v1beta1/tx.amino.js
var tx_amino_exports12 = {};
__export(tx_amino_exports12, {
  AminoConverter: () => AminoConverter12
});
var AminoConverter12 = {
  "/cosmos.mint.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/mint/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          mint_denom: params.mintDenom,
          inflation_rate_change: params.inflationRateChange,
          inflation_max: params.inflationMax,
          inflation_min: params.inflationMin,
          goal_bonded: params.goalBonded,
          blocks_per_year: params.blocksPerYear.toString()
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          mintDenom: params.mint_denom,
          inflationRateChange: params.inflation_rate_change,
          inflationMax: params.inflation_max,
          inflationMin: params.inflation_min,
          goalBonded: params.goal_bonded,
          blocksPerYear: BigInt(params.blocks_per_year)
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/nft/v1beta1/tx.amino.js
var tx_amino_exports13 = {};
__export(tx_amino_exports13, {
  AminoConverter: () => AminoConverter13
});
var AminoConverter13 = {
  "/cosmos.nft.v1beta1.MsgSend": {
    aminoType: "cosmos-sdk/MsgNFTSend",
    toAmino: ({
      classId,
      id,
      sender,
      receiver
    }) => {
      return {
        class_id: classId,
        id,
        sender,
        receiver
      };
    },
    fromAmino: ({
      class_id,
      id,
      sender,
      receiver
    }) => {
      return {
        classId: class_id,
        id,
        sender,
        receiver
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/slashing/v1beta1/tx.amino.js
var tx_amino_exports14 = {};
__export(tx_amino_exports14, {
  AminoConverter: () => AminoConverter14
});
var AminoConverter14 = {
  "/cosmos.slashing.v1beta1.MsgUnjail": {
    aminoType: "cosmos-sdk/MsgUnjail",
    toAmino: ({
      validatorAddr
    }) => {
      return {
        validator_addr: validatorAddr
      };
    },
    fromAmino: ({
      validator_addr
    }) => {
      return {
        validatorAddr: validator_addr
      };
    }
  },
  "/cosmos.slashing.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/slashing/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          signed_blocks_window: params.signedBlocksWindow.toString(),
          min_signed_per_window: params.minSignedPerWindow,
          downtime_jail_duration: (params.downtimeJailDuration * 1e9).toString(),
          slash_fraction_double_sign: params.slashFractionDoubleSign,
          slash_fraction_downtime: params.slashFractionDowntime
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          signedBlocksWindow: BigInt(params.signed_blocks_window),
          minSignedPerWindow: params.min_signed_per_window,
          downtimeJailDuration: {
            seconds: BigInt(Math.floor(parseInt(params.downtime_jail_duration) / 1e9)),
            nanos: parseInt(params.downtime_jail_duration) % 1e9
          },
          slashFractionDoubleSign: params.slash_fraction_double_sign,
          slashFractionDowntime: params.slash_fraction_downtime
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/staking/v1beta1/tx.amino.js
var tx_amino_exports15 = {};
__export(tx_amino_exports15, {
  AminoConverter: () => AminoConverter15
});
var import_amino = __toESM(require_build5());
var import_encoding = __toESM(require_build());
var AminoConverter15 = {
  "/cosmos.staking.v1beta1.MsgCreateValidator": {
    aminoType: "cosmos-sdk/MsgCreateValidator",
    toAmino: ({
      description,
      commission,
      minSelfDelegation,
      delegatorAddress,
      validatorAddress,
      pubkey,
      value
    }) => {
      return {
        description: {
          moniker: description.moniker,
          identity: description.identity,
          website: description.website,
          security_contact: description.securityContact,
          details: description.details
        },
        commission: {
          rate: commission.rate,
          max_rate: commission.maxRate,
          max_change_rate: commission.maxChangeRate
        },
        min_self_delegation: minSelfDelegation,
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        pubkey: {
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: (0, import_encoding.fromBase64)((0, import_amino.decodeBech32Pubkey)(pubkey).value)
        },
        value: {
          denom: value.denom,
          amount: value.amount
        }
      };
    },
    fromAmino: ({
      description,
      commission,
      min_self_delegation,
      delegator_address,
      validator_address,
      pubkey,
      value
    }) => {
      return {
        description: {
          moniker: description.moniker,
          identity: description.identity,
          website: description.website,
          securityContact: description.security_contact,
          details: description.details
        },
        commission: {
          rate: commission.rate,
          maxRate: commission.max_rate,
          maxChangeRate: commission.max_change_rate
        },
        minSelfDelegation: min_self_delegation,
        delegatorAddress: delegator_address,
        validatorAddress: validator_address,
        pubkey: (0, import_amino.encodeBech32Pubkey)({
          type: "tendermint/PubKeySecp256k1",
          value: (0, import_encoding.toBase64)(pubkey.value)
        }, "cosmos"),
        value: {
          denom: value.denom,
          amount: value.amount
        }
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgEditValidator": {
    aminoType: "cosmos-sdk/MsgEditValidator",
    toAmino: ({
      description,
      validatorAddress,
      commissionRate,
      minSelfDelegation
    }) => {
      return {
        description: {
          moniker: description.moniker,
          identity: description.identity,
          website: description.website,
          security_contact: description.securityContact,
          details: description.details
        },
        validator_address: validatorAddress,
        commission_rate: commissionRate,
        min_self_delegation: minSelfDelegation
      };
    },
    fromAmino: ({
      description,
      validator_address,
      commission_rate,
      min_self_delegation
    }) => {
      return {
        description: {
          moniker: description.moniker,
          identity: description.identity,
          website: description.website,
          securityContact: description.security_contact,
          details: description.details
        },
        validatorAddress: validator_address,
        commissionRate: commission_rate,
        minSelfDelegation: min_self_delegation
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgDelegate": {
    aminoType: "cosmos-sdk/MsgDelegate",
    toAmino: ({
      delegatorAddress,
      validatorAddress,
      amount
    }) => {
      return {
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    },
    fromAmino: ({
      delegator_address,
      validator_address,
      amount
    }) => {
      return {
        delegatorAddress: delegator_address,
        validatorAddress: validator_address,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
    aminoType: "cosmos-sdk/MsgBeginRedelegate",
    toAmino: ({
      delegatorAddress,
      validatorSrcAddress,
      validatorDstAddress,
      amount
    }) => {
      return {
        delegator_address: delegatorAddress,
        validator_src_address: validatorSrcAddress,
        validator_dst_address: validatorDstAddress,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    },
    fromAmino: ({
      delegator_address,
      validator_src_address,
      validator_dst_address,
      amount
    }) => {
      return {
        delegatorAddress: delegator_address,
        validatorSrcAddress: validator_src_address,
        validatorDstAddress: validator_dst_address,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgUndelegate": {
    aminoType: "cosmos-sdk/MsgUndelegate",
    toAmino: ({
      delegatorAddress,
      validatorAddress,
      amount
    }) => {
      return {
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    },
    fromAmino: ({
      delegator_address,
      validator_address,
      amount
    }) => {
      return {
        delegatorAddress: delegator_address,
        validatorAddress: validator_address,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        }
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
    aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
    toAmino: ({
      delegatorAddress,
      validatorAddress,
      amount,
      creationHeight
    }) => {
      return {
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        },
        creation_height: creationHeight.toString()
      };
    },
    fromAmino: ({
      delegator_address,
      validator_address,
      amount,
      creation_height
    }) => {
      return {
        delegatorAddress: delegator_address,
        validatorAddress: validator_address,
        amount: {
          denom: amount.denom,
          amount: amount.amount
        },
        creationHeight: BigInt(creation_height)
      };
    }
  },
  "/cosmos.staking.v1beta1.MsgUpdateParams": {
    aminoType: "cosmos-sdk/x/staking/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          unbonding_time: (params.unbondingTime * 1e9).toString(),
          max_validators: params.maxValidators,
          max_entries: params.maxEntries,
          historical_entries: params.historicalEntries,
          bond_denom: params.bondDenom,
          min_commission_rate: params.minCommissionRate
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          unbondingTime: {
            seconds: BigInt(Math.floor(parseInt(params.unbonding_time) / 1e9)),
            nanos: parseInt(params.unbonding_time) % 1e9
          },
          maxValidators: params.max_validators,
          maxEntries: params.max_entries,
          historicalEntries: params.historical_entries,
          bondDenom: params.bond_denom,
          minCommissionRate: params.min_commission_rate
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/upgrade/v1beta1/tx.amino.js
var tx_amino_exports16 = {};
__export(tx_amino_exports16, {
  AminoConverter: () => AminoConverter16
});
var AminoConverter16 = {
  "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade": {
    aminoType: "cosmos-sdk/MsgSoftwareUpgrade",
    toAmino: ({
      authority,
      plan
    }) => {
      return {
        authority,
        plan: {
          name: plan.name,
          time: plan.time,
          height: plan.height.toString(),
          info: plan.info,
          upgraded_client_state: {
            type_url: plan.upgradedClientState.typeUrl,
            value: plan.upgradedClientState.value
          }
        }
      };
    },
    fromAmino: ({
      authority,
      plan
    }) => {
      return {
        authority,
        plan: {
          name: plan.name,
          time: plan.time,
          height: BigInt(plan.height),
          info: plan.info,
          upgradedClientState: {
            typeUrl: plan.upgraded_client_state.type_url,
            value: plan.upgraded_client_state.value
          }
        }
      };
    }
  },
  "/cosmos.upgrade.v1beta1.MsgCancelUpgrade": {
    aminoType: "cosmos-sdk/MsgCancelUpgrade",
    toAmino: ({
      authority
    }) => {
      return {
        authority
      };
    },
    fromAmino: ({
      authority
    }) => {
      return {
        authority
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/vesting/v1beta1/tx.amino.js
var tx_amino_exports17 = {};
__export(tx_amino_exports17, {
  AminoConverter: () => AminoConverter17
});
var AminoConverter17 = {
  "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
    aminoType: "cosmos-sdk/MsgCreateVestingAccount",
    toAmino: ({
      fromAddress,
      toAddress,
      amount,
      endTime,
      delayed
    }) => {
      return {
        from_address: fromAddress,
        to_address: toAddress,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        end_time: endTime.toString(),
        delayed
      };
    },
    fromAmino: ({
      from_address,
      to_address,
      amount,
      end_time,
      delayed
    }) => {
      return {
        fromAddress: from_address,
        toAddress: to_address,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        endTime: BigInt(end_time),
        delayed
      };
    }
  },
  "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount": {
    aminoType: "cosmos-sdk/MsgCreatePermLockedAccount",
    toAmino: ({
      fromAddress,
      toAddress,
      amount
    }) => {
      return {
        from_address: fromAddress,
        to_address: toAddress,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      from_address,
      to_address,
      amount
    }) => {
      return {
        fromAddress: from_address,
        toAddress: to_address,
        amount: amount.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  },
  "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount": {
    aminoType: "cosmos-sdk/MsgCreatePeriodicVestingAccount",
    toAmino: ({
      fromAddress,
      toAddress,
      startTime,
      vestingPeriods
    }) => {
      return {
        from_address: fromAddress,
        to_address: toAddress,
        start_time: startTime.toString(),
        vesting_periods: vestingPeriods.map((el0) => ({
          length: el0.length.toString(),
          amount: el0.amount.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        }))
      };
    },
    fromAmino: ({
      from_address,
      to_address,
      start_time,
      vesting_periods
    }) => {
      return {
        fromAddress: from_address,
        toAddress: to_address,
        startTime: BigInt(start_time),
        vestingPeriods: vesting_periods.map((el0) => ({
          length: BigInt(el0.length),
          amount: el0.amount.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        }))
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/auth/v1beta1/tx.registry.js
var tx_registry_exports = {};
__export(tx_registry_exports, {
  MessageComposer: () => MessageComposer,
  load: () => load,
  registry: () => registry
});
var registry = [["/cosmos.auth.v1beta1.MsgUpdateParams", MsgUpdateParams]];
var load = (protoRegistry) => {
  registry.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer = {
  encoded: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams.toJSON(value)
      };
    }
  },
  fromJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams.fromJSON(value)
      };
    }
  },
  fromPartial: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/authz/v1beta1/tx.registry.js
var tx_registry_exports2 = {};
__export(tx_registry_exports2, {
  MessageComposer: () => MessageComposer2,
  load: () => load2,
  registry: () => registry2
});
var registry2 = [["/cosmos.authz.v1beta1.MsgGrant", MsgGrant], ["/cosmos.authz.v1beta1.MsgExec", MsgExec], ["/cosmos.authz.v1beta1.MsgRevoke", MsgRevoke]];
var load2 = (protoRegistry) => {
  registry2.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer2 = {
  encoded: {
    grant(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
        value: MsgGrant.encode(value).finish()
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgExec",
        value: MsgExec.encode(value).finish()
      };
    },
    revoke(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
        value: MsgRevoke.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    grant(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
        value
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgExec",
        value
      };
    },
    revoke(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
        value
      };
    }
  },
  toJSON: {
    grant(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
        value: MsgGrant.toJSON(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgExec",
        value: MsgExec.toJSON(value)
      };
    },
    revoke(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
        value: MsgRevoke.toJSON(value)
      };
    }
  },
  fromJSON: {
    grant(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
        value: MsgGrant.fromJSON(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgExec",
        value: MsgExec.fromJSON(value)
      };
    },
    revoke(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
        value: MsgRevoke.fromJSON(value)
      };
    }
  },
  fromPartial: {
    grant(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
        value: MsgGrant.fromPartial(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgExec",
        value: MsgExec.fromPartial(value)
      };
    },
    revoke(value) {
      return {
        typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
        value: MsgRevoke.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bank/v1beta1/tx.registry.js
var tx_registry_exports3 = {};
__export(tx_registry_exports3, {
  MessageComposer: () => MessageComposer3,
  load: () => load3,
  registry: () => registry3
});
var registry3 = [["/cosmos.bank.v1beta1.MsgSend", MsgSend], ["/cosmos.bank.v1beta1.MsgMultiSend", MsgMultiSend], ["/cosmos.bank.v1beta1.MsgUpdateParams", MsgUpdateParams2], ["/cosmos.bank.v1beta1.MsgSetSendEnabled", MsgSetSendEnabled]];
var load3 = (protoRegistry) => {
  registry3.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer3 = {
  encoded: {
    send(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: MsgSend.encode(value).finish()
      };
    },
    multiSend(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
        value: MsgMultiSend.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams2.encode(value).finish()
      };
    },
    setSendEnabled(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
        value: MsgSetSendEnabled.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    send(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value
      };
    },
    multiSend(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
        value
      };
    },
    setSendEnabled(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
        value
      };
    }
  },
  toJSON: {
    send(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: MsgSend.toJSON(value)
      };
    },
    multiSend(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
        value: MsgMultiSend.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams2.toJSON(value)
      };
    },
    setSendEnabled(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
        value: MsgSetSendEnabled.toJSON(value)
      };
    }
  },
  fromJSON: {
    send(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: MsgSend.fromJSON(value)
      };
    },
    multiSend(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
        value: MsgMultiSend.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams2.fromJSON(value)
      };
    },
    setSendEnabled(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
        value: MsgSetSendEnabled.fromJSON(value)
      };
    }
  },
  fromPartial: {
    send(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: MsgSend.fromPartial(value)
      };
    },
    multiSend(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
        value: MsgMultiSend.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams2.fromPartial(value)
      };
    },
    setSendEnabled(value) {
      return {
        typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
        value: MsgSetSendEnabled.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/consensus/v1/tx.registry.js
var tx_registry_exports4 = {};
__export(tx_registry_exports4, {
  MessageComposer: () => MessageComposer4,
  load: () => load4,
  registry: () => registry4
});
var registry4 = [["/cosmos.consensus.v1.MsgUpdateParams", MsgUpdateParams3]];
var load4 = (protoRegistry) => {
  registry4.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer4 = {
  encoded: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.consensus.v1.MsgUpdateParams",
        value: MsgUpdateParams3.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.consensus.v1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.consensus.v1.MsgUpdateParams",
        value: MsgUpdateParams3.toJSON(value)
      };
    }
  },
  fromJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.consensus.v1.MsgUpdateParams",
        value: MsgUpdateParams3.fromJSON(value)
      };
    }
  },
  fromPartial: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.consensus.v1.MsgUpdateParams",
        value: MsgUpdateParams3.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/crisis/v1beta1/tx.registry.js
var tx_registry_exports5 = {};
__export(tx_registry_exports5, {
  MessageComposer: () => MessageComposer5,
  load: () => load5,
  registry: () => registry5
});
var registry5 = [["/cosmos.crisis.v1beta1.MsgVerifyInvariant", MsgVerifyInvariant], ["/cosmos.crisis.v1beta1.MsgUpdateParams", MsgUpdateParams4]];
var load5 = (protoRegistry) => {
  registry5.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer5 = {
  encoded: {
    verifyInvariant(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
        value: MsgVerifyInvariant.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams4.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    verifyInvariant(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    verifyInvariant(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
        value: MsgVerifyInvariant.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams4.toJSON(value)
      };
    }
  },
  fromJSON: {
    verifyInvariant(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
        value: MsgVerifyInvariant.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams4.fromJSON(value)
      };
    }
  },
  fromPartial: {
    verifyInvariant(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
        value: MsgVerifyInvariant.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.crisis.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams4.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/distribution/v1beta1/tx.registry.js
var tx_registry_exports6 = {};
__export(tx_registry_exports6, {
  MessageComposer: () => MessageComposer6,
  load: () => load6,
  registry: () => registry6
});
var registry6 = [["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", MsgSetWithdrawAddress], ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", MsgWithdrawDelegatorReward], ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", MsgWithdrawValidatorCommission], ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", MsgFundCommunityPool], ["/cosmos.distribution.v1beta1.MsgUpdateParams", MsgUpdateParams5], ["/cosmos.distribution.v1beta1.MsgCommunityPoolSpend", MsgCommunityPoolSpend]];
var load6 = (protoRegistry) => {
  registry6.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer6 = {
  encoded: {
    setWithdrawAddress(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        value: MsgSetWithdrawAddress.encode(value).finish()
      };
    },
    withdrawDelegatorReward(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: MsgWithdrawDelegatorReward.encode(value).finish()
      };
    },
    withdrawValidatorCommission(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        value: MsgWithdrawValidatorCommission.encode(value).finish()
      };
    },
    fundCommunityPool(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        value: MsgFundCommunityPool.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams5.encode(value).finish()
      };
    },
    communityPoolSpend(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
        value: MsgCommunityPoolSpend.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    setWithdrawAddress(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        value
      };
    },
    withdrawDelegatorReward(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value
      };
    },
    withdrawValidatorCommission(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        value
      };
    },
    fundCommunityPool(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
        value
      };
    },
    communityPoolSpend(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
        value
      };
    }
  },
  toJSON: {
    setWithdrawAddress(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        value: MsgSetWithdrawAddress.toJSON(value)
      };
    },
    withdrawDelegatorReward(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: MsgWithdrawDelegatorReward.toJSON(value)
      };
    },
    withdrawValidatorCommission(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        value: MsgWithdrawValidatorCommission.toJSON(value)
      };
    },
    fundCommunityPool(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        value: MsgFundCommunityPool.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams5.toJSON(value)
      };
    },
    communityPoolSpend(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
        value: MsgCommunityPoolSpend.toJSON(value)
      };
    }
  },
  fromJSON: {
    setWithdrawAddress(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        value: MsgSetWithdrawAddress.fromJSON(value)
      };
    },
    withdrawDelegatorReward(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: MsgWithdrawDelegatorReward.fromJSON(value)
      };
    },
    withdrawValidatorCommission(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        value: MsgWithdrawValidatorCommission.fromJSON(value)
      };
    },
    fundCommunityPool(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        value: MsgFundCommunityPool.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams5.fromJSON(value)
      };
    },
    communityPoolSpend(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
        value: MsgCommunityPoolSpend.fromJSON(value)
      };
    }
  },
  fromPartial: {
    setWithdrawAddress(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        value: MsgSetWithdrawAddress.fromPartial(value)
      };
    },
    withdrawDelegatorReward(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: MsgWithdrawDelegatorReward.fromPartial(value)
      };
    },
    withdrawValidatorCommission(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        value: MsgWithdrawValidatorCommission.fromPartial(value)
      };
    },
    fundCommunityPool(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        value: MsgFundCommunityPool.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams5.fromPartial(value)
      };
    },
    communityPoolSpend(value) {
      return {
        typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
        value: MsgCommunityPoolSpend.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/evidence/v1beta1/tx.registry.js
var tx_registry_exports7 = {};
__export(tx_registry_exports7, {
  MessageComposer: () => MessageComposer7,
  load: () => load7,
  registry: () => registry7
});
var registry7 = [["/cosmos.evidence.v1beta1.MsgSubmitEvidence", MsgSubmitEvidence]];
var load7 = (protoRegistry) => {
  registry7.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer7 = {
  encoded: {
    submitEvidence(value) {
      return {
        typeUrl: "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
        value: MsgSubmitEvidence.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    submitEvidence(value) {
      return {
        typeUrl: "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
        value
      };
    }
  },
  toJSON: {
    submitEvidence(value) {
      return {
        typeUrl: "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
        value: MsgSubmitEvidence.toJSON(value)
      };
    }
  },
  fromJSON: {
    submitEvidence(value) {
      return {
        typeUrl: "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
        value: MsgSubmitEvidence.fromJSON(value)
      };
    }
  },
  fromPartial: {
    submitEvidence(value) {
      return {
        typeUrl: "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
        value: MsgSubmitEvidence.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/feegrant/v1beta1/tx.registry.js
var tx_registry_exports8 = {};
__export(tx_registry_exports8, {
  MessageComposer: () => MessageComposer8,
  load: () => load8,
  registry: () => registry8
});
var registry8 = [["/cosmos.feegrant.v1beta1.MsgGrantAllowance", MsgGrantAllowance], ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", MsgRevokeAllowance]];
var load8 = (protoRegistry) => {
  registry8.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer8 = {
  encoded: {
    grantAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        value: MsgGrantAllowance.encode(value).finish()
      };
    },
    revokeAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        value: MsgRevokeAllowance.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    grantAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        value
      };
    },
    revokeAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        value
      };
    }
  },
  toJSON: {
    grantAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        value: MsgGrantAllowance.toJSON(value)
      };
    },
    revokeAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        value: MsgRevokeAllowance.toJSON(value)
      };
    }
  },
  fromJSON: {
    grantAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        value: MsgGrantAllowance.fromJSON(value)
      };
    },
    revokeAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        value: MsgRevokeAllowance.fromJSON(value)
      };
    }
  },
  fromPartial: {
    grantAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        value: MsgGrantAllowance.fromPartial(value)
      };
    },
    revokeAllowance(value) {
      return {
        typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        value: MsgRevokeAllowance.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1/tx.registry.js
var tx_registry_exports9 = {};
__export(tx_registry_exports9, {
  MessageComposer: () => MessageComposer9,
  load: () => load9,
  registry: () => registry9
});
var registry9 = [["/cosmos.gov.v1.MsgSubmitProposal", MsgSubmitProposal], ["/cosmos.gov.v1.MsgExecLegacyContent", MsgExecLegacyContent], ["/cosmos.gov.v1.MsgVote", MsgVote], ["/cosmos.gov.v1.MsgVoteWeighted", MsgVoteWeighted], ["/cosmos.gov.v1.MsgDeposit", MsgDeposit], ["/cosmos.gov.v1.MsgUpdateParams", MsgUpdateParams6]];
var load9 = (protoRegistry) => {
  registry9.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer9 = {
  encoded: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
        value: MsgSubmitProposal.encode(value).finish()
      };
    },
    execLegacyContent(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
        value: MsgExecLegacyContent.encode(value).finish()
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVote",
        value: MsgVote.encode(value).finish()
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
        value: MsgVoteWeighted.encode(value).finish()
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgDeposit",
        value: MsgDeposit.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
        value: MsgUpdateParams6.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
        value
      };
    },
    execLegacyContent(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
        value
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVote",
        value
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
        value
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgDeposit",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
        value: MsgSubmitProposal.toJSON(value)
      };
    },
    execLegacyContent(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
        value: MsgExecLegacyContent.toJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVote",
        value: MsgVote.toJSON(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
        value: MsgVoteWeighted.toJSON(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgDeposit",
        value: MsgDeposit.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
        value: MsgUpdateParams6.toJSON(value)
      };
    }
  },
  fromJSON: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
        value: MsgSubmitProposal.fromJSON(value)
      };
    },
    execLegacyContent(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
        value: MsgExecLegacyContent.fromJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVote",
        value: MsgVote.fromJSON(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
        value: MsgVoteWeighted.fromJSON(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgDeposit",
        value: MsgDeposit.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
        value: MsgUpdateParams6.fromJSON(value)
      };
    }
  },
  fromPartial: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
        value: MsgSubmitProposal.fromPartial(value)
      };
    },
    execLegacyContent(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
        value: MsgExecLegacyContent.fromPartial(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVote",
        value: MsgVote.fromPartial(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
        value: MsgVoteWeighted.fromPartial(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgDeposit",
        value: MsgDeposit.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
        value: MsgUpdateParams6.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/gov/v1beta1/tx.registry.js
var tx_registry_exports10 = {};
__export(tx_registry_exports10, {
  MessageComposer: () => MessageComposer10,
  load: () => load10,
  registry: () => registry10
});
var registry10 = [["/cosmos.gov.v1beta1.MsgSubmitProposal", MsgSubmitProposal2], ["/cosmos.gov.v1beta1.MsgVote", MsgVote2], ["/cosmos.gov.v1beta1.MsgVoteWeighted", MsgVoteWeighted2], ["/cosmos.gov.v1beta1.MsgDeposit", MsgDeposit2]];
var load10 = (protoRegistry) => {
  registry10.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer10 = {
  encoded: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
        value: MsgSubmitProposal2.encode(value).finish()
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
        value: MsgVote2.encode(value).finish()
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
        value: MsgVoteWeighted2.encode(value).finish()
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
        value: MsgDeposit2.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
        value
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
        value
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
        value
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
        value
      };
    }
  },
  toJSON: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
        value: MsgSubmitProposal2.toJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
        value: MsgVote2.toJSON(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
        value: MsgVoteWeighted2.toJSON(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
        value: MsgDeposit2.toJSON(value)
      };
    }
  },
  fromJSON: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
        value: MsgSubmitProposal2.fromJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
        value: MsgVote2.fromJSON(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
        value: MsgVoteWeighted2.fromJSON(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
        value: MsgDeposit2.fromJSON(value)
      };
    }
  },
  fromPartial: {
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
        value: MsgSubmitProposal2.fromPartial(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
        value: MsgVote2.fromPartial(value)
      };
    },
    voteWeighted(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
        value: MsgVoteWeighted2.fromPartial(value)
      };
    },
    deposit(value) {
      return {
        typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
        value: MsgDeposit2.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/group/v1/tx.registry.js
var tx_registry_exports11 = {};
__export(tx_registry_exports11, {
  MessageComposer: () => MessageComposer11,
  load: () => load11,
  registry: () => registry11
});
var registry11 = [["/cosmos.group.v1.MsgCreateGroup", MsgCreateGroup], ["/cosmos.group.v1.MsgUpdateGroupMembers", MsgUpdateGroupMembers], ["/cosmos.group.v1.MsgUpdateGroupAdmin", MsgUpdateGroupAdmin], ["/cosmos.group.v1.MsgUpdateGroupMetadata", MsgUpdateGroupMetadata], ["/cosmos.group.v1.MsgCreateGroupPolicy", MsgCreateGroupPolicy], ["/cosmos.group.v1.MsgCreateGroupWithPolicy", MsgCreateGroupWithPolicy], ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", MsgUpdateGroupPolicyAdmin], ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", MsgUpdateGroupPolicyDecisionPolicy], ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", MsgUpdateGroupPolicyMetadata], ["/cosmos.group.v1.MsgSubmitProposal", MsgSubmitProposal3], ["/cosmos.group.v1.MsgWithdrawProposal", MsgWithdrawProposal], ["/cosmos.group.v1.MsgVote", MsgVote3], ["/cosmos.group.v1.MsgExec", MsgExec2], ["/cosmos.group.v1.MsgLeaveGroup", MsgLeaveGroup]];
var load11 = (protoRegistry) => {
  registry11.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer11 = {
  encoded: {
    createGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroup",
        value: MsgCreateGroup.encode(value).finish()
      };
    },
    updateGroupMembers(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
        value: MsgUpdateGroupMembers.encode(value).finish()
      };
    },
    updateGroupAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
        value: MsgUpdateGroupAdmin.encode(value).finish()
      };
    },
    updateGroupMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
        value: MsgUpdateGroupMetadata.encode(value).finish()
      };
    },
    createGroupPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
        value: MsgCreateGroupPolicy.encode(value).finish()
      };
    },
    createGroupWithPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        value: MsgCreateGroupWithPolicy.encode(value).finish()
      };
    },
    updateGroupPolicyAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        value: MsgUpdateGroupPolicyAdmin.encode(value).finish()
      };
    },
    updateGroupPolicyDecisionPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        value: MsgUpdateGroupPolicyDecisionPolicy.encode(value).finish()
      };
    },
    updateGroupPolicyMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        value: MsgUpdateGroupPolicyMetadata.encode(value).finish()
      };
    },
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
        value: MsgSubmitProposal3.encode(value).finish()
      };
    },
    withdrawProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
        value: MsgWithdrawProposal.encode(value).finish()
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgVote",
        value: MsgVote3.encode(value).finish()
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgExec",
        value: MsgExec2.encode(value).finish()
      };
    },
    leaveGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
        value: MsgLeaveGroup.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    createGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroup",
        value
      };
    },
    updateGroupMembers(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
        value
      };
    },
    updateGroupAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
        value
      };
    },
    updateGroupMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
        value
      };
    },
    createGroupPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
        value
      };
    },
    createGroupWithPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        value
      };
    },
    updateGroupPolicyAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        value
      };
    },
    updateGroupPolicyDecisionPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        value
      };
    },
    updateGroupPolicyMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        value
      };
    },
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
        value
      };
    },
    withdrawProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
        value
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgVote",
        value
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgExec",
        value
      };
    },
    leaveGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
        value
      };
    }
  },
  toJSON: {
    createGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroup",
        value: MsgCreateGroup.toJSON(value)
      };
    },
    updateGroupMembers(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
        value: MsgUpdateGroupMembers.toJSON(value)
      };
    },
    updateGroupAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
        value: MsgUpdateGroupAdmin.toJSON(value)
      };
    },
    updateGroupMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
        value: MsgUpdateGroupMetadata.toJSON(value)
      };
    },
    createGroupPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
        value: MsgCreateGroupPolicy.toJSON(value)
      };
    },
    createGroupWithPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        value: MsgCreateGroupWithPolicy.toJSON(value)
      };
    },
    updateGroupPolicyAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        value: MsgUpdateGroupPolicyAdmin.toJSON(value)
      };
    },
    updateGroupPolicyDecisionPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        value: MsgUpdateGroupPolicyDecisionPolicy.toJSON(value)
      };
    },
    updateGroupPolicyMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        value: MsgUpdateGroupPolicyMetadata.toJSON(value)
      };
    },
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
        value: MsgSubmitProposal3.toJSON(value)
      };
    },
    withdrawProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
        value: MsgWithdrawProposal.toJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgVote",
        value: MsgVote3.toJSON(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgExec",
        value: MsgExec2.toJSON(value)
      };
    },
    leaveGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
        value: MsgLeaveGroup.toJSON(value)
      };
    }
  },
  fromJSON: {
    createGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroup",
        value: MsgCreateGroup.fromJSON(value)
      };
    },
    updateGroupMembers(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
        value: MsgUpdateGroupMembers.fromJSON(value)
      };
    },
    updateGroupAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
        value: MsgUpdateGroupAdmin.fromJSON(value)
      };
    },
    updateGroupMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
        value: MsgUpdateGroupMetadata.fromJSON(value)
      };
    },
    createGroupPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
        value: MsgCreateGroupPolicy.fromJSON(value)
      };
    },
    createGroupWithPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        value: MsgCreateGroupWithPolicy.fromJSON(value)
      };
    },
    updateGroupPolicyAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        value: MsgUpdateGroupPolicyAdmin.fromJSON(value)
      };
    },
    updateGroupPolicyDecisionPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        value: MsgUpdateGroupPolicyDecisionPolicy.fromJSON(value)
      };
    },
    updateGroupPolicyMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        value: MsgUpdateGroupPolicyMetadata.fromJSON(value)
      };
    },
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
        value: MsgSubmitProposal3.fromJSON(value)
      };
    },
    withdrawProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
        value: MsgWithdrawProposal.fromJSON(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgVote",
        value: MsgVote3.fromJSON(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgExec",
        value: MsgExec2.fromJSON(value)
      };
    },
    leaveGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
        value: MsgLeaveGroup.fromJSON(value)
      };
    }
  },
  fromPartial: {
    createGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroup",
        value: MsgCreateGroup.fromPartial(value)
      };
    },
    updateGroupMembers(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
        value: MsgUpdateGroupMembers.fromPartial(value)
      };
    },
    updateGroupAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
        value: MsgUpdateGroupAdmin.fromPartial(value)
      };
    },
    updateGroupMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
        value: MsgUpdateGroupMetadata.fromPartial(value)
      };
    },
    createGroupPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
        value: MsgCreateGroupPolicy.fromPartial(value)
      };
    },
    createGroupWithPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        value: MsgCreateGroupWithPolicy.fromPartial(value)
      };
    },
    updateGroupPolicyAdmin(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        value: MsgUpdateGroupPolicyAdmin.fromPartial(value)
      };
    },
    updateGroupPolicyDecisionPolicy(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        value: MsgUpdateGroupPolicyDecisionPolicy.fromPartial(value)
      };
    },
    updateGroupPolicyMetadata(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        value: MsgUpdateGroupPolicyMetadata.fromPartial(value)
      };
    },
    submitProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
        value: MsgSubmitProposal3.fromPartial(value)
      };
    },
    withdrawProposal(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
        value: MsgWithdrawProposal.fromPartial(value)
      };
    },
    vote(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgVote",
        value: MsgVote3.fromPartial(value)
      };
    },
    exec(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgExec",
        value: MsgExec2.fromPartial(value)
      };
    },
    leaveGroup(value) {
      return {
        typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
        value: MsgLeaveGroup.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/mint/v1beta1/tx.registry.js
var tx_registry_exports12 = {};
__export(tx_registry_exports12, {
  MessageComposer: () => MessageComposer12,
  load: () => load12,
  registry: () => registry12
});
var registry12 = [["/cosmos.mint.v1beta1.MsgUpdateParams", MsgUpdateParams7]];
var load12 = (protoRegistry) => {
  registry12.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer12 = {
  encoded: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.mint.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams7.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.mint.v1beta1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.mint.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams7.toJSON(value)
      };
    }
  },
  fromJSON: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.mint.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams7.fromJSON(value)
      };
    }
  },
  fromPartial: {
    updateParams(value) {
      return {
        typeUrl: "/cosmos.mint.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams7.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/nft/v1beta1/tx.registry.js
var tx_registry_exports13 = {};
__export(tx_registry_exports13, {
  MessageComposer: () => MessageComposer13,
  load: () => load13,
  registry: () => registry13
});
var registry13 = [["/cosmos.nft.v1beta1.MsgSend", MsgSend2]];
var load13 = (protoRegistry) => {
  registry13.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer13 = {
  encoded: {
    send(value) {
      return {
        typeUrl: "/cosmos.nft.v1beta1.MsgSend",
        value: MsgSend2.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    send(value) {
      return {
        typeUrl: "/cosmos.nft.v1beta1.MsgSend",
        value
      };
    }
  },
  toJSON: {
    send(value) {
      return {
        typeUrl: "/cosmos.nft.v1beta1.MsgSend",
        value: MsgSend2.toJSON(value)
      };
    }
  },
  fromJSON: {
    send(value) {
      return {
        typeUrl: "/cosmos.nft.v1beta1.MsgSend",
        value: MsgSend2.fromJSON(value)
      };
    }
  },
  fromPartial: {
    send(value) {
      return {
        typeUrl: "/cosmos.nft.v1beta1.MsgSend",
        value: MsgSend2.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/slashing/v1beta1/tx.registry.js
var tx_registry_exports14 = {};
__export(tx_registry_exports14, {
  MessageComposer: () => MessageComposer14,
  load: () => load14,
  registry: () => registry14
});
var registry14 = [["/cosmos.slashing.v1beta1.MsgUnjail", MsgUnjail], ["/cosmos.slashing.v1beta1.MsgUpdateParams", MsgUpdateParams8]];
var load14 = (protoRegistry) => {
  registry14.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer14 = {
  encoded: {
    unjail(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUnjail",
        value: MsgUnjail.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams8.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    unjail(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUnjail",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    unjail(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUnjail",
        value: MsgUnjail.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams8.toJSON(value)
      };
    }
  },
  fromJSON: {
    unjail(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUnjail",
        value: MsgUnjail.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams8.fromJSON(value)
      };
    }
  },
  fromPartial: {
    unjail(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUnjail",
        value: MsgUnjail.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.slashing.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams8.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/staking/v1beta1/tx.registry.js
var tx_registry_exports15 = {};
__export(tx_registry_exports15, {
  MessageComposer: () => MessageComposer15,
  load: () => load15,
  registry: () => registry15
});
var registry15 = [["/cosmos.staking.v1beta1.MsgCreateValidator", MsgCreateValidator], ["/cosmos.staking.v1beta1.MsgEditValidator", MsgEditValidator], ["/cosmos.staking.v1beta1.MsgDelegate", MsgDelegate], ["/cosmos.staking.v1beta1.MsgBeginRedelegate", MsgBeginRedelegate], ["/cosmos.staking.v1beta1.MsgUndelegate", MsgUndelegate], ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", MsgCancelUnbondingDelegation], ["/cosmos.staking.v1beta1.MsgUpdateParams", MsgUpdateParams9]];
var load15 = (protoRegistry) => {
  registry15.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer15 = {
  encoded: {
    createValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
        value: MsgCreateValidator.encode(value).finish()
      };
    },
    editValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
        value: MsgEditValidator.encode(value).finish()
      };
    },
    delegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: MsgDelegate.encode(value).finish()
      };
    },
    beginRedelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        value: MsgBeginRedelegate.encode(value).finish()
      };
    },
    undelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: MsgUndelegate.encode(value).finish()
      };
    },
    cancelUnbondingDelegation(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        value: MsgCancelUnbondingDelegation.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams9.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    createValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
        value
      };
    },
    editValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
        value
      };
    },
    delegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value
      };
    },
    beginRedelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        value
      };
    },
    undelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value
      };
    },
    cancelUnbondingDelegation(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
        value
      };
    }
  },
  toJSON: {
    createValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
        value: MsgCreateValidator.toJSON(value)
      };
    },
    editValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
        value: MsgEditValidator.toJSON(value)
      };
    },
    delegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: MsgDelegate.toJSON(value)
      };
    },
    beginRedelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        value: MsgBeginRedelegate.toJSON(value)
      };
    },
    undelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: MsgUndelegate.toJSON(value)
      };
    },
    cancelUnbondingDelegation(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        value: MsgCancelUnbondingDelegation.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams9.toJSON(value)
      };
    }
  },
  fromJSON: {
    createValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
        value: MsgCreateValidator.fromJSON(value)
      };
    },
    editValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
        value: MsgEditValidator.fromJSON(value)
      };
    },
    delegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: MsgDelegate.fromJSON(value)
      };
    },
    beginRedelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        value: MsgBeginRedelegate.fromJSON(value)
      };
    },
    undelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: MsgUndelegate.fromJSON(value)
      };
    },
    cancelUnbondingDelegation(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        value: MsgCancelUnbondingDelegation.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams9.fromJSON(value)
      };
    }
  },
  fromPartial: {
    createValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
        value: MsgCreateValidator.fromPartial(value)
      };
    },
    editValidator(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
        value: MsgEditValidator.fromPartial(value)
      };
    },
    delegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: MsgDelegate.fromPartial(value)
      };
    },
    beginRedelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        value: MsgBeginRedelegate.fromPartial(value)
      };
    },
    undelegate(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: MsgUndelegate.fromPartial(value)
      };
    },
    cancelUnbondingDelegation(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        value: MsgCancelUnbondingDelegation.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
        value: MsgUpdateParams9.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/upgrade/v1beta1/tx.registry.js
var tx_registry_exports16 = {};
__export(tx_registry_exports16, {
  MessageComposer: () => MessageComposer16,
  load: () => load16,
  registry: () => registry16
});
var registry16 = [["/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade", MsgSoftwareUpgrade], ["/cosmos.upgrade.v1beta1.MsgCancelUpgrade", MsgCancelUpgrade]];
var load16 = (protoRegistry) => {
  registry16.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer16 = {
  encoded: {
    softwareUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
        value: MsgSoftwareUpgrade.encode(value).finish()
      };
    },
    cancelUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
        value: MsgCancelUpgrade.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    softwareUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
        value
      };
    },
    cancelUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
        value
      };
    }
  },
  toJSON: {
    softwareUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
        value: MsgSoftwareUpgrade.toJSON(value)
      };
    },
    cancelUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
        value: MsgCancelUpgrade.toJSON(value)
      };
    }
  },
  fromJSON: {
    softwareUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
        value: MsgSoftwareUpgrade.fromJSON(value)
      };
    },
    cancelUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
        value: MsgCancelUpgrade.fromJSON(value)
      };
    }
  },
  fromPartial: {
    softwareUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
        value: MsgSoftwareUpgrade.fromPartial(value)
      };
    },
    cancelUpgrade(value) {
      return {
        typeUrl: "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
        value: MsgCancelUpgrade.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/vesting/v1beta1/tx.registry.js
var tx_registry_exports17 = {};
__export(tx_registry_exports17, {
  MessageComposer: () => MessageComposer17,
  load: () => load17,
  registry: () => registry17
});
var registry17 = [["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", MsgCreateVestingAccount], ["/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount", MsgCreatePermanentLockedAccount], ["/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount", MsgCreatePeriodicVestingAccount]];
var load17 = (protoRegistry) => {
  registry17.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer17 = {
  encoded: {
    createVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        value: MsgCreateVestingAccount.encode(value).finish()
      };
    },
    createPermanentLockedAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
        value: MsgCreatePermanentLockedAccount.encode(value).finish()
      };
    },
    createPeriodicVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
        value: MsgCreatePeriodicVestingAccount.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    createVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        value
      };
    },
    createPermanentLockedAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
        value
      };
    },
    createPeriodicVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
        value
      };
    }
  },
  toJSON: {
    createVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        value: MsgCreateVestingAccount.toJSON(value)
      };
    },
    createPermanentLockedAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
        value: MsgCreatePermanentLockedAccount.toJSON(value)
      };
    },
    createPeriodicVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
        value: MsgCreatePeriodicVestingAccount.toJSON(value)
      };
    }
  },
  fromJSON: {
    createVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        value: MsgCreateVestingAccount.fromJSON(value)
      };
    },
    createPermanentLockedAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
        value: MsgCreatePermanentLockedAccount.fromJSON(value)
      };
    },
    createPeriodicVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
        value: MsgCreatePeriodicVestingAccount.fromJSON(value)
      };
    }
  },
  fromPartial: {
    createVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        value: MsgCreateVestingAccount.fromPartial(value)
      };
    },
    createPermanentLockedAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
        value: MsgCreatePermanentLockedAccount.fromPartial(value)
      };
    },
    createPeriodicVestingAccount(value) {
      return {
        typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
        value: MsgCreatePeriodicVestingAccount.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/rpc.query.js
var rpc_query_exports = {};
__export(rpc_query_exports, {
  createRPCQueryClient: () => createRPCQueryClient
});
var import_tendermint_rpc = __toESM(require_build7());
var import_stargate = __toESM(require_build8());
var createRPCQueryClient = async ({
  rpcEndpoint
}) => {
  const tmClient = await import_tendermint_rpc.Tendermint34Client.connect(rpcEndpoint);
  const client = new import_stargate.QueryClient(tmClient);
  return {
    cosmos: {
      app: {
        v1alpha1: (await import("./query.rpc.Query-Z645J2C5.js")).createRpcQueryExtension(client)
      },
      auth: {
        v1beta1: (await import("./query.rpc.Query-HSLFEKVN.js")).createRpcQueryExtension(client)
      },
      authz: {
        v1beta1: (await import("./query.rpc.Query-VOBALZII.js")).createRpcQueryExtension(client)
      },
      autocli: {
        v1: (await import("./query.rpc.Query-3ECKZXP6.js")).createRpcQueryExtension(client)
      },
      bank: {
        v1beta1: (await import("./query.rpc.Query-IKLKUQBX.js")).createRpcQueryExtension(client)
      },
      base: {
        node: {
          v1beta1: (await import("./query.rpc.Service-OGSDUVYD.js")).createRpcQueryExtension(client)
        },
        tendermint: {
          v1beta1: (await import("./query.rpc.Service-UMVNZL3P.js")).createRpcQueryExtension(client)
        }
      },
      consensus: {
        v1: (await import("./query.rpc.Query-3VII2VNJ.js")).createRpcQueryExtension(client)
      },
      distribution: {
        v1beta1: (await import("./query.rpc.Query-OHEFBXHH.js")).createRpcQueryExtension(client)
      },
      evidence: {
        v1beta1: (await import("./query.rpc.Query-XMO4CSIX.js")).createRpcQueryExtension(client)
      },
      feegrant: {
        v1beta1: (await import("./query.rpc.Query-75IUKG33.js")).createRpcQueryExtension(client)
      },
      gov: {
        v1: (await import("./query.rpc.Query-4R3ETNBS.js")).createRpcQueryExtension(client),
        v1beta1: (await import("./query.rpc.Query-LMLDHT3F.js")).createRpcQueryExtension(client)
      },
      group: {
        v1: (await import("./query.rpc.Query-YAFZXBYA.js")).createRpcQueryExtension(client)
      },
      mint: {
        v1beta1: (await import("./query.rpc.Query-HMTMFHXZ.js")).createRpcQueryExtension(client)
      },
      nft: {
        v1beta1: (await import("./query.rpc.Query-FGSDCMTH.js")).createRpcQueryExtension(client)
      },
      orm: {
        query: {
          v1alpha1: (await import("./query.rpc.Query-PE7Q6FYK.js")).createRpcQueryExtension(client)
        }
      },
      params: {
        v1beta1: (await import("./query.rpc.Query-AEFB4JOF.js")).createRpcQueryExtension(client)
      },
      slashing: {
        v1beta1: (await import("./query.rpc.Query-S22SWOLR.js")).createRpcQueryExtension(client)
      },
      staking: {
        v1beta1: (await import("./query.rpc.Query-5LB62TJJ.js")).createRpcQueryExtension(client)
      },
      tx: {
        v1beta1: (await import("./service.rpc.Service-5OSPDZTY.js")).createRpcQueryExtension(client)
      },
      upgrade: {
        v1beta1: (await import("./query.rpc.Query-MKAFUIMA.js")).createRpcQueryExtension(client)
      }
    }
  };
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/rpc.tx.js
var rpc_tx_exports = {};
__export(rpc_tx_exports, {
  createRPCMsgClient: () => createRPCMsgClient
});
var createRPCMsgClient = async ({
  rpc
}) => ({
  cosmos: {
    auth: {
      v1beta1: new (await import("./tx.rpc.msg-BKM7GIDF.js")).MsgClientImpl(rpc)
    },
    authz: {
      v1beta1: new (await import("./tx.rpc.msg-4IOFIOJT.js")).MsgClientImpl(rpc)
    },
    bank: {
      v1beta1: new (await import("./tx.rpc.msg-GY3AG57M.js")).MsgClientImpl(rpc)
    },
    consensus: {
      v1: new (await import("./tx.rpc.msg-7IS2XNHP.js")).MsgClientImpl(rpc)
    },
    crisis: {
      v1beta1: new (await import("./tx.rpc.msg-2P7C25FF.js")).MsgClientImpl(rpc)
    },
    distribution: {
      v1beta1: new (await import("./tx.rpc.msg-5N6UVCQE.js")).MsgClientImpl(rpc)
    },
    evidence: {
      v1beta1: new (await import("./tx.rpc.msg-AIXRTESQ.js")).MsgClientImpl(rpc)
    },
    feegrant: {
      v1beta1: new (await import("./tx.rpc.msg-F3E4UQKA.js")).MsgClientImpl(rpc)
    },
    gov: {
      v1: new (await import("./tx.rpc.msg-EPAYKNRX.js")).MsgClientImpl(rpc),
      v1beta1: new (await import("./tx.rpc.msg-WTSROBNU.js")).MsgClientImpl(rpc)
    },
    group: {
      v1: new (await import("./tx.rpc.msg-3CXHGTHS.js")).MsgClientImpl(rpc)
    },
    mint: {
      v1beta1: new (await import("./tx.rpc.msg-7L6KBKRN.js")).MsgClientImpl(rpc)
    },
    nft: {
      v1beta1: new (await import("./tx.rpc.msg-PDAZEZ2U.js")).MsgClientImpl(rpc)
    },
    slashing: {
      v1beta1: new (await import("./tx.rpc.msg-GQQ4TSDM.js")).MsgClientImpl(rpc)
    },
    staking: {
      v1beta1: new (await import("./tx.rpc.msg-2OHK3UTX.js")).MsgClientImpl(rpc)
    },
    upgrade: {
      v1beta1: new (await import("./tx.rpc.msg-FXRHAFBV.js")).MsgClientImpl(rpc)
    },
    vesting: {
      v1beta1: new (await import("./tx.rpc.msg-DIHQBATM.js")).MsgClientImpl(rpc)
    }
  }
});

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/bundle.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var cosmos;
(function(_cosmos) {
  let app;
  (function(_app) {
    let runtime;
    (function(_runtime) {
      const v1alpha12 = _runtime.v1alpha1 = _objectSpread3({}, module_exports);
    })(runtime || (runtime = _app.runtime || (_app.runtime = {})));
    const v1alpha1 = _app.v1alpha1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, config_exports), module_exports2), query_exports), query_rpc_Query_exports);
  })(app || (app = _cosmos.app || (_cosmos.app = {})));
  let auth;
  (function(_auth) {
    let module;
    (function(_module) {
      const v1 = _module.v1 = _objectSpread3({}, module_exports3);
    })(module || (module = _auth.module || (_auth.module = {})));
    const v1beta1 = _auth.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, auth_exports), genesis_exports2), query_exports2), tx_exports), tx_amino_exports), tx_registry_exports), query_rpc_Query_exports2), tx_rpc_msg_exports);
  })(auth || (auth = _cosmos.auth || (_cosmos.auth = {})));
  let authz;
  (function(_authz) {
    let module;
    (function(_module2) {
      const v1 = _module2.v1 = _objectSpread3({}, module_exports4);
    })(module || (module = _authz.module || (_authz.module = {})));
    const v1beta1 = _authz.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, authz_exports), event_exports), genesis_exports3), query_exports3), tx_exports2), tx_amino_exports2), tx_registry_exports2), query_rpc_Query_exports3), tx_rpc_msg_exports2);
  })(authz || (authz = _cosmos.authz || (_cosmos.authz = {})));
  let autocli;
  (function(_autocli) {
    const v1 = _autocli.v1 = _objectSpread3(_objectSpread3(_objectSpread3({}, options_exports), query_exports4), query_rpc_Query_exports4);
  })(autocli || (autocli = _cosmos.autocli || (_cosmos.autocli = {})));
  let bank;
  (function(_bank) {
    let module;
    (function(_module3) {
      const v1 = _module3.v1 = _objectSpread3({}, module_exports5);
    })(module || (module = _bank.module || (_bank.module = {})));
    const v1beta1 = _bank.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, authz_exports2), bank_exports), genesis_exports4), query_exports5), tx_exports3), tx_amino_exports3), tx_registry_exports3), query_rpc_Query_exports5), tx_rpc_msg_exports3);
  })(bank || (bank = _cosmos.bank || (_cosmos.bank = {})));
  let base;
  (function(_base) {
    let abci;
    (function(_abci) {
      const v1beta12 = _abci.v1beta1 = _objectSpread3({}, abci_exports);
    })(abci || (abci = _base.abci || (_base.abci = {})));
    let kv;
    (function(_kv) {
      const v1beta12 = _kv.v1beta1 = _objectSpread3({}, kv_exports);
    })(kv || (kv = _base.kv || (_base.kv = {})));
    let node;
    (function(_node) {
      const v1beta12 = _node.v1beta1 = _objectSpread3(_objectSpread3({}, query_exports6), query_rpc_Service_exports);
    })(node || (node = _base.node || (_base.node = {})));
    let query2;
    (function(_query) {
      const v1beta12 = _query.v1beta1 = _objectSpread3({}, pagination_exports);
    })(query2 || (query2 = _base.query || (_base.query = {})));
    let reflection2;
    (function(_reflection) {
      const v1beta12 = _reflection.v1beta1 = _objectSpread3({}, reflection_exports);
      const v2alpha1 = _reflection.v2alpha1 = _objectSpread3({}, reflection_exports2);
    })(reflection2 || (reflection2 = _base.reflection || (_base.reflection = {})));
    let snapshots;
    (function(_snapshots) {
      const v1beta12 = _snapshots.v1beta1 = _objectSpread3({}, snapshot_exports);
    })(snapshots || (snapshots = _base.snapshots || (_base.snapshots = {})));
    let store;
    (function(_store) {
      const v1beta12 = _store.v1beta1 = _objectSpread3(_objectSpread3({}, commit_info_exports), listening_exports);
    })(store || (store = _base.store || (_base.store = {})));
    let tendermint2;
    (function(_tendermint) {
      const v1beta12 = _tendermint.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3({}, query_exports7), types_exports4), query_rpc_Service_exports2);
    })(tendermint2 || (tendermint2 = _base.tendermint || (_base.tendermint = {})));
    const v1beta1 = _base.v1beta1 = _objectSpread3({}, coin_exports);
  })(base || (base = _cosmos.base || (_cosmos.base = {})));
  let capability;
  (function(_capability) {
    let module;
    (function(_module4) {
      const v1 = _module4.v1 = _objectSpread3({}, module_exports6);
    })(module || (module = _capability.module || (_capability.module = {})));
    const v1beta1 = _capability.v1beta1 = _objectSpread3(_objectSpread3({}, capability_exports), genesis_exports5);
  })(capability || (capability = _cosmos.capability || (_cosmos.capability = {})));
  let consensus;
  (function(_consensus) {
    let module;
    (function(_module5) {
      const v12 = _module5.v1 = _objectSpread3({}, module_exports7);
    })(module || (module = _consensus.module || (_consensus.module = {})));
    const v1 = _consensus.v1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, query_exports8), tx_exports4), tx_amino_exports4), tx_registry_exports4), query_rpc_Query_exports6), tx_rpc_msg_exports4);
  })(consensus || (consensus = _cosmos.consensus || (_cosmos.consensus = {})));
  let crisis;
  (function(_crisis) {
    let module;
    (function(_module6) {
      const v1 = _module6.v1 = _objectSpread3({}, module_exports8);
    })(module || (module = _crisis.module || (_crisis.module = {})));
    const v1beta1 = _crisis.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, genesis_exports6), tx_exports5), tx_amino_exports5), tx_registry_exports5), tx_rpc_msg_exports5);
  })(crisis || (crisis = _cosmos.crisis || (_cosmos.crisis = {})));
  let crypto;
  (function(_crypto) {
    const ed25519 = _crypto.ed25519 = _objectSpread3({}, keys_exports2);
    let hd;
    (function(_hd) {
      const v1 = _hd.v1 = _objectSpread3({}, hd_exports);
    })(hd || (hd = _crypto.hd || (_crypto.hd = {})));
    let keyring;
    (function(_keyring) {
      const v1 = _keyring.v1 = _objectSpread3({}, record_exports);
    })(keyring || (keyring = _crypto.keyring || (_crypto.keyring = {})));
    const multisig = _crypto.multisig = _objectSpread3({}, keys_exports3);
    const secp256k1 = _crypto.secp256k1 = _objectSpread3({}, keys_exports4);
    const secp256r1 = _crypto.secp256r1 = _objectSpread3({}, keys_exports5);
  })(crypto || (crypto = _cosmos.crypto || (_cosmos.crypto = {})));
  let distribution;
  (function(_distribution) {
    let module;
    (function(_module7) {
      const v1 = _module7.v1 = _objectSpread3({}, module_exports9);
    })(module || (module = _distribution.module || (_distribution.module = {})));
    const v1beta1 = _distribution.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, distribution_exports), genesis_exports7), query_exports9), tx_exports6), tx_amino_exports6), tx_registry_exports6), query_rpc_Query_exports7), tx_rpc_msg_exports6);
  })(distribution || (distribution = _cosmos.distribution || (_cosmos.distribution = {})));
  let evidence;
  (function(_evidence) {
    let module;
    (function(_module8) {
      const v1 = _module8.v1 = _objectSpread3({}, module_exports10);
    })(module || (module = _evidence.module || (_evidence.module = {})));
    const v1beta1 = _evidence.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, evidence_exports2), genesis_exports8), query_exports10), tx_exports7), tx_amino_exports7), tx_registry_exports7), query_rpc_Query_exports8), tx_rpc_msg_exports7);
  })(evidence || (evidence = _cosmos.evidence || (_cosmos.evidence = {})));
  let feegrant;
  (function(_feegrant) {
    let module;
    (function(_module9) {
      const v1 = _module9.v1 = _objectSpread3({}, module_exports11);
    })(module || (module = _feegrant.module || (_feegrant.module = {})));
    const v1beta1 = _feegrant.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, feegrant_exports), genesis_exports9), query_exports11), tx_exports8), tx_amino_exports8), tx_registry_exports8), query_rpc_Query_exports9), tx_rpc_msg_exports8);
  })(feegrant || (feegrant = _cosmos.feegrant || (_cosmos.feegrant = {})));
  let genutil;
  (function(_genutil) {
    let module;
    (function(_module10) {
      const v1 = _module10.v1 = _objectSpread3({}, module_exports12);
    })(module || (module = _genutil.module || (_genutil.module = {})));
    const v1beta1 = _genutil.v1beta1 = _objectSpread3({}, genesis_exports10);
  })(genutil || (genutil = _cosmos.genutil || (_cosmos.genutil = {})));
  let gov;
  (function(_gov) {
    let module;
    (function(_module11) {
      const v12 = _module11.v1 = _objectSpread3({}, module_exports13);
    })(module || (module = _gov.module || (_gov.module = {})));
    const v1 = _gov.v1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, genesis_exports11), gov_exports), query_exports12), tx_exports9), tx_amino_exports9), tx_registry_exports9), query_rpc_Query_exports10), tx_rpc_msg_exports9);
    const v1beta1 = _gov.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, genesis_exports12), gov_exports2), query_exports13), tx_exports10), tx_amino_exports10), tx_registry_exports10), query_rpc_Query_exports11), tx_rpc_msg_exports10);
  })(gov || (gov = _cosmos.gov || (_cosmos.gov = {})));
  let group;
  (function(_group) {
    let module;
    (function(_module12) {
      const v12 = _module12.v1 = _objectSpread3({}, module_exports14);
    })(module || (module = _group.module || (_group.module = {})));
    const v1 = _group.v1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, events_exports), genesis_exports13), query_exports14), tx_exports11), types_exports6), tx_amino_exports11), tx_registry_exports11), query_rpc_Query_exports12), tx_rpc_msg_exports11);
  })(group || (group = _cosmos.group || (_cosmos.group = {})));
  let ics23;
  (function(_ics) {
    const v1 = _ics.v1 = _objectSpread3({}, proofs_exports);
  })(ics23 || (ics23 = _cosmos.ics23 || (_cosmos.ics23 = {})));
  let mint;
  (function(_mint) {
    let module;
    (function(_module13) {
      const v1 = _module13.v1 = _objectSpread3({}, module_exports15);
    })(module || (module = _mint.module || (_mint.module = {})));
    const v1beta1 = _mint.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, genesis_exports14), mint_exports), query_exports15), tx_exports12), tx_amino_exports12), tx_registry_exports12), query_rpc_Query_exports13), tx_rpc_msg_exports12);
  })(mint || (mint = _cosmos.mint || (_cosmos.mint = {})));
  let msg;
  (function(_msg) {
    const v1 = _msg.v1 = _objectSpread3({}, msg_exports);
  })(msg || (msg = _cosmos.msg || (_cosmos.msg = {})));
  let nft;
  (function(_nft) {
    let module;
    (function(_module14) {
      const v1 = _module14.v1 = _objectSpread3({}, module_exports16);
    })(module || (module = _nft.module || (_nft.module = {})));
    const v1beta1 = _nft.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, event_exports2), genesis_exports15), nft_exports), query_exports16), tx_exports13), tx_amino_exports13), tx_registry_exports13), query_rpc_Query_exports14), tx_rpc_msg_exports13);
  })(nft || (nft = _cosmos.nft || (_cosmos.nft = {})));
  let orm;
  (function(_orm) {
    let module;
    (function(_module15) {
      const v1alpha12 = _module15.v1alpha1 = _objectSpread3({}, module_exports17);
    })(module || (module = _orm.module || (_orm.module = {})));
    let query2;
    (function(_query2) {
      const v1alpha12 = _query2.v1alpha1 = _objectSpread3(_objectSpread3({}, query_exports17), query_rpc_Query_exports15);
    })(query2 || (query2 = _orm.query || (_orm.query = {})));
    const v1 = _orm.v1 = _objectSpread3({}, orm_exports);
    const v1alpha1 = _orm.v1alpha1 = _objectSpread3({}, schema_exports);
  })(orm || (orm = _cosmos.orm || (_cosmos.orm = {})));
  let params;
  (function(_params) {
    let module;
    (function(_module16) {
      const v1 = _module16.v1 = _objectSpread3({}, module_exports18);
    })(module || (module = _params.module || (_params.module = {})));
    const v1beta1 = _params.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3({}, params_exports2), query_exports18), query_rpc_Query_exports16);
  })(params || (params = _cosmos.params || (_cosmos.params = {})));
  let query;
  (function(_query3) {
    const v1 = _query3.v1 = _objectSpread3({}, query_exports33);
  })(query || (query = _cosmos.query || (_cosmos.query = {})));
  let reflection;
  (function(_reflection2) {
    const v1 = _reflection2.v1 = _objectSpread3({}, reflection_exports3);
  })(reflection || (reflection = _cosmos.reflection || (_cosmos.reflection = {})));
  let slashing;
  (function(_slashing) {
    let module;
    (function(_module17) {
      const v1 = _module17.v1 = _objectSpread3({}, module_exports19);
    })(module || (module = _slashing.module || (_slashing.module = {})));
    const v1beta1 = _slashing.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, genesis_exports16), query_exports19), slashing_exports), tx_exports14), tx_amino_exports14), tx_registry_exports14), query_rpc_Query_exports17), tx_rpc_msg_exports14);
  })(slashing || (slashing = _cosmos.slashing || (_cosmos.slashing = {})));
  let staking;
  (function(_staking) {
    let module;
    (function(_module18) {
      const v1 = _module18.v1 = _objectSpread3({}, module_exports20);
    })(module || (module = _staking.module || (_staking.module = {})));
    const v1beta1 = _staking.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, authz_exports3), genesis_exports17), query_exports20), staking_exports), tx_exports15), tx_amino_exports15), tx_registry_exports15), query_rpc_Query_exports18), tx_rpc_msg_exports15);
  })(staking || (staking = _cosmos.staking || (_cosmos.staking = {})));
  let tx;
  (function(_tx) {
    let config;
    (function(_config) {
      const v1 = _config.v1 = _objectSpread3({}, config_exports2);
    })(config || (config = _tx.config || (_tx.config = {})));
    let signing;
    (function(_signing) {
      const v1beta12 = _signing.v1beta1 = _objectSpread3({}, signing_exports);
    })(signing || (signing = _tx.signing || (_tx.signing = {})));
    const v1beta1 = _tx.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3({}, service_exports), tx_exports16), service_rpc_Service_exports);
  })(tx || (tx = _cosmos.tx || (_cosmos.tx = {})));
  let upgrade;
  (function(_upgrade) {
    let module;
    (function(_module19) {
      const v1 = _module19.v1 = _objectSpread3({}, module_exports21);
    })(module || (module = _upgrade.module || (_upgrade.module = {})));
    const v1beta1 = _upgrade.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, query_exports21), tx_exports17), upgrade_exports), tx_amino_exports16), tx_registry_exports16), query_rpc_Query_exports19), tx_rpc_msg_exports16);
  })(upgrade || (upgrade = _cosmos.upgrade || (_cosmos.upgrade = {})));
  let vesting;
  (function(_vesting) {
    let module;
    (function(_module20) {
      const v1 = _module20.v1 = _objectSpread3({}, module_exports22);
    })(module || (module = _vesting.module || (_vesting.module = {})));
    const v1beta1 = _vesting.v1beta1 = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, tx_exports18), vesting_exports), tx_amino_exports17), tx_registry_exports17), tx_rpc_msg_exports17);
  })(vesting || (vesting = _cosmos.vesting || (_cosmos.vesting = {})));
  const ClientFactory = _cosmos.ClientFactory = _objectSpread3(_objectSpread3({}, rpc_query_exports), rpc_tx_exports);
})(cosmos || (cosmos = {}));

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmos/client.js
var import_proto_signing = __toESM(require_build6());
var import_stargate2 = __toESM(require_build8());
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var cosmosAminoConverters = _objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4(_objectSpread4({}, AminoConverter), AminoConverter2), AminoConverter3), AminoConverter4), AminoConverter5), AminoConverter6), AminoConverter7), AminoConverter8), AminoConverter9), AminoConverter10), AminoConverter11), AminoConverter12), AminoConverter13), AminoConverter14), AminoConverter15), AminoConverter16), AminoConverter17);
var cosmosProtoRegistry = [...registry, ...registry2, ...registry3, ...registry4, ...registry5, ...registry6, ...registry7, ...registry8, ...registry9, ...registry10, ...registry11, ...registry12, ...registry13, ...registry14, ...registry15, ...registry16, ...registry17];
var getSigningCosmosClientOptions = () => {
  const registry28 = new import_proto_signing.Registry([...cosmosProtoRegistry]);
  const aminoTypes = new import_stargate2.AminoTypes(_objectSpread4({}, cosmosAminoConverters));
  return {
    registry: registry28,
    aminoTypes
  };
};
var getSigningCosmosClient = async ({
  rpcEndpoint,
  signer
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningCosmosClientOptions();
  const client = await import_stargate2.SigningStargateClient.connectWithSigner(rpcEndpoint, signer, {
    registry: registry28,
    aminoTypes
  });
  return client;
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/authz.js
var authz_exports4 = {};
__export(authz_exports4, {
  AcceptedMessageKeysFilter: () => AcceptedMessageKeysFilter,
  AcceptedMessagesFilter: () => AcceptedMessagesFilter,
  AllowAllMessagesFilter: () => AllowAllMessagesFilter,
  CombinedLimit: () => CombinedLimit,
  ContractExecutionAuthorization: () => ContractExecutionAuthorization,
  ContractGrant: () => ContractGrant,
  ContractMigrationAuthorization: () => ContractMigrationAuthorization,
  MaxCallsLimit: () => MaxCallsLimit,
  MaxFundsLimit: () => MaxFundsLimit
});
var _m064 = __toESM(require_minimal());
function createBaseContractExecutionAuthorization() {
  return {
    grants: []
  };
}
var ContractExecutionAuthorization = {
  encode(message, writer = _m064.Writer.create()) {
    for (const v of message.grants) {
      ContractGrant.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContractExecutionAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.grants.push(ContractGrant.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants) ? object.grants.map((e) => ContractGrant.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.grants) {
      obj.grants = message.grants.map((e) => e ? ContractGrant.toJSON(e) : void 0);
    } else {
      obj.grants = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$grants;
    const message = createBaseContractExecutionAuthorization();
    message.grants = ((_object$grants = object.grants) === null || _object$grants === void 0 ? void 0 : _object$grants.map((e) => ContractGrant.fromPartial(e))) || [];
    return message;
  }
};
function createBaseContractMigrationAuthorization() {
  return {
    grants: []
  };
}
var ContractMigrationAuthorization = {
  encode(message, writer = _m064.Writer.create()) {
    for (const v of message.grants) {
      ContractGrant.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContractMigrationAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.grants.push(ContractGrant.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants) ? object.grants.map((e) => ContractGrant.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.grants) {
      obj.grants = message.grants.map((e) => e ? ContractGrant.toJSON(e) : void 0);
    } else {
      obj.grants = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$grants2;
    const message = createBaseContractMigrationAuthorization();
    message.grants = ((_object$grants2 = object.grants) === null || _object$grants2 === void 0 ? void 0 : _object$grants2.map((e) => ContractGrant.fromPartial(e))) || [];
    return message;
  }
};
function createBaseContractGrant() {
  return {
    contract: "",
    limit: void 0,
    filter: void 0
  };
}
var ContractGrant = {
  encode(message, writer = _m064.Writer.create()) {
    if (message.contract !== "") {
      writer.uint32(10).string(message.contract);
    }
    if (message.limit !== void 0) {
      Any.encode(message.limit, writer.uint32(18).fork()).ldelim();
    }
    if (message.filter !== void 0) {
      Any.encode(message.filter, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContractGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.contract = reader.string();
          break;
        case 2:
          message.limit = Any.decode(reader, reader.uint32());
          break;
        case 3:
          message.filter = Any.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      contract: isSet(object.contract) ? String(object.contract) : "",
      limit: isSet(object.limit) ? Any.fromJSON(object.limit) : void 0,
      filter: isSet(object.filter) ? Any.fromJSON(object.filter) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.contract !== void 0 && (obj.contract = message.contract);
    message.limit !== void 0 && (obj.limit = message.limit ? Any.toJSON(message.limit) : void 0);
    message.filter !== void 0 && (obj.filter = message.filter ? Any.toJSON(message.filter) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$contract;
    const message = createBaseContractGrant();
    message.contract = (_object$contract = object.contract) !== null && _object$contract !== void 0 ? _object$contract : "";
    message.limit = object.limit !== void 0 && object.limit !== null ? Any.fromPartial(object.limit) : void 0;
    message.filter = object.filter !== void 0 && object.filter !== null ? Any.fromPartial(object.filter) : void 0;
    return message;
  }
};
function createBaseMaxCallsLimit() {
  return {
    remaining: BigInt("0")
  };
}
var MaxCallsLimit = {
  encode(message, writer = _m064.Writer.create()) {
    if (message.remaining !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.remaining.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMaxCallsLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.remaining = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      remaining: isSet(object.remaining) ? BigInt(object.remaining.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.remaining !== void 0 && (obj.remaining = (message.remaining || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMaxCallsLimit();
    message.remaining = object.remaining !== void 0 && object.remaining !== null ? BigInt(object.remaining.toString()) : BigInt("0");
    return message;
  }
};
function createBaseMaxFundsLimit() {
  return {
    amounts: []
  };
}
var MaxFundsLimit = {
  encode(message, writer = _m064.Writer.create()) {
    for (const v of message.amounts) {
      Coin.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMaxFundsLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.amounts.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      amounts: Array.isArray(object === null || object === void 0 ? void 0 : object.amounts) ? object.amounts.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.amounts) {
      obj.amounts = message.amounts.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.amounts = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$amounts;
    const message = createBaseMaxFundsLimit();
    message.amounts = ((_object$amounts = object.amounts) === null || _object$amounts === void 0 ? void 0 : _object$amounts.map((e) => Coin.fromPartial(e))) || [];
    return message;
  }
};
function createBaseCombinedLimit() {
  return {
    callsRemaining: BigInt("0"),
    amounts: []
  };
}
var CombinedLimit = {
  encode(message, writer = _m064.Writer.create()) {
    if (message.callsRemaining !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.callsRemaining.toString()));
    }
    for (const v of message.amounts) {
      Coin.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCombinedLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.callsRemaining = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.amounts.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      callsRemaining: isSet(object.callsRemaining) ? BigInt(object.callsRemaining.toString()) : BigInt("0"),
      amounts: Array.isArray(object === null || object === void 0 ? void 0 : object.amounts) ? object.amounts.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.callsRemaining !== void 0 && (obj.callsRemaining = (message.callsRemaining || BigInt("0")).toString());
    if (message.amounts) {
      obj.amounts = message.amounts.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.amounts = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$amounts2;
    const message = createBaseCombinedLimit();
    message.callsRemaining = object.callsRemaining !== void 0 && object.callsRemaining !== null ? BigInt(object.callsRemaining.toString()) : BigInt("0");
    message.amounts = ((_object$amounts2 = object.amounts) === null || _object$amounts2 === void 0 ? void 0 : _object$amounts2.map((e) => Coin.fromPartial(e))) || [];
    return message;
  }
};
function createBaseAllowAllMessagesFilter() {
  return {};
}
var AllowAllMessagesFilter = {
  encode(_, writer = _m064.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAllowAllMessagesFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseAllowAllMessagesFilter();
    return message;
  }
};
function createBaseAcceptedMessageKeysFilter() {
  return {
    keys: []
  };
}
var AcceptedMessageKeysFilter = {
  encode(message, writer = _m064.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptedMessageKeysFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys) ? object.keys.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys) {
      obj.keys = message.keys.map((e) => e);
    } else {
      obj.keys = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$keys;
    const message = createBaseAcceptedMessageKeysFilter();
    message.keys = ((_object$keys = object.keys) === null || _object$keys === void 0 ? void 0 : _object$keys.map((e) => e)) || [];
    return message;
  }
};
function createBaseAcceptedMessagesFilter() {
  return {
    messages: []
  };
}
var AcceptedMessagesFilter = {
  encode(message, writer = _m064.Writer.create()) {
    for (const v of message.messages) {
      writer.uint32(10).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m064.Reader ? input : new _m064.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptedMessagesFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messages.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e) => bytesFromBase64(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.messages = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$messages;
    const message = createBaseAcceptedMessagesFilter();
    message.messages = ((_object$messages = object.messages) === null || _object$messages === void 0 ? void 0 : _object$messages.map((e) => e)) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/genesis.js
var genesis_exports18 = {};
__export(genesis_exports18, {
  Code: () => Code,
  Contract: () => Contract,
  GenesisState: () => GenesisState17,
  Sequence: () => Sequence
});
var _m065 = __toESM(require_minimal());
function createBaseGenesisState17() {
  return {
    params: void 0,
    codes: [],
    contracts: [],
    sequences: []
  };
}
var GenesisState17 = {
  encode(message, writer = _m065.Writer.create()) {
    if (message.params !== void 0) {
      Params8.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.codes) {
      Code.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contracts) {
      Contract.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.sequences) {
      Sequence.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m065.Reader ? input : new _m065.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState17();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params8.decode(reader, reader.uint32());
          break;
        case 2:
          message.codes.push(Code.decode(reader, reader.uint32()));
          break;
        case 3:
          message.contracts.push(Contract.decode(reader, reader.uint32()));
          break;
        case 4:
          message.sequences.push(Sequence.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params8.fromJSON(object.params) : void 0,
      codes: Array.isArray(object === null || object === void 0 ? void 0 : object.codes) ? object.codes.map((e) => Code.fromJSON(e)) : [],
      contracts: Array.isArray(object === null || object === void 0 ? void 0 : object.contracts) ? object.contracts.map((e) => Contract.fromJSON(e)) : [],
      sequences: Array.isArray(object === null || object === void 0 ? void 0 : object.sequences) ? object.sequences.map((e) => Sequence.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params8.toJSON(message.params) : void 0);
    if (message.codes) {
      obj.codes = message.codes.map((e) => e ? Code.toJSON(e) : void 0);
    } else {
      obj.codes = [];
    }
    if (message.contracts) {
      obj.contracts = message.contracts.map((e) => e ? Contract.toJSON(e) : void 0);
    } else {
      obj.contracts = [];
    }
    if (message.sequences) {
      obj.sequences = message.sequences.map((e) => e ? Sequence.toJSON(e) : void 0);
    } else {
      obj.sequences = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$codes, _object$contracts, _object$sequences;
    const message = createBaseGenesisState17();
    message.params = object.params !== void 0 && object.params !== null ? Params8.fromPartial(object.params) : void 0;
    message.codes = ((_object$codes = object.codes) === null || _object$codes === void 0 ? void 0 : _object$codes.map((e) => Code.fromPartial(e))) || [];
    message.contracts = ((_object$contracts = object.contracts) === null || _object$contracts === void 0 ? void 0 : _object$contracts.map((e) => Contract.fromPartial(e))) || [];
    message.sequences = ((_object$sequences = object.sequences) === null || _object$sequences === void 0 ? void 0 : _object$sequences.map((e) => Sequence.fromPartial(e))) || [];
    return message;
  }
};
function createBaseCode() {
  return {
    codeId: BigInt("0"),
    codeInfo: void 0,
    codeBytes: new Uint8Array(),
    pinned: false
  };
}
var Code = {
  encode(message, writer = _m065.Writer.create()) {
    if (message.codeId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.codeId.toString()));
    }
    if (message.codeInfo !== void 0) {
      CodeInfo.encode(message.codeInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.codeBytes.length !== 0) {
      writer.uint32(26).bytes(message.codeBytes);
    }
    if (message.pinned === true) {
      writer.uint32(32).bool(message.pinned);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m065.Reader ? input : new _m065.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codeId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.codeInfo = CodeInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.codeBytes = reader.bytes();
          break;
        case 4:
          message.pinned = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codeId: isSet(object.codeId) ? BigInt(object.codeId.toString()) : BigInt("0"),
      codeInfo: isSet(object.codeInfo) ? CodeInfo.fromJSON(object.codeInfo) : void 0,
      codeBytes: isSet(object.codeBytes) ? bytesFromBase64(object.codeBytes) : new Uint8Array(),
      pinned: isSet(object.pinned) ? Boolean(object.pinned) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt("0")).toString());
    message.codeInfo !== void 0 && (obj.codeInfo = message.codeInfo ? CodeInfo.toJSON(message.codeInfo) : void 0);
    message.codeBytes !== void 0 && (obj.codeBytes = base64FromBytes(message.codeBytes !== void 0 ? message.codeBytes : new Uint8Array()));
    message.pinned !== void 0 && (obj.pinned = message.pinned);
    return obj;
  },
  fromPartial(object) {
    var _object$codeBytes, _object$pinned;
    const message = createBaseCode();
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? BigInt(object.codeId.toString()) : BigInt("0");
    message.codeInfo = object.codeInfo !== void 0 && object.codeInfo !== null ? CodeInfo.fromPartial(object.codeInfo) : void 0;
    message.codeBytes = (_object$codeBytes = object.codeBytes) !== null && _object$codeBytes !== void 0 ? _object$codeBytes : new Uint8Array();
    message.pinned = (_object$pinned = object.pinned) !== null && _object$pinned !== void 0 ? _object$pinned : false;
    return message;
  }
};
function createBaseContract() {
  return {
    contractAddress: "",
    contractInfo: void 0,
    contractState: [],
    contractCodeHistory: []
  };
}
var Contract = {
  encode(message, writer = _m065.Writer.create()) {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.contractInfo !== void 0) {
      ContractInfo.encode(message.contractInfo, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contractState) {
      Model.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.contractCodeHistory) {
      ContractCodeHistoryEntry.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m065.Reader ? input : new _m065.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.contractAddress = reader.string();
          break;
        case 2:
          message.contractInfo = ContractInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.contractState.push(Model.decode(reader, reader.uint32()));
          break;
        case 4:
          message.contractCodeHistory.push(ContractCodeHistoryEntry.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
      contractInfo: isSet(object.contractInfo) ? ContractInfo.fromJSON(object.contractInfo) : void 0,
      contractState: Array.isArray(object === null || object === void 0 ? void 0 : object.contractState) ? object.contractState.map((e) => Model.fromJSON(e)) : [],
      contractCodeHistory: Array.isArray(object === null || object === void 0 ? void 0 : object.contractCodeHistory) ? object.contractCodeHistory.map((e) => ContractCodeHistoryEntry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.contractAddress !== void 0 && (obj.contractAddress = message.contractAddress);
    message.contractInfo !== void 0 && (obj.contractInfo = message.contractInfo ? ContractInfo.toJSON(message.contractInfo) : void 0);
    if (message.contractState) {
      obj.contractState = message.contractState.map((e) => e ? Model.toJSON(e) : void 0);
    } else {
      obj.contractState = [];
    }
    if (message.contractCodeHistory) {
      obj.contractCodeHistory = message.contractCodeHistory.map((e) => e ? ContractCodeHistoryEntry.toJSON(e) : void 0);
    } else {
      obj.contractCodeHistory = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$contractAddre, _object$contractState, _object$contractCodeH;
    const message = createBaseContract();
    message.contractAddress = (_object$contractAddre = object.contractAddress) !== null && _object$contractAddre !== void 0 ? _object$contractAddre : "";
    message.contractInfo = object.contractInfo !== void 0 && object.contractInfo !== null ? ContractInfo.fromPartial(object.contractInfo) : void 0;
    message.contractState = ((_object$contractState = object.contractState) === null || _object$contractState === void 0 ? void 0 : _object$contractState.map((e) => Model.fromPartial(e))) || [];
    message.contractCodeHistory = ((_object$contractCodeH = object.contractCodeHistory) === null || _object$contractCodeH === void 0 ? void 0 : _object$contractCodeH.map((e) => ContractCodeHistoryEntry.fromPartial(e))) || [];
    return message;
  }
};
function createBaseSequence() {
  return {
    idKey: new Uint8Array(),
    value: BigInt("0")
  };
}
var Sequence = {
  encode(message, writer = _m065.Writer.create()) {
    if (message.idKey.length !== 0) {
      writer.uint32(10).bytes(message.idKey);
    }
    if (message.value !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.value.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m065.Reader ? input : new _m065.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.idKey = reader.bytes();
          break;
        case 2:
          message.value = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      idKey: isSet(object.idKey) ? bytesFromBase64(object.idKey) : new Uint8Array(),
      value: isSet(object.value) ? BigInt(object.value.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.idKey !== void 0 && (obj.idKey = base64FromBytes(message.idKey !== void 0 ? message.idKey : new Uint8Array()));
    message.value !== void 0 && (obj.value = (message.value || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$idKey;
    const message = createBaseSequence();
    message.idKey = (_object$idKey = object.idKey) !== null && _object$idKey !== void 0 ? _object$idKey : new Uint8Array();
    message.value = object.value !== void 0 && object.value !== null ? BigInt(object.value.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/ibc.js
var ibc_exports = {};
__export(ibc_exports, {
  MsgIBCCloseChannel: () => MsgIBCCloseChannel,
  MsgIBCSend: () => MsgIBCSend,
  MsgIBCSendResponse: () => MsgIBCSendResponse
});
var _m066 = __toESM(require_minimal());
function createBaseMsgIBCSend() {
  return {
    channel: "",
    timeoutHeight: BigInt("0"),
    timeoutTimestamp: BigInt("0"),
    data: new Uint8Array()
  };
}
var MsgIBCSend = {
  encode(message, writer = _m066.Writer.create()) {
    if (message.channel !== "") {
      writer.uint32(18).string(message.channel);
    }
    if (message.timeoutHeight !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.timeoutHeight.toString()));
    }
    if (message.timeoutTimestamp !== BigInt(0)) {
      writer.uint32(40).uint64(import_long.default.fromString(message.timeoutTimestamp.toString()));
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m066.Reader ? input : new _m066.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgIBCSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.channel = reader.string();
          break;
        case 4:
          message.timeoutHeight = BigInt(reader.uint64().toString());
          break;
        case 5:
          message.timeoutTimestamp = BigInt(reader.uint64().toString());
          break;
        case 6:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      channel: isSet(object.channel) ? String(object.channel) : "",
      timeoutHeight: isSet(object.timeoutHeight) ? BigInt(object.timeoutHeight.toString()) : BigInt("0"),
      timeoutTimestamp: isSet(object.timeoutTimestamp) ? BigInt(object.timeoutTimestamp.toString()) : BigInt("0"),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.channel !== void 0 && (obj.channel = message.channel);
    message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || BigInt("0")).toString());
    message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt("0")).toString());
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$channel, _object$data;
    const message = createBaseMsgIBCSend();
    message.channel = (_object$channel = object.channel) !== null && _object$channel !== void 0 ? _object$channel : "";
    message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? BigInt(object.timeoutHeight.toString()) : BigInt("0");
    message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? BigInt(object.timeoutTimestamp.toString()) : BigInt("0");
    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();
    return message;
  }
};
function createBaseMsgIBCSendResponse() {
  return {
    sequence: BigInt("0")
  };
}
var MsgIBCSendResponse = {
  encode(message, writer = _m066.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m066.Reader ? input : new _m066.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgIBCSendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMsgIBCSendResponse();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    return message;
  }
};
function createBaseMsgIBCCloseChannel() {
  return {
    channel: ""
  };
}
var MsgIBCCloseChannel = {
  encode(message, writer = _m066.Writer.create()) {
    if (message.channel !== "") {
      writer.uint32(18).string(message.channel);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m066.Reader ? input : new _m066.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgIBCCloseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.channel = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      channel: isSet(object.channel) ? String(object.channel) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.channel !== void 0 && (obj.channel = message.channel);
    return obj;
  },
  fromPartial(object) {
    var _object$channel2;
    const message = createBaseMsgIBCCloseChannel();
    message.channel = (_object$channel2 = object.channel) !== null && _object$channel2 !== void 0 ? _object$channel2 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/proposal.js
var proposal_exports = {};
__export(proposal_exports, {
  AccessConfigUpdate: () => AccessConfigUpdate,
  ClearAdminProposal: () => ClearAdminProposal,
  ExecuteContractProposal: () => ExecuteContractProposal,
  InstantiateContract2Proposal: () => InstantiateContract2Proposal,
  InstantiateContractProposal: () => InstantiateContractProposal,
  MigrateContractProposal: () => MigrateContractProposal,
  PinCodesProposal: () => PinCodesProposal,
  StoreAndInstantiateContractProposal: () => StoreAndInstantiateContractProposal,
  StoreCodeProposal: () => StoreCodeProposal,
  SudoContractProposal: () => SudoContractProposal,
  UnpinCodesProposal: () => UnpinCodesProposal,
  UpdateAdminProposal: () => UpdateAdminProposal,
  UpdateInstantiateConfigProposal: () => UpdateInstantiateConfigProposal
});
var _m067 = __toESM(require_minimal());
function createBaseStoreCodeProposal() {
  return {
    title: "",
    description: "",
    runAs: "",
    wasmByteCode: new Uint8Array(),
    instantiatePermission: void 0,
    unpinCode: false,
    source: "",
    builder: "",
    codeHash: new Uint8Array()
  };
}
var StoreCodeProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runAs !== "") {
      writer.uint32(26).string(message.runAs);
    }
    if (message.wasmByteCode.length !== 0) {
      writer.uint32(34).bytes(message.wasmByteCode);
    }
    if (message.instantiatePermission !== void 0) {
      AccessConfig.encode(message.instantiatePermission, writer.uint32(58).fork()).ldelim();
    }
    if (message.unpinCode === true) {
      writer.uint32(64).bool(message.unpinCode);
    }
    if (message.source !== "") {
      writer.uint32(74).string(message.source);
    }
    if (message.builder !== "") {
      writer.uint32(82).string(message.builder);
    }
    if (message.codeHash.length !== 0) {
      writer.uint32(90).bytes(message.codeHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoreCodeProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.runAs = reader.string();
          break;
        case 4:
          message.wasmByteCode = reader.bytes();
          break;
        case 7:
          message.instantiatePermission = AccessConfig.decode(reader, reader.uint32());
          break;
        case 8:
          message.unpinCode = reader.bool();
          break;
        case 9:
          message.source = reader.string();
          break;
        case 10:
          message.builder = reader.string();
          break;
        case 11:
          message.codeHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      runAs: isSet(object.runAs) ? String(object.runAs) : "",
      wasmByteCode: isSet(object.wasmByteCode) ? bytesFromBase64(object.wasmByteCode) : new Uint8Array(),
      instantiatePermission: isSet(object.instantiatePermission) ? AccessConfig.fromJSON(object.instantiatePermission) : void 0,
      unpinCode: isSet(object.unpinCode) ? Boolean(object.unpinCode) : false,
      source: isSet(object.source) ? String(object.source) : "",
      builder: isSet(object.builder) ? String(object.builder) : "",
      codeHash: isSet(object.codeHash) ? bytesFromBase64(object.codeHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.wasmByteCode !== void 0 && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
    message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? AccessConfig.toJSON(message.instantiatePermission) : void 0);
    message.unpinCode !== void 0 && (obj.unpinCode = message.unpinCode);
    message.source !== void 0 && (obj.source = message.source);
    message.builder !== void 0 && (obj.builder = message.builder);
    message.codeHash !== void 0 && (obj.codeHash = base64FromBytes(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$title, _object$description, _object$runAs, _object$wasmByteCode, _object$unpinCode, _object$source, _object$builder, _object$codeHash;
    const message = createBaseStoreCodeProposal();
    message.title = (_object$title = object.title) !== null && _object$title !== void 0 ? _object$title : "";
    message.description = (_object$description = object.description) !== null && _object$description !== void 0 ? _object$description : "";
    message.runAs = (_object$runAs = object.runAs) !== null && _object$runAs !== void 0 ? _object$runAs : "";
    message.wasmByteCode = (_object$wasmByteCode = object.wasmByteCode) !== null && _object$wasmByteCode !== void 0 ? _object$wasmByteCode : new Uint8Array();
    message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? AccessConfig.fromPartial(object.instantiatePermission) : void 0;
    message.unpinCode = (_object$unpinCode = object.unpinCode) !== null && _object$unpinCode !== void 0 ? _object$unpinCode : false;
    message.source = (_object$source = object.source) !== null && _object$source !== void 0 ? _object$source : "";
    message.builder = (_object$builder = object.builder) !== null && _object$builder !== void 0 ? _object$builder : "";
    message.codeHash = (_object$codeHash = object.codeHash) !== null && _object$codeHash !== void 0 ? _object$codeHash : new Uint8Array();
    return message;
  }
};
function createBaseInstantiateContractProposal() {
  return {
    title: "",
    description: "",
    runAs: "",
    admin: "",
    codeId: BigInt("0"),
    label: "",
    msg: new Uint8Array(),
    funds: []
  };
}
var InstantiateContractProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runAs !== "") {
      writer.uint32(26).string(message.runAs);
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    if (message.codeId !== BigInt(0)) {
      writer.uint32(40).uint64(import_long.default.fromString(message.codeId.toString()));
    }
    if (message.label !== "") {
      writer.uint32(50).string(message.label);
    }
    if (message.msg.length !== 0) {
      writer.uint32(58).bytes(message.msg);
    }
    for (const v of message.funds) {
      Coin.encode(v, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstantiateContractProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.runAs = reader.string();
          break;
        case 4:
          message.admin = reader.string();
          break;
        case 5:
          message.codeId = BigInt(reader.uint64().toString());
          break;
        case 6:
          message.label = reader.string();
          break;
        case 7:
          message.msg = reader.bytes();
          break;
        case 8:
          message.funds.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      runAs: isSet(object.runAs) ? String(object.runAs) : "",
      admin: isSet(object.admin) ? String(object.admin) : "",
      codeId: isSet(object.codeId) ? BigInt(object.codeId.toString()) : BigInt("0"),
      label: isSet(object.label) ? String(object.label) : "",
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
      funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.admin !== void 0 && (obj.admin = message.admin);
    message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt("0")).toString());
    message.label !== void 0 && (obj.label = message.label);
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    if (message.funds) {
      obj.funds = message.funds.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.funds = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$title2, _object$description2, _object$runAs2, _object$admin, _object$label, _object$msg, _object$funds;
    const message = createBaseInstantiateContractProposal();
    message.title = (_object$title2 = object.title) !== null && _object$title2 !== void 0 ? _object$title2 : "";
    message.description = (_object$description2 = object.description) !== null && _object$description2 !== void 0 ? _object$description2 : "";
    message.runAs = (_object$runAs2 = object.runAs) !== null && _object$runAs2 !== void 0 ? _object$runAs2 : "";
    message.admin = (_object$admin = object.admin) !== null && _object$admin !== void 0 ? _object$admin : "";
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? BigInt(object.codeId.toString()) : BigInt("0");
    message.label = (_object$label = object.label) !== null && _object$label !== void 0 ? _object$label : "";
    message.msg = (_object$msg = object.msg) !== null && _object$msg !== void 0 ? _object$msg : new Uint8Array();
    message.funds = ((_object$funds = object.funds) === null || _object$funds === void 0 ? void 0 : _object$funds.map((e) => Coin.fromPartial(e))) || [];
    return message;
  }
};
function createBaseInstantiateContract2Proposal() {
  return {
    title: "",
    description: "",
    runAs: "",
    admin: "",
    codeId: BigInt("0"),
    label: "",
    msg: new Uint8Array(),
    funds: [],
    salt: new Uint8Array(),
    fixMsg: false
  };
}
var InstantiateContract2Proposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runAs !== "") {
      writer.uint32(26).string(message.runAs);
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    if (message.codeId !== BigInt(0)) {
      writer.uint32(40).uint64(import_long.default.fromString(message.codeId.toString()));
    }
    if (message.label !== "") {
      writer.uint32(50).string(message.label);
    }
    if (message.msg.length !== 0) {
      writer.uint32(58).bytes(message.msg);
    }
    for (const v of message.funds) {
      Coin.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.salt.length !== 0) {
      writer.uint32(74).bytes(message.salt);
    }
    if (message.fixMsg === true) {
      writer.uint32(80).bool(message.fixMsg);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstantiateContract2Proposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.runAs = reader.string();
          break;
        case 4:
          message.admin = reader.string();
          break;
        case 5:
          message.codeId = BigInt(reader.uint64().toString());
          break;
        case 6:
          message.label = reader.string();
          break;
        case 7:
          message.msg = reader.bytes();
          break;
        case 8:
          message.funds.push(Coin.decode(reader, reader.uint32()));
          break;
        case 9:
          message.salt = reader.bytes();
          break;
        case 10:
          message.fixMsg = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      runAs: isSet(object.runAs) ? String(object.runAs) : "",
      admin: isSet(object.admin) ? String(object.admin) : "",
      codeId: isSet(object.codeId) ? BigInt(object.codeId.toString()) : BigInt("0"),
      label: isSet(object.label) ? String(object.label) : "",
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
      funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => Coin.fromJSON(e)) : [],
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(),
      fixMsg: isSet(object.fixMsg) ? Boolean(object.fixMsg) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.admin !== void 0 && (obj.admin = message.admin);
    message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt("0")).toString());
    message.label !== void 0 && (obj.label = message.label);
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    if (message.funds) {
      obj.funds = message.funds.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.funds = [];
    }
    message.salt !== void 0 && (obj.salt = base64FromBytes(message.salt !== void 0 ? message.salt : new Uint8Array()));
    message.fixMsg !== void 0 && (obj.fixMsg = message.fixMsg);
    return obj;
  },
  fromPartial(object) {
    var _object$title3, _object$description3, _object$runAs3, _object$admin2, _object$label2, _object$msg2, _object$funds2, _object$salt, _object$fixMsg;
    const message = createBaseInstantiateContract2Proposal();
    message.title = (_object$title3 = object.title) !== null && _object$title3 !== void 0 ? _object$title3 : "";
    message.description = (_object$description3 = object.description) !== null && _object$description3 !== void 0 ? _object$description3 : "";
    message.runAs = (_object$runAs3 = object.runAs) !== null && _object$runAs3 !== void 0 ? _object$runAs3 : "";
    message.admin = (_object$admin2 = object.admin) !== null && _object$admin2 !== void 0 ? _object$admin2 : "";
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? BigInt(object.codeId.toString()) : BigInt("0");
    message.label = (_object$label2 = object.label) !== null && _object$label2 !== void 0 ? _object$label2 : "";
    message.msg = (_object$msg2 = object.msg) !== null && _object$msg2 !== void 0 ? _object$msg2 : new Uint8Array();
    message.funds = ((_object$funds2 = object.funds) === null || _object$funds2 === void 0 ? void 0 : _object$funds2.map((e) => Coin.fromPartial(e))) || [];
    message.salt = (_object$salt = object.salt) !== null && _object$salt !== void 0 ? _object$salt : new Uint8Array();
    message.fixMsg = (_object$fixMsg = object.fixMsg) !== null && _object$fixMsg !== void 0 ? _object$fixMsg : false;
    return message;
  }
};
function createBaseMigrateContractProposal() {
  return {
    title: "",
    description: "",
    contract: "",
    codeId: BigInt("0"),
    msg: new Uint8Array()
  };
}
var MigrateContractProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.contract !== "") {
      writer.uint32(34).string(message.contract);
    }
    if (message.codeId !== BigInt(0)) {
      writer.uint32(40).uint64(import_long.default.fromString(message.codeId.toString()));
    }
    if (message.msg.length !== 0) {
      writer.uint32(50).bytes(message.msg);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMigrateContractProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 4:
          message.contract = reader.string();
          break;
        case 5:
          message.codeId = BigInt(reader.uint64().toString());
          break;
        case 6:
          message.msg = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contract: isSet(object.contract) ? String(object.contract) : "",
      codeId: isSet(object.codeId) ? BigInt(object.codeId.toString()) : BigInt("0"),
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.contract !== void 0 && (obj.contract = message.contract);
    message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt("0")).toString());
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$title4, _object$description4, _object$contract, _object$msg3;
    const message = createBaseMigrateContractProposal();
    message.title = (_object$title4 = object.title) !== null && _object$title4 !== void 0 ? _object$title4 : "";
    message.description = (_object$description4 = object.description) !== null && _object$description4 !== void 0 ? _object$description4 : "";
    message.contract = (_object$contract = object.contract) !== null && _object$contract !== void 0 ? _object$contract : "";
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? BigInt(object.codeId.toString()) : BigInt("0");
    message.msg = (_object$msg3 = object.msg) !== null && _object$msg3 !== void 0 ? _object$msg3 : new Uint8Array();
    return message;
  }
};
function createBaseSudoContractProposal() {
  return {
    title: "",
    description: "",
    contract: "",
    msg: new Uint8Array()
  };
}
var SudoContractProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.contract !== "") {
      writer.uint32(26).string(message.contract);
    }
    if (message.msg.length !== 0) {
      writer.uint32(34).bytes(message.msg);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSudoContractProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.contract = reader.string();
          break;
        case 4:
          message.msg = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contract: isSet(object.contract) ? String(object.contract) : "",
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.contract !== void 0 && (obj.contract = message.contract);
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$title5, _object$description5, _object$contract2, _object$msg4;
    const message = createBaseSudoContractProposal();
    message.title = (_object$title5 = object.title) !== null && _object$title5 !== void 0 ? _object$title5 : "";
    message.description = (_object$description5 = object.description) !== null && _object$description5 !== void 0 ? _object$description5 : "";
    message.contract = (_object$contract2 = object.contract) !== null && _object$contract2 !== void 0 ? _object$contract2 : "";
    message.msg = (_object$msg4 = object.msg) !== null && _object$msg4 !== void 0 ? _object$msg4 : new Uint8Array();
    return message;
  }
};
function createBaseExecuteContractProposal() {
  return {
    title: "",
    description: "",
    runAs: "",
    contract: "",
    msg: new Uint8Array(),
    funds: []
  };
}
var ExecuteContractProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runAs !== "") {
      writer.uint32(26).string(message.runAs);
    }
    if (message.contract !== "") {
      writer.uint32(34).string(message.contract);
    }
    if (message.msg.length !== 0) {
      writer.uint32(42).bytes(message.msg);
    }
    for (const v of message.funds) {
      Coin.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExecuteContractProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.runAs = reader.string();
          break;
        case 4:
          message.contract = reader.string();
          break;
        case 5:
          message.msg = reader.bytes();
          break;
        case 6:
          message.funds.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      runAs: isSet(object.runAs) ? String(object.runAs) : "",
      contract: isSet(object.contract) ? String(object.contract) : "",
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
      funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.contract !== void 0 && (obj.contract = message.contract);
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    if (message.funds) {
      obj.funds = message.funds.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.funds = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$title6, _object$description6, _object$runAs4, _object$contract3, _object$msg5, _object$funds3;
    const message = createBaseExecuteContractProposal();
    message.title = (_object$title6 = object.title) !== null && _object$title6 !== void 0 ? _object$title6 : "";
    message.description = (_object$description6 = object.description) !== null && _object$description6 !== void 0 ? _object$description6 : "";
    message.runAs = (_object$runAs4 = object.runAs) !== null && _object$runAs4 !== void 0 ? _object$runAs4 : "";
    message.contract = (_object$contract3 = object.contract) !== null && _object$contract3 !== void 0 ? _object$contract3 : "";
    message.msg = (_object$msg5 = object.msg) !== null && _object$msg5 !== void 0 ? _object$msg5 : new Uint8Array();
    message.funds = ((_object$funds3 = object.funds) === null || _object$funds3 === void 0 ? void 0 : _object$funds3.map((e) => Coin.fromPartial(e))) || [];
    return message;
  }
};
function createBaseUpdateAdminProposal() {
  return {
    title: "",
    description: "",
    newAdmin: "",
    contract: ""
  };
}
var UpdateAdminProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.newAdmin !== "") {
      writer.uint32(26).string(message.newAdmin);
    }
    if (message.contract !== "") {
      writer.uint32(34).string(message.contract);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAdminProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.newAdmin = reader.string();
          break;
        case 4:
          message.contract = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      newAdmin: isSet(object.newAdmin) ? String(object.newAdmin) : "",
      contract: isSet(object.contract) ? String(object.contract) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
    message.contract !== void 0 && (obj.contract = message.contract);
    return obj;
  },
  fromPartial(object) {
    var _object$title7, _object$description7, _object$newAdmin, _object$contract4;
    const message = createBaseUpdateAdminProposal();
    message.title = (_object$title7 = object.title) !== null && _object$title7 !== void 0 ? _object$title7 : "";
    message.description = (_object$description7 = object.description) !== null && _object$description7 !== void 0 ? _object$description7 : "";
    message.newAdmin = (_object$newAdmin = object.newAdmin) !== null && _object$newAdmin !== void 0 ? _object$newAdmin : "";
    message.contract = (_object$contract4 = object.contract) !== null && _object$contract4 !== void 0 ? _object$contract4 : "";
    return message;
  }
};
function createBaseClearAdminProposal() {
  return {
    title: "",
    description: "",
    contract: ""
  };
}
var ClearAdminProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.contract !== "") {
      writer.uint32(26).string(message.contract);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearAdminProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.contract = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contract: isSet(object.contract) ? String(object.contract) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.contract !== void 0 && (obj.contract = message.contract);
    return obj;
  },
  fromPartial(object) {
    var _object$title8, _object$description8, _object$contract5;
    const message = createBaseClearAdminProposal();
    message.title = (_object$title8 = object.title) !== null && _object$title8 !== void 0 ? _object$title8 : "";
    message.description = (_object$description8 = object.description) !== null && _object$description8 !== void 0 ? _object$description8 : "";
    message.contract = (_object$contract5 = object.contract) !== null && _object$contract5 !== void 0 ? _object$contract5 : "";
    return message;
  }
};
function createBasePinCodesProposal() {
  return {
    title: "",
    description: "",
    codeIds: []
  };
}
var PinCodesProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    writer.uint32(26).fork();
    for (const v of message.codeIds) {
      writer.uint64(import_long.default.fromString(v.toString()));
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinCodesProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.codeIds.push(BigInt(reader.uint64().toString()));
            }
          } else {
            message.codeIds.push(BigInt(reader.uint64().toString()));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      codeIds: Array.isArray(object === null || object === void 0 ? void 0 : object.codeIds) ? object.codeIds.map((e) => BigInt(e.toString())) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    if (message.codeIds) {
      obj.codeIds = message.codeIds.map((e) => (e || BigInt("0")).toString());
    } else {
      obj.codeIds = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$title9, _object$description9, _object$codeIds;
    const message = createBasePinCodesProposal();
    message.title = (_object$title9 = object.title) !== null && _object$title9 !== void 0 ? _object$title9 : "";
    message.description = (_object$description9 = object.description) !== null && _object$description9 !== void 0 ? _object$description9 : "";
    message.codeIds = ((_object$codeIds = object.codeIds) === null || _object$codeIds === void 0 ? void 0 : _object$codeIds.map((e) => BigInt(e.toString()))) || [];
    return message;
  }
};
function createBaseUnpinCodesProposal() {
  return {
    title: "",
    description: "",
    codeIds: []
  };
}
var UnpinCodesProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    writer.uint32(26).fork();
    for (const v of message.codeIds) {
      writer.uint64(import_long.default.fromString(v.toString()));
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinCodesProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.codeIds.push(BigInt(reader.uint64().toString()));
            }
          } else {
            message.codeIds.push(BigInt(reader.uint64().toString()));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      codeIds: Array.isArray(object === null || object === void 0 ? void 0 : object.codeIds) ? object.codeIds.map((e) => BigInt(e.toString())) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    if (message.codeIds) {
      obj.codeIds = message.codeIds.map((e) => (e || BigInt("0")).toString());
    } else {
      obj.codeIds = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$title10, _object$description10, _object$codeIds2;
    const message = createBaseUnpinCodesProposal();
    message.title = (_object$title10 = object.title) !== null && _object$title10 !== void 0 ? _object$title10 : "";
    message.description = (_object$description10 = object.description) !== null && _object$description10 !== void 0 ? _object$description10 : "";
    message.codeIds = ((_object$codeIds2 = object.codeIds) === null || _object$codeIds2 === void 0 ? void 0 : _object$codeIds2.map((e) => BigInt(e.toString()))) || [];
    return message;
  }
};
function createBaseAccessConfigUpdate() {
  return {
    codeId: BigInt("0"),
    instantiatePermission: void 0
  };
}
var AccessConfigUpdate = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.codeId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.codeId.toString()));
    }
    if (message.instantiatePermission !== void 0) {
      AccessConfig.encode(message.instantiatePermission, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAccessConfigUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codeId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.instantiatePermission = AccessConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codeId: isSet(object.codeId) ? BigInt(object.codeId.toString()) : BigInt("0"),
      instantiatePermission: isSet(object.instantiatePermission) ? AccessConfig.fromJSON(object.instantiatePermission) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt("0")).toString());
    message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? AccessConfig.toJSON(message.instantiatePermission) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAccessConfigUpdate();
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? BigInt(object.codeId.toString()) : BigInt("0");
    message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? AccessConfig.fromPartial(object.instantiatePermission) : void 0;
    return message;
  }
};
function createBaseUpdateInstantiateConfigProposal() {
  return {
    title: "",
    description: "",
    accessConfigUpdates: []
  };
}
var UpdateInstantiateConfigProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.accessConfigUpdates) {
      AccessConfigUpdate.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstantiateConfigProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.accessConfigUpdates.push(AccessConfigUpdate.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      accessConfigUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.accessConfigUpdates) ? object.accessConfigUpdates.map((e) => AccessConfigUpdate.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    if (message.accessConfigUpdates) {
      obj.accessConfigUpdates = message.accessConfigUpdates.map((e) => e ? AccessConfigUpdate.toJSON(e) : void 0);
    } else {
      obj.accessConfigUpdates = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$title11, _object$description11, _object$accessConfigU;
    const message = createBaseUpdateInstantiateConfigProposal();
    message.title = (_object$title11 = object.title) !== null && _object$title11 !== void 0 ? _object$title11 : "";
    message.description = (_object$description11 = object.description) !== null && _object$description11 !== void 0 ? _object$description11 : "";
    message.accessConfigUpdates = ((_object$accessConfigU = object.accessConfigUpdates) === null || _object$accessConfigU === void 0 ? void 0 : _object$accessConfigU.map((e) => AccessConfigUpdate.fromPartial(e))) || [];
    return message;
  }
};
function createBaseStoreAndInstantiateContractProposal() {
  return {
    title: "",
    description: "",
    runAs: "",
    wasmByteCode: new Uint8Array(),
    instantiatePermission: void 0,
    unpinCode: false,
    admin: "",
    label: "",
    msg: new Uint8Array(),
    funds: [],
    source: "",
    builder: "",
    codeHash: new Uint8Array()
  };
}
var StoreAndInstantiateContractProposal = {
  encode(message, writer = _m067.Writer.create()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runAs !== "") {
      writer.uint32(26).string(message.runAs);
    }
    if (message.wasmByteCode.length !== 0) {
      writer.uint32(34).bytes(message.wasmByteCode);
    }
    if (message.instantiatePermission !== void 0) {
      AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
    }
    if (message.unpinCode === true) {
      writer.uint32(48).bool(message.unpinCode);
    }
    if (message.admin !== "") {
      writer.uint32(58).string(message.admin);
    }
    if (message.label !== "") {
      writer.uint32(66).string(message.label);
    }
    if (message.msg.length !== 0) {
      writer.uint32(74).bytes(message.msg);
    }
    for (const v of message.funds) {
      Coin.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.source !== "") {
      writer.uint32(90).string(message.source);
    }
    if (message.builder !== "") {
      writer.uint32(98).string(message.builder);
    }
    if (message.codeHash.length !== 0) {
      writer.uint32(106).bytes(message.codeHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m067.Reader ? input : new _m067.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoreAndInstantiateContractProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.runAs = reader.string();
          break;
        case 4:
          message.wasmByteCode = reader.bytes();
          break;
        case 5:
          message.instantiatePermission = AccessConfig.decode(reader, reader.uint32());
          break;
        case 6:
          message.unpinCode = reader.bool();
          break;
        case 7:
          message.admin = reader.string();
          break;
        case 8:
          message.label = reader.string();
          break;
        case 9:
          message.msg = reader.bytes();
          break;
        case 10:
          message.funds.push(Coin.decode(reader, reader.uint32()));
          break;
        case 11:
          message.source = reader.string();
          break;
        case 12:
          message.builder = reader.string();
          break;
        case 13:
          message.codeHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      runAs: isSet(object.runAs) ? String(object.runAs) : "",
      wasmByteCode: isSet(object.wasmByteCode) ? bytesFromBase64(object.wasmByteCode) : new Uint8Array(),
      instantiatePermission: isSet(object.instantiatePermission) ? AccessConfig.fromJSON(object.instantiatePermission) : void 0,
      unpinCode: isSet(object.unpinCode) ? Boolean(object.unpinCode) : false,
      admin: isSet(object.admin) ? String(object.admin) : "",
      label: isSet(object.label) ? String(object.label) : "",
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
      funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => Coin.fromJSON(e)) : [],
      source: isSet(object.source) ? String(object.source) : "",
      builder: isSet(object.builder) ? String(object.builder) : "",
      codeHash: isSet(object.codeHash) ? bytesFromBase64(object.codeHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.description !== void 0 && (obj.description = message.description);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.wasmByteCode !== void 0 && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
    message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? AccessConfig.toJSON(message.instantiatePermission) : void 0);
    message.unpinCode !== void 0 && (obj.unpinCode = message.unpinCode);
    message.admin !== void 0 && (obj.admin = message.admin);
    message.label !== void 0 && (obj.label = message.label);
    message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
    if (message.funds) {
      obj.funds = message.funds.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.funds = [];
    }
    message.source !== void 0 && (obj.source = message.source);
    message.builder !== void 0 && (obj.builder = message.builder);
    message.codeHash !== void 0 && (obj.codeHash = base64FromBytes(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$title12, _object$description12, _object$runAs5, _object$wasmByteCode2, _object$unpinCode2, _object$admin3, _object$label3, _object$msg6, _object$funds4, _object$source2, _object$builder2, _object$codeHash2;
    const message = createBaseStoreAndInstantiateContractProposal();
    message.title = (_object$title12 = object.title) !== null && _object$title12 !== void 0 ? _object$title12 : "";
    message.description = (_object$description12 = object.description) !== null && _object$description12 !== void 0 ? _object$description12 : "";
    message.runAs = (_object$runAs5 = object.runAs) !== null && _object$runAs5 !== void 0 ? _object$runAs5 : "";
    message.wasmByteCode = (_object$wasmByteCode2 = object.wasmByteCode) !== null && _object$wasmByteCode2 !== void 0 ? _object$wasmByteCode2 : new Uint8Array();
    message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? AccessConfig.fromPartial(object.instantiatePermission) : void 0;
    message.unpinCode = (_object$unpinCode2 = object.unpinCode) !== null && _object$unpinCode2 !== void 0 ? _object$unpinCode2 : false;
    message.admin = (_object$admin3 = object.admin) !== null && _object$admin3 !== void 0 ? _object$admin3 : "";
    message.label = (_object$label3 = object.label) !== null && _object$label3 !== void 0 ? _object$label3 : "";
    message.msg = (_object$msg6 = object.msg) !== null && _object$msg6 !== void 0 ? _object$msg6 : new Uint8Array();
    message.funds = ((_object$funds4 = object.funds) === null || _object$funds4 === void 0 ? void 0 : _object$funds4.map((e) => Coin.fromPartial(e))) || [];
    message.source = (_object$source2 = object.source) !== null && _object$source2 !== void 0 ? _object$source2 : "";
    message.builder = (_object$builder2 = object.builder) !== null && _object$builder2 !== void 0 ? _object$builder2 : "";
    message.codeHash = (_object$codeHash2 = object.codeHash) !== null && _object$codeHash2 !== void 0 ? _object$codeHash2 : new Uint8Array();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/tx.amino.js
var tx_amino_exports18 = {};
__export(tx_amino_exports18, {
  AminoConverter: () => AminoConverter18
});
var import_encoding2 = __toESM(require_build());
var AminoConverter18 = {
  "/cosmwasm.wasm.v1.MsgStoreCode": {
    aminoType: "wasm/MsgStoreCode",
    toAmino: ({
      sender,
      wasmByteCode,
      instantiatePermission
    }) => {
      return {
        sender,
        wasm_byte_code: (0, import_encoding2.toBase64)(wasmByteCode),
        instantiate_permission: {
          permission: instantiatePermission.permission,
          address: instantiatePermission.address,
          addresses: instantiatePermission.addresses
        }
      };
    },
    fromAmino: ({
      sender,
      wasm_byte_code,
      instantiate_permission
    }) => {
      return {
        sender,
        wasmByteCode: (0, import_encoding2.fromBase64)(wasm_byte_code),
        instantiatePermission: {
          permission: accessTypeFromJSON(instantiate_permission.permission),
          address: instantiate_permission.address,
          addresses: instantiate_permission.addresses
        }
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgInstantiateContract": {
    aminoType: "wasm/MsgInstantiateContract",
    toAmino: ({
      sender,
      admin,
      codeId,
      label,
      msg,
      funds
    }) => {
      return {
        sender,
        admin,
        code_id: codeId.toString(),
        label,
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      sender,
      admin,
      code_id,
      label,
      msg,
      funds
    }) => {
      return {
        sender,
        admin,
        codeId: BigInt(code_id),
        label,
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgInstantiateContract2": {
    aminoType: "wasm/MsgInstantiateContract2",
    toAmino: ({
      sender,
      admin,
      codeId,
      label,
      msg,
      funds,
      salt,
      fixMsg
    }) => {
      return {
        sender,
        admin,
        code_id: codeId.toString(),
        label,
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        salt,
        fix_msg: fixMsg
      };
    },
    fromAmino: ({
      sender,
      admin,
      code_id,
      label,
      msg,
      funds,
      salt,
      fix_msg
    }) => {
      return {
        sender,
        admin,
        codeId: BigInt(code_id),
        label,
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        salt,
        fixMsg: fix_msg
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgExecuteContract": {
    aminoType: "wasm/MsgExecuteContract",
    toAmino: ({
      sender,
      contract,
      msg,
      funds
    }) => {
      return {
        sender,
        contract,
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    },
    fromAmino: ({
      sender,
      contract,
      msg,
      funds
    }) => {
      return {
        sender,
        contract,
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        }))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgMigrateContract": {
    aminoType: "wasm/MsgMigrateContract",
    toAmino: ({
      sender,
      contract,
      codeId,
      msg
    }) => {
      return {
        sender,
        contract,
        code_id: codeId.toString(),
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg))
      };
    },
    fromAmino: ({
      sender,
      contract,
      code_id,
      msg
    }) => {
      return {
        sender,
        contract,
        codeId: BigInt(code_id),
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
    aminoType: "wasm/MsgUpdateAdmin",
    toAmino: ({
      sender,
      newAdmin,
      contract
    }) => {
      return {
        sender,
        new_admin: newAdmin,
        contract
      };
    },
    fromAmino: ({
      sender,
      new_admin,
      contract
    }) => {
      return {
        sender,
        newAdmin: new_admin,
        contract
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgClearAdmin": {
    aminoType: "wasm/MsgClearAdmin",
    toAmino: ({
      sender,
      contract
    }) => {
      return {
        sender,
        contract
      };
    },
    fromAmino: ({
      sender,
      contract
    }) => {
      return {
        sender,
        contract
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig": {
    aminoType: "wasm/MsgUpdateInstantiateConfig",
    toAmino: ({
      sender,
      codeId,
      newInstantiatePermission
    }) => {
      return {
        sender,
        code_id: codeId.toString(),
        new_instantiate_permission: {
          permission: newInstantiatePermission.permission,
          address: newInstantiatePermission.address,
          addresses: newInstantiatePermission.addresses
        }
      };
    },
    fromAmino: ({
      sender,
      code_id,
      new_instantiate_permission
    }) => {
      return {
        sender,
        codeId: BigInt(code_id),
        newInstantiatePermission: {
          permission: accessTypeFromJSON(new_instantiate_permission.permission),
          address: new_instantiate_permission.address,
          addresses: new_instantiate_permission.addresses
        }
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgUpdateParams": {
    aminoType: "wasm/MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          code_upload_access: {
            permission: params.codeUploadAccess.permission,
            address: params.codeUploadAccess.address,
            addresses: params.codeUploadAccess.addresses
          },
          instantiate_default_permission: params.instantiateDefaultPermission
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          codeUploadAccess: {
            permission: accessTypeFromJSON(params.code_upload_access.permission),
            address: params.code_upload_access.address,
            addresses: params.code_upload_access.addresses
          },
          instantiateDefaultPermission: accessTypeFromJSON(params.instantiate_default_permission)
        }
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgSudoContract": {
    aminoType: "wasm/MsgSudoContract",
    toAmino: ({
      authority,
      contract,
      msg
    }) => {
      return {
        authority,
        contract,
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg))
      };
    },
    fromAmino: ({
      authority,
      contract,
      msg
    }) => {
      return {
        authority,
        contract,
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgPinCodes": {
    aminoType: "wasm/MsgPinCodes",
    toAmino: ({
      authority,
      codeIds
    }) => {
      return {
        authority,
        code_ids: codeIds.map((el0) => el0.toString())
      };
    },
    fromAmino: ({
      authority,
      code_ids
    }) => {
      return {
        authority,
        codeIds: code_ids.map((el0) => BigInt(el0))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgUnpinCodes": {
    aminoType: "wasm/MsgUnpinCodes",
    toAmino: ({
      authority,
      codeIds
    }) => {
      return {
        authority,
        code_ids: codeIds.map((el0) => el0.toString())
      };
    },
    fromAmino: ({
      authority,
      code_ids
    }) => {
      return {
        authority,
        codeIds: code_ids.map((el0) => BigInt(el0))
      };
    }
  },
  "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract": {
    aminoType: "wasm/MsgStoreAndInstantiateContract",
    toAmino: ({
      authority,
      wasmByteCode,
      instantiatePermission,
      unpinCode,
      admin,
      label,
      msg,
      funds,
      source,
      builder,
      codeHash
    }) => {
      return {
        authority,
        wasm_byte_code: (0, import_encoding2.toBase64)(wasmByteCode),
        instantiate_permission: {
          permission: instantiatePermission.permission,
          address: instantiatePermission.address,
          addresses: instantiatePermission.addresses
        },
        unpin_code: unpinCode,
        admin,
        label,
        msg: JSON.parse((0, import_encoding2.fromUtf8)(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        source,
        builder,
        code_hash: codeHash
      };
    },
    fromAmino: ({
      authority,
      wasm_byte_code,
      instantiate_permission,
      unpin_code,
      admin,
      label,
      msg,
      funds,
      source,
      builder,
      code_hash
    }) => {
      return {
        authority,
        wasmByteCode: (0, import_encoding2.fromBase64)(wasm_byte_code),
        instantiatePermission: {
          permission: accessTypeFromJSON(instantiate_permission.permission),
          address: instantiate_permission.address,
          addresses: instantiate_permission.addresses
        },
        unpinCode: unpin_code,
        admin,
        label,
        msg: (0, import_encoding2.toUtf8)(JSON.stringify(msg)),
        funds: funds.map((el0) => ({
          denom: el0.denom,
          amount: el0.amount
        })),
        source,
        builder,
        codeHash: code_hash
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/wasm/v1/tx.registry.js
var tx_registry_exports18 = {};
__export(tx_registry_exports18, {
  MessageComposer: () => MessageComposer18,
  load: () => load18,
  registry: () => registry18
});
var registry18 = [["/cosmwasm.wasm.v1.MsgStoreCode", MsgStoreCode], ["/cosmwasm.wasm.v1.MsgInstantiateContract", MsgInstantiateContract], ["/cosmwasm.wasm.v1.MsgInstantiateContract2", MsgInstantiateContract2], ["/cosmwasm.wasm.v1.MsgExecuteContract", MsgExecuteContract], ["/cosmwasm.wasm.v1.MsgMigrateContract", MsgMigrateContract], ["/cosmwasm.wasm.v1.MsgUpdateAdmin", MsgUpdateAdmin], ["/cosmwasm.wasm.v1.MsgClearAdmin", MsgClearAdmin], ["/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig", MsgUpdateInstantiateConfig], ["/cosmwasm.wasm.v1.MsgUpdateParams", MsgUpdateParams10], ["/cosmwasm.wasm.v1.MsgSudoContract", MsgSudoContract], ["/cosmwasm.wasm.v1.MsgPinCodes", MsgPinCodes], ["/cosmwasm.wasm.v1.MsgUnpinCodes", MsgUnpinCodes], ["/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract", MsgStoreAndInstantiateContract]];
var load18 = (protoRegistry) => {
  registry18.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer18 = {
  encoded: {
    storeCode(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
        value: MsgStoreCode.encode(value).finish()
      };
    },
    instantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
        value: MsgInstantiateContract.encode(value).finish()
      };
    },
    instantiateContract2(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
        value: MsgInstantiateContract2.encode(value).finish()
      };
    },
    executeContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
        value: MsgExecuteContract.encode(value).finish()
      };
    },
    migrateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
        value: MsgMigrateContract.encode(value).finish()
      };
    },
    updateAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
        value: MsgUpdateAdmin.encode(value).finish()
      };
    },
    clearAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
        value: MsgClearAdmin.encode(value).finish()
      };
    },
    updateInstantiateConfig(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
        value: MsgUpdateInstantiateConfig.encode(value).finish()
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
        value: MsgUpdateParams10.encode(value).finish()
      };
    },
    sudoContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
        value: MsgSudoContract.encode(value).finish()
      };
    },
    pinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
        value: MsgPinCodes.encode(value).finish()
      };
    },
    unpinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
        value: MsgUnpinCodes.encode(value).finish()
      };
    },
    storeAndInstantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
        value: MsgStoreAndInstantiateContract.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    storeCode(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
        value
      };
    },
    instantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
        value
      };
    },
    instantiateContract2(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
        value
      };
    },
    executeContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
        value
      };
    },
    migrateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
        value
      };
    },
    updateAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
        value
      };
    },
    clearAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
        value
      };
    },
    updateInstantiateConfig(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
        value
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
        value
      };
    },
    sudoContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
        value
      };
    },
    pinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
        value
      };
    },
    unpinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
        value
      };
    },
    storeAndInstantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
        value
      };
    }
  },
  toJSON: {
    storeCode(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
        value: MsgStoreCode.toJSON(value)
      };
    },
    instantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
        value: MsgInstantiateContract.toJSON(value)
      };
    },
    instantiateContract2(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
        value: MsgInstantiateContract2.toJSON(value)
      };
    },
    executeContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
        value: MsgExecuteContract.toJSON(value)
      };
    },
    migrateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
        value: MsgMigrateContract.toJSON(value)
      };
    },
    updateAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
        value: MsgUpdateAdmin.toJSON(value)
      };
    },
    clearAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
        value: MsgClearAdmin.toJSON(value)
      };
    },
    updateInstantiateConfig(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
        value: MsgUpdateInstantiateConfig.toJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
        value: MsgUpdateParams10.toJSON(value)
      };
    },
    sudoContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
        value: MsgSudoContract.toJSON(value)
      };
    },
    pinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
        value: MsgPinCodes.toJSON(value)
      };
    },
    unpinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
        value: MsgUnpinCodes.toJSON(value)
      };
    },
    storeAndInstantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
        value: MsgStoreAndInstantiateContract.toJSON(value)
      };
    }
  },
  fromJSON: {
    storeCode(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
        value: MsgStoreCode.fromJSON(value)
      };
    },
    instantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
        value: MsgInstantiateContract.fromJSON(value)
      };
    },
    instantiateContract2(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
        value: MsgInstantiateContract2.fromJSON(value)
      };
    },
    executeContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
        value: MsgExecuteContract.fromJSON(value)
      };
    },
    migrateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
        value: MsgMigrateContract.fromJSON(value)
      };
    },
    updateAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
        value: MsgUpdateAdmin.fromJSON(value)
      };
    },
    clearAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
        value: MsgClearAdmin.fromJSON(value)
      };
    },
    updateInstantiateConfig(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
        value: MsgUpdateInstantiateConfig.fromJSON(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
        value: MsgUpdateParams10.fromJSON(value)
      };
    },
    sudoContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
        value: MsgSudoContract.fromJSON(value)
      };
    },
    pinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
        value: MsgPinCodes.fromJSON(value)
      };
    },
    unpinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
        value: MsgUnpinCodes.fromJSON(value)
      };
    },
    storeAndInstantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
        value: MsgStoreAndInstantiateContract.fromJSON(value)
      };
    }
  },
  fromPartial: {
    storeCode(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
        value: MsgStoreCode.fromPartial(value)
      };
    },
    instantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
        value: MsgInstantiateContract.fromPartial(value)
      };
    },
    instantiateContract2(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
        value: MsgInstantiateContract2.fromPartial(value)
      };
    },
    executeContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
        value: MsgExecuteContract.fromPartial(value)
      };
    },
    migrateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
        value: MsgMigrateContract.fromPartial(value)
      };
    },
    updateAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
        value: MsgUpdateAdmin.fromPartial(value)
      };
    },
    clearAdmin(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
        value: MsgClearAdmin.fromPartial(value)
      };
    },
    updateInstantiateConfig(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
        value: MsgUpdateInstantiateConfig.fromPartial(value)
      };
    },
    updateParams(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
        value: MsgUpdateParams10.fromPartial(value)
      };
    },
    sudoContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
        value: MsgSudoContract.fromPartial(value)
      };
    },
    pinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
        value: MsgPinCodes.fromPartial(value)
      };
    },
    unpinCodes(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
        value: MsgUnpinCodes.fromPartial(value)
      };
    },
    storeAndInstantiateContract(value) {
      return {
        typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
        value: MsgStoreAndInstantiateContract.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/rpc.query.js
var rpc_query_exports2 = {};
__export(rpc_query_exports2, {
  createRPCQueryClient: () => createRPCQueryClient2
});
var import_tendermint_rpc2 = __toESM(require_build7());
var import_stargate3 = __toESM(require_build8());
var createRPCQueryClient2 = async ({
  rpcEndpoint
}) => {
  const tmClient = await import_tendermint_rpc2.Tendermint34Client.connect(rpcEndpoint);
  const client = new import_stargate3.QueryClient(tmClient);
  return {
    cosmos: {
      app: {
        v1alpha1: (await import("./query.rpc.Query-Z645J2C5.js")).createRpcQueryExtension(client)
      },
      auth: {
        v1beta1: (await import("./query.rpc.Query-HSLFEKVN.js")).createRpcQueryExtension(client)
      },
      authz: {
        v1beta1: (await import("./query.rpc.Query-VOBALZII.js")).createRpcQueryExtension(client)
      },
      autocli: {
        v1: (await import("./query.rpc.Query-3ECKZXP6.js")).createRpcQueryExtension(client)
      },
      bank: {
        v1beta1: (await import("./query.rpc.Query-IKLKUQBX.js")).createRpcQueryExtension(client)
      },
      base: {
        node: {
          v1beta1: (await import("./query.rpc.Service-OGSDUVYD.js")).createRpcQueryExtension(client)
        },
        tendermint: {
          v1beta1: (await import("./query.rpc.Service-UMVNZL3P.js")).createRpcQueryExtension(client)
        }
      },
      consensus: {
        v1: (await import("./query.rpc.Query-3VII2VNJ.js")).createRpcQueryExtension(client)
      },
      distribution: {
        v1beta1: (await import("./query.rpc.Query-OHEFBXHH.js")).createRpcQueryExtension(client)
      },
      evidence: {
        v1beta1: (await import("./query.rpc.Query-XMO4CSIX.js")).createRpcQueryExtension(client)
      },
      feegrant: {
        v1beta1: (await import("./query.rpc.Query-75IUKG33.js")).createRpcQueryExtension(client)
      },
      gov: {
        v1: (await import("./query.rpc.Query-4R3ETNBS.js")).createRpcQueryExtension(client),
        v1beta1: (await import("./query.rpc.Query-LMLDHT3F.js")).createRpcQueryExtension(client)
      },
      group: {
        v1: (await import("./query.rpc.Query-YAFZXBYA.js")).createRpcQueryExtension(client)
      },
      mint: {
        v1beta1: (await import("./query.rpc.Query-HMTMFHXZ.js")).createRpcQueryExtension(client)
      },
      nft: {
        v1beta1: (await import("./query.rpc.Query-FGSDCMTH.js")).createRpcQueryExtension(client)
      },
      orm: {
        query: {
          v1alpha1: (await import("./query.rpc.Query-PE7Q6FYK.js")).createRpcQueryExtension(client)
        }
      },
      params: {
        v1beta1: (await import("./query.rpc.Query-AEFB4JOF.js")).createRpcQueryExtension(client)
      },
      slashing: {
        v1beta1: (await import("./query.rpc.Query-S22SWOLR.js")).createRpcQueryExtension(client)
      },
      staking: {
        v1beta1: (await import("./query.rpc.Query-5LB62TJJ.js")).createRpcQueryExtension(client)
      },
      tx: {
        v1beta1: (await import("./service.rpc.Service-5OSPDZTY.js")).createRpcQueryExtension(client)
      },
      upgrade: {
        v1beta1: (await import("./query.rpc.Query-MKAFUIMA.js")).createRpcQueryExtension(client)
      }
    },
    cosmwasm: {
      wasm: {
        v1: (await import("./query.rpc.Query-JO37HU6A.js")).createRpcQueryExtension(client)
      }
    }
  };
};

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/rpc.tx.js
var rpc_tx_exports2 = {};
__export(rpc_tx_exports2, {
  createRPCMsgClient: () => createRPCMsgClient2
});
var createRPCMsgClient2 = async ({
  rpc
}) => ({
  cosmos: {
    auth: {
      v1beta1: new (await import("./tx.rpc.msg-BKM7GIDF.js")).MsgClientImpl(rpc)
    },
    authz: {
      v1beta1: new (await import("./tx.rpc.msg-4IOFIOJT.js")).MsgClientImpl(rpc)
    },
    bank: {
      v1beta1: new (await import("./tx.rpc.msg-GY3AG57M.js")).MsgClientImpl(rpc)
    },
    consensus: {
      v1: new (await import("./tx.rpc.msg-7IS2XNHP.js")).MsgClientImpl(rpc)
    },
    crisis: {
      v1beta1: new (await import("./tx.rpc.msg-2P7C25FF.js")).MsgClientImpl(rpc)
    },
    distribution: {
      v1beta1: new (await import("./tx.rpc.msg-5N6UVCQE.js")).MsgClientImpl(rpc)
    },
    evidence: {
      v1beta1: new (await import("./tx.rpc.msg-AIXRTESQ.js")).MsgClientImpl(rpc)
    },
    feegrant: {
      v1beta1: new (await import("./tx.rpc.msg-F3E4UQKA.js")).MsgClientImpl(rpc)
    },
    gov: {
      v1: new (await import("./tx.rpc.msg-EPAYKNRX.js")).MsgClientImpl(rpc),
      v1beta1: new (await import("./tx.rpc.msg-WTSROBNU.js")).MsgClientImpl(rpc)
    },
    group: {
      v1: new (await import("./tx.rpc.msg-3CXHGTHS.js")).MsgClientImpl(rpc)
    },
    mint: {
      v1beta1: new (await import("./tx.rpc.msg-7L6KBKRN.js")).MsgClientImpl(rpc)
    },
    nft: {
      v1beta1: new (await import("./tx.rpc.msg-PDAZEZ2U.js")).MsgClientImpl(rpc)
    },
    slashing: {
      v1beta1: new (await import("./tx.rpc.msg-GQQ4TSDM.js")).MsgClientImpl(rpc)
    },
    staking: {
      v1beta1: new (await import("./tx.rpc.msg-2OHK3UTX.js")).MsgClientImpl(rpc)
    },
    upgrade: {
      v1beta1: new (await import("./tx.rpc.msg-FXRHAFBV.js")).MsgClientImpl(rpc)
    },
    vesting: {
      v1beta1: new (await import("./tx.rpc.msg-DIHQBATM.js")).MsgClientImpl(rpc)
    }
  },
  cosmwasm: {
    wasm: {
      v1: new (await import("./tx.rpc.msg-YGHST65Y.js")).MsgClientImpl(rpc)
    }
  }
});

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/bundle.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var cosmwasm;
(function(_cosmwasm) {
  let wasm;
  (function(_wasm) {
    const v1 = _wasm.v1 = _objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5({}, authz_exports4), genesis_exports18), ibc_exports), proposal_exports), query_exports22), tx_exports19), types_exports7), tx_amino_exports18), tx_registry_exports18), query_rpc_Query_exports20), tx_rpc_msg_exports18);
  })(wasm || (wasm = _cosmwasm.wasm || (_cosmwasm.wasm = {})));
  const ClientFactory = _cosmwasm.ClientFactory = _objectSpread5(_objectSpread5({}, rpc_query_exports2), rpc_tx_exports2);
})(cosmwasm || (cosmwasm = {}));

// node_modules/@empower-plastic/empowerjs/module/codegen/cosmwasm/client.js
var import_proto_signing2 = __toESM(require_build6());
var import_stargate4 = __toESM(require_build8());
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var cosmwasmAminoConverters = _objectSpread6({}, AminoConverter18);
var cosmwasmProtoRegistry = [...registry18];
var getSigningCosmwasmClientOptions = ({
  defaultTypes = import_stargate4.defaultRegistryTypes
} = {}) => {
  const registry28 = new import_proto_signing2.Registry([...defaultTypes, ...cosmwasmProtoRegistry]);
  const aminoTypes = new import_stargate4.AminoTypes(_objectSpread6({}, cosmwasmAminoConverters));
  return {
    registry: registry28,
    aminoTypes
  };
};
var getSigningCosmwasmClient = async ({
  rpcEndpoint,
  signer,
  defaultTypes = import_stargate4.defaultRegistryTypes
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningCosmwasmClientOptions({
    defaultTypes
  });
  const client = await import_stargate4.SigningStargateClient.connectWithSigner(rpcEndpoint, signer, {
    registry: registry28,
    aminoTypes
  });
  return client;
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/certificates/events.js
var events_exports2 = {};
__export(events_exports2, {
  EventCreateCertificate: () => EventCreateCertificate
});
var _m068 = __toESM(require_minimal());
function createBaseEventCreateCertificate() {
  return {
    certificateId: BigInt("0"),
    issuer: "",
    owner: "",
    certificateType: "",
    additionalData: ""
  };
}
var EventCreateCertificate = {
  encode(message, writer = _m068.Writer.create()) {
    if (message.certificateId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.certificateId.toString()));
    }
    if (message.issuer !== "") {
      writer.uint32(18).string(message.issuer);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.certificateType !== "") {
      writer.uint32(34).string(message.certificateType);
    }
    if (message.additionalData !== "") {
      writer.uint32(42).string(message.additionalData);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m068.Reader ? input : new _m068.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.certificateId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.issuer = reader.string();
          break;
        case 3:
          message.owner = reader.string();
          break;
        case 4:
          message.certificateType = reader.string();
          break;
        case 5:
          message.additionalData = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      certificateId: isSet(object.certificateId) ? BigInt(object.certificateId.toString()) : BigInt("0"),
      issuer: isSet(object.issuer) ? String(object.issuer) : "",
      owner: isSet(object.owner) ? String(object.owner) : "",
      certificateType: isSet(object.certificateType) ? String(object.certificateType) : "",
      additionalData: isSet(object.additionalData) ? String(object.additionalData) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.certificateId !== void 0 && (obj.certificateId = (message.certificateId || BigInt("0")).toString());
    message.issuer !== void 0 && (obj.issuer = message.issuer);
    message.owner !== void 0 && (obj.owner = message.owner);
    message.certificateType !== void 0 && (obj.certificateType = message.certificateType);
    message.additionalData !== void 0 && (obj.additionalData = message.additionalData);
    return obj;
  },
  fromPartial(object) {
    var _object$issuer, _object$owner, _object$certificateTy, _object$additionalDat;
    const message = createBaseEventCreateCertificate();
    message.certificateId = object.certificateId !== void 0 && object.certificateId !== null ? BigInt(object.certificateId.toString()) : BigInt("0");
    message.issuer = (_object$issuer = object.issuer) !== null && _object$issuer !== void 0 ? _object$issuer : "";
    message.owner = (_object$owner = object.owner) !== null && _object$owner !== void 0 ? _object$owner : "";
    message.certificateType = (_object$certificateTy = object.certificateType) !== null && _object$certificateTy !== void 0 ? _object$certificateTy : "";
    message.additionalData = (_object$additionalDat = object.additionalData) !== null && _object$additionalDat !== void 0 ? _object$additionalDat : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/certificates/genesis.js
var genesis_exports19 = {};
__export(genesis_exports19, {
  GenesisState: () => GenesisState18
});
var _m069 = __toESM(require_minimal());
function createBaseGenesisState18() {
  return {
    params: void 0,
    certificates: [],
    idCounters: void 0
  };
}
var GenesisState18 = {
  encode(message, writer = _m069.Writer.create()) {
    if (message.params !== void 0) {
      Params9.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.certificates) {
      Certificate.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.idCounters !== void 0) {
      IDCounters.encode(message.idCounters, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m069.Reader ? input : new _m069.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState18();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params9.decode(reader, reader.uint32());
          break;
        case 2:
          message.certificates.push(Certificate.decode(reader, reader.uint32()));
          break;
        case 3:
          message.idCounters = IDCounters.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params9.fromJSON(object.params) : void 0,
      certificates: Array.isArray(object === null || object === void 0 ? void 0 : object.certificates) ? object.certificates.map((e) => Certificate.fromJSON(e)) : [],
      idCounters: isSet(object.idCounters) ? IDCounters.fromJSON(object.idCounters) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params9.toJSON(message.params) : void 0);
    if (message.certificates) {
      obj.certificates = message.certificates.map((e) => e ? Certificate.toJSON(e) : void 0);
    } else {
      obj.certificates = [];
    }
    message.idCounters !== void 0 && (obj.idCounters = message.idCounters ? IDCounters.toJSON(message.idCounters) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$certificates;
    const message = createBaseGenesisState18();
    message.params = object.params !== void 0 && object.params !== null ? Params9.fromPartial(object.params) : void 0;
    message.certificates = ((_object$certificates = object.certificates) === null || _object$certificates === void 0 ? void 0 : _object$certificates.map((e) => Certificate.fromPartial(e))) || [];
    message.idCounters = object.idCounters !== void 0 && object.idCounters !== null ? IDCounters.fromPartial(object.idCounters) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/plasticcredit/authz.js
var authz_exports5 = {};
__export(authz_exports5, {
  TransferAuthorization: () => TransferAuthorization
});
var _m070 = __toESM(require_minimal());
function createBaseTransferAuthorization() {
  return {
    denom: "",
    maxCredits: BigInt("0")
  };
}
var TransferAuthorization = {
  encode(message, writer = _m070.Writer.create()) {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.maxCredits !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.maxCredits.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m070.Reader ? input : new _m070.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransferAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.maxCredits = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      maxCredits: isSet(object.maxCredits) ? BigInt(object.maxCredits.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    message.maxCredits !== void 0 && (obj.maxCredits = (message.maxCredits || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$denom;
    const message = createBaseTransferAuthorization();
    message.denom = (_object$denom = object.denom) !== null && _object$denom !== void 0 ? _object$denom : "";
    message.maxCredits = object.maxCredits !== void 0 && object.maxCredits !== null ? BigInt(object.maxCredits.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/plasticcredit/events.js
var events_exports3 = {};
__export(events_exports3, {
  EventCreateApplicant: () => EventCreateApplicant,
  EventCreateCreditType: () => EventCreateCreditType,
  EventCreateIssuer: () => EventCreateIssuer,
  EventCreateProject: () => EventCreateProject,
  EventIssuedCredits: () => EventIssuedCredits,
  EventProjectApproved: () => EventProjectApproved,
  EventProjectRejected: () => EventProjectRejected,
  EventProjectSuspended: () => EventProjectSuspended,
  EventRetiredCredits: () => EventRetiredCredits,
  EventTransferCredits: () => EventTransferCredits,
  EventUpdateApplicant: () => EventUpdateApplicant,
  EventUpdateCreditType: () => EventUpdateCreditType,
  EventUpdateIssuer: () => EventUpdateIssuer,
  EventUpdateProject: () => EventUpdateProject
});
var _m071 = __toESM(require_minimal());
function createBaseEventCreateIssuer() {
  return {
    issuerId: BigInt("0"),
    creator: "",
    name: "",
    description: "",
    admin: ""
  };
}
var EventCreateIssuer = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.admin !== "") {
      writer.uint32(42).string(message.admin);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateIssuer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.creator = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.admin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      creator: isSet(object.creator) ? String(object.creator) : "",
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      admin: isSet(object.admin) ? String(object.admin) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.creator !== void 0 && (obj.creator = message.creator);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.admin !== void 0 && (obj.admin = message.admin);
    return obj;
  },
  fromPartial(object) {
    var _object$creator, _object$name, _object$description, _object$admin;
    const message = createBaseEventCreateIssuer();
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.creator = (_object$creator = object.creator) !== null && _object$creator !== void 0 ? _object$creator : "";
    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : "";
    message.description = (_object$description = object.description) !== null && _object$description !== void 0 ? _object$description : "";
    message.admin = (_object$admin = object.admin) !== null && _object$admin !== void 0 ? _object$admin : "";
    return message;
  }
};
function createBaseEventUpdateIssuer() {
  return {
    issuerId: BigInt("0"),
    creator: "",
    name: "",
    description: "",
    admin: ""
  };
}
var EventUpdateIssuer = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.admin !== "") {
      writer.uint32(42).string(message.admin);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateIssuer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.creator = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.admin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      creator: isSet(object.creator) ? String(object.creator) : "",
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      admin: isSet(object.admin) ? String(object.admin) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.creator !== void 0 && (obj.creator = message.creator);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.admin !== void 0 && (obj.admin = message.admin);
    return obj;
  },
  fromPartial(object) {
    var _object$creator2, _object$name2, _object$description2, _object$admin2;
    const message = createBaseEventUpdateIssuer();
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.creator = (_object$creator2 = object.creator) !== null && _object$creator2 !== void 0 ? _object$creator2 : "";
    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : "";
    message.description = (_object$description2 = object.description) !== null && _object$description2 !== void 0 ? _object$description2 : "";
    message.admin = (_object$admin2 = object.admin) !== null && _object$admin2 !== void 0 ? _object$admin2 : "";
    return message;
  }
};
function createBaseEventCreateProject() {
  return {
    creator: "",
    projectId: BigInt("0"),
    applicantId: BigInt("0"),
    creditTypeAbbreviation: "",
    name: ""
  };
}
var EventCreateProject = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.projectId !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.applicantId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.applicantId.toString()));
    }
    if (message.creditTypeAbbreviation !== "") {
      writer.uint32(34).string(message.creditTypeAbbreviation);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.creator = reader.string();
          break;
        case 2:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.applicantId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.creditTypeAbbreviation = reader.string();
          break;
        case 5:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      creator: isSet(object.creator) ? String(object.creator) : "",
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      applicantId: isSet(object.applicantId) ? BigInt(object.applicantId.toString()) : BigInt("0"),
      creditTypeAbbreviation: isSet(object.creditTypeAbbreviation) ? String(object.creditTypeAbbreviation) : "",
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.creator !== void 0 && (obj.creator = message.creator);
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.applicantId !== void 0 && (obj.applicantId = (message.applicantId || BigInt("0")).toString());
    message.creditTypeAbbreviation !== void 0 && (obj.creditTypeAbbreviation = message.creditTypeAbbreviation);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$creator3, _object$creditTypeAbb, _object$name3;
    const message = createBaseEventCreateProject();
    message.creator = (_object$creator3 = object.creator) !== null && _object$creator3 !== void 0 ? _object$creator3 : "";
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.applicantId = object.applicantId !== void 0 && object.applicantId !== null ? BigInt(object.applicantId.toString()) : BigInt("0");
    message.creditTypeAbbreviation = (_object$creditTypeAbb = object.creditTypeAbbreviation) !== null && _object$creditTypeAbb !== void 0 ? _object$creditTypeAbb : "";
    message.name = (_object$name3 = object.name) !== null && _object$name3 !== void 0 ? _object$name3 : "";
    return message;
  }
};
function createBaseEventUpdateProject() {
  return {
    updater: "",
    projectId: BigInt("0"),
    name: ""
  };
}
var EventUpdateProject = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.updater !== "") {
      writer.uint32(10).string(message.updater);
    }
    if (message.projectId !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.updater = reader.string();
          break;
        case 2:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      updater: isSet(object.updater) ? String(object.updater) : "",
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.updater !== void 0 && (obj.updater = message.updater);
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$updater, _object$name4;
    const message = createBaseEventUpdateProject();
    message.updater = (_object$updater = object.updater) !== null && _object$updater !== void 0 ? _object$updater : "";
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.name = (_object$name4 = object.name) !== null && _object$name4 !== void 0 ? _object$name4 : "";
    return message;
  }
};
function createBaseEventProjectApproved() {
  return {
    projectId: BigInt("0"),
    approvedForCreditTypeAbbreviation: "",
    approvingIssuerId: BigInt("0"),
    approvedBy: ""
  };
}
var EventProjectApproved = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.projectId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.approvedForCreditTypeAbbreviation !== "") {
      writer.uint32(18).string(message.approvedForCreditTypeAbbreviation);
    }
    if (message.approvingIssuerId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.approvingIssuerId.toString()));
    }
    if (message.approvedBy !== "") {
      writer.uint32(34).string(message.approvedBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventProjectApproved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.approvedForCreditTypeAbbreviation = reader.string();
          break;
        case 3:
          message.approvingIssuerId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.approvedBy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      approvedForCreditTypeAbbreviation: isSet(object.approvedForCreditTypeAbbreviation) ? String(object.approvedForCreditTypeAbbreviation) : "",
      approvingIssuerId: isSet(object.approvingIssuerId) ? BigInt(object.approvingIssuerId.toString()) : BigInt("0"),
      approvedBy: isSet(object.approvedBy) ? String(object.approvedBy) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.approvedForCreditTypeAbbreviation !== void 0 && (obj.approvedForCreditTypeAbbreviation = message.approvedForCreditTypeAbbreviation);
    message.approvingIssuerId !== void 0 && (obj.approvingIssuerId = (message.approvingIssuerId || BigInt("0")).toString());
    message.approvedBy !== void 0 && (obj.approvedBy = message.approvedBy);
    return obj;
  },
  fromPartial(object) {
    var _object$approvedForCr, _object$approvedBy;
    const message = createBaseEventProjectApproved();
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.approvedForCreditTypeAbbreviation = (_object$approvedForCr = object.approvedForCreditTypeAbbreviation) !== null && _object$approvedForCr !== void 0 ? _object$approvedForCr : "";
    message.approvingIssuerId = object.approvingIssuerId !== void 0 && object.approvingIssuerId !== null ? BigInt(object.approvingIssuerId.toString()) : BigInt("0");
    message.approvedBy = (_object$approvedBy = object.approvedBy) !== null && _object$approvedBy !== void 0 ? _object$approvedBy : "";
    return message;
  }
};
function createBaseEventProjectRejected() {
  return {
    projectId: BigInt("0"),
    rejectedForCreditTypeAbbreviation: "",
    rejectingIssuerId: BigInt("0"),
    rejectedBy: ""
  };
}
var EventProjectRejected = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.projectId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.rejectedForCreditTypeAbbreviation !== "") {
      writer.uint32(18).string(message.rejectedForCreditTypeAbbreviation);
    }
    if (message.rejectingIssuerId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.rejectingIssuerId.toString()));
    }
    if (message.rejectedBy !== "") {
      writer.uint32(34).string(message.rejectedBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventProjectRejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.rejectedForCreditTypeAbbreviation = reader.string();
          break;
        case 3:
          message.rejectingIssuerId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.rejectedBy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      rejectedForCreditTypeAbbreviation: isSet(object.rejectedForCreditTypeAbbreviation) ? String(object.rejectedForCreditTypeAbbreviation) : "",
      rejectingIssuerId: isSet(object.rejectingIssuerId) ? BigInt(object.rejectingIssuerId.toString()) : BigInt("0"),
      rejectedBy: isSet(object.rejectedBy) ? String(object.rejectedBy) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.rejectedForCreditTypeAbbreviation !== void 0 && (obj.rejectedForCreditTypeAbbreviation = message.rejectedForCreditTypeAbbreviation);
    message.rejectingIssuerId !== void 0 && (obj.rejectingIssuerId = (message.rejectingIssuerId || BigInt("0")).toString());
    message.rejectedBy !== void 0 && (obj.rejectedBy = message.rejectedBy);
    return obj;
  },
  fromPartial(object) {
    var _object$rejectedForCr, _object$rejectedBy;
    const message = createBaseEventProjectRejected();
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.rejectedForCreditTypeAbbreviation = (_object$rejectedForCr = object.rejectedForCreditTypeAbbreviation) !== null && _object$rejectedForCr !== void 0 ? _object$rejectedForCr : "";
    message.rejectingIssuerId = object.rejectingIssuerId !== void 0 && object.rejectingIssuerId !== null ? BigInt(object.rejectingIssuerId.toString()) : BigInt("0");
    message.rejectedBy = (_object$rejectedBy = object.rejectedBy) !== null && _object$rejectedBy !== void 0 ? _object$rejectedBy : "";
    return message;
  }
};
function createBaseEventProjectSuspended() {
  return {
    projectId: BigInt("0"),
    suspendedForCreditTypeAbbreviation: "",
    suspendingIssuerId: BigInt("0"),
    suspendedBy: ""
  };
}
var EventProjectSuspended = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.projectId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.suspendedForCreditTypeAbbreviation !== "") {
      writer.uint32(18).string(message.suspendedForCreditTypeAbbreviation);
    }
    if (message.suspendingIssuerId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.suspendingIssuerId.toString()));
    }
    if (message.suspendedBy !== "") {
      writer.uint32(34).string(message.suspendedBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventProjectSuspended();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.suspendedForCreditTypeAbbreviation = reader.string();
          break;
        case 3:
          message.suspendingIssuerId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.suspendedBy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      suspendedForCreditTypeAbbreviation: isSet(object.suspendedForCreditTypeAbbreviation) ? String(object.suspendedForCreditTypeAbbreviation) : "",
      suspendingIssuerId: isSet(object.suspendingIssuerId) ? BigInt(object.suspendingIssuerId.toString()) : BigInt("0"),
      suspendedBy: isSet(object.suspendedBy) ? String(object.suspendedBy) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.suspendedForCreditTypeAbbreviation !== void 0 && (obj.suspendedForCreditTypeAbbreviation = message.suspendedForCreditTypeAbbreviation);
    message.suspendingIssuerId !== void 0 && (obj.suspendingIssuerId = (message.suspendingIssuerId || BigInt("0")).toString());
    message.suspendedBy !== void 0 && (obj.suspendedBy = message.suspendedBy);
    return obj;
  },
  fromPartial(object) {
    var _object$suspendedForC, _object$suspendedBy;
    const message = createBaseEventProjectSuspended();
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.suspendedForCreditTypeAbbreviation = (_object$suspendedForC = object.suspendedForCreditTypeAbbreviation) !== null && _object$suspendedForC !== void 0 ? _object$suspendedForC : "";
    message.suspendingIssuerId = object.suspendingIssuerId !== void 0 && object.suspendingIssuerId !== null ? BigInt(object.suspendingIssuerId.toString()) : BigInt("0");
    message.suspendedBy = (_object$suspendedBy = object.suspendedBy) !== null && _object$suspendedBy !== void 0 ? _object$suspendedBy : "";
    return message;
  }
};
function createBaseEventIssuedCredits() {
  return {
    issuerId: BigInt("0"),
    projectId: BigInt("0"),
    applicantId: BigInt("0"),
    recipient: "",
    creditTypeAbbreviation: "",
    denom: "",
    amount: BigInt("0"),
    issuerAddress: "",
    metadataUris: []
  };
}
var EventIssuedCredits = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.projectId !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.projectId.toString()));
    }
    if (message.applicantId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.applicantId.toString()));
    }
    if (message.recipient !== "") {
      writer.uint32(34).string(message.recipient);
    }
    if (message.creditTypeAbbreviation !== "") {
      writer.uint32(42).string(message.creditTypeAbbreviation);
    }
    if (message.denom !== "") {
      writer.uint32(50).string(message.denom);
    }
    if (message.amount !== BigInt(0)) {
      writer.uint32(56).uint64(import_long.default.fromString(message.amount.toString()));
    }
    if (message.issuerAddress !== "") {
      writer.uint32(66).string(message.issuerAddress);
    }
    for (const v of message.metadataUris) {
      writer.uint32(74).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventIssuedCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.projectId = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.applicantId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.recipient = reader.string();
          break;
        case 5:
          message.creditTypeAbbreviation = reader.string();
          break;
        case 6:
          message.denom = reader.string();
          break;
        case 7:
          message.amount = BigInt(reader.uint64().toString());
          break;
        case 8:
          message.issuerAddress = reader.string();
          break;
        case 9:
          message.metadataUris.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      projectId: isSet(object.projectId) ? BigInt(object.projectId.toString()) : BigInt("0"),
      applicantId: isSet(object.applicantId) ? BigInt(object.applicantId.toString()) : BigInt("0"),
      recipient: isSet(object.recipient) ? String(object.recipient) : "",
      creditTypeAbbreviation: isSet(object.creditTypeAbbreviation) ? String(object.creditTypeAbbreviation) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? BigInt(object.amount.toString()) : BigInt("0"),
      issuerAddress: isSet(object.issuerAddress) ? String(object.issuerAddress) : "",
      metadataUris: Array.isArray(object === null || object === void 0 ? void 0 : object.metadataUris) ? object.metadataUris.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.projectId !== void 0 && (obj.projectId = (message.projectId || BigInt("0")).toString());
    message.applicantId !== void 0 && (obj.applicantId = (message.applicantId || BigInt("0")).toString());
    message.recipient !== void 0 && (obj.recipient = message.recipient);
    message.creditTypeAbbreviation !== void 0 && (obj.creditTypeAbbreviation = message.creditTypeAbbreviation);
    message.denom !== void 0 && (obj.denom = message.denom);
    message.amount !== void 0 && (obj.amount = (message.amount || BigInt("0")).toString());
    message.issuerAddress !== void 0 && (obj.issuerAddress = message.issuerAddress);
    if (message.metadataUris) {
      obj.metadataUris = message.metadataUris.map((e) => e);
    } else {
      obj.metadataUris = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$recipient, _object$creditTypeAbb2, _object$denom, _object$issuerAddress, _object$metadataUris;
    const message = createBaseEventIssuedCredits();
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.projectId = object.projectId !== void 0 && object.projectId !== null ? BigInt(object.projectId.toString()) : BigInt("0");
    message.applicantId = object.applicantId !== void 0 && object.applicantId !== null ? BigInt(object.applicantId.toString()) : BigInt("0");
    message.recipient = (_object$recipient = object.recipient) !== null && _object$recipient !== void 0 ? _object$recipient : "";
    message.creditTypeAbbreviation = (_object$creditTypeAbb2 = object.creditTypeAbbreviation) !== null && _object$creditTypeAbb2 !== void 0 ? _object$creditTypeAbb2 : "";
    message.denom = (_object$denom = object.denom) !== null && _object$denom !== void 0 ? _object$denom : "";
    message.amount = object.amount !== void 0 && object.amount !== null ? BigInt(object.amount.toString()) : BigInt("0");
    message.issuerAddress = (_object$issuerAddress = object.issuerAddress) !== null && _object$issuerAddress !== void 0 ? _object$issuerAddress : "";
    message.metadataUris = ((_object$metadataUris = object.metadataUris) === null || _object$metadataUris === void 0 ? void 0 : _object$metadataUris.map((e) => e)) || [];
    return message;
  }
};
function createBaseEventTransferCredits() {
  return {
    sender: "",
    recipient: "",
    denom: "",
    amount: BigInt("0"),
    issuerId: BigInt("0"),
    creditTypeAbbreviation: ""
  };
}
var EventTransferCredits = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.recipient !== "") {
      writer.uint32(18).string(message.recipient);
    }
    if (message.denom !== "") {
      writer.uint32(26).string(message.denom);
    }
    if (message.amount !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.amount.toString()));
    }
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(40).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.creditTypeAbbreviation !== "") {
      writer.uint32(50).string(message.creditTypeAbbreviation);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventTransferCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.recipient = reader.string();
          break;
        case 3:
          message.denom = reader.string();
          break;
        case 4:
          message.amount = BigInt(reader.uint64().toString());
          break;
        case 5:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 6:
          message.creditTypeAbbreviation = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      recipient: isSet(object.recipient) ? String(object.recipient) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? BigInt(object.amount.toString()) : BigInt("0"),
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      creditTypeAbbreviation: isSet(object.creditTypeAbbreviation) ? String(object.creditTypeAbbreviation) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.sender !== void 0 && (obj.sender = message.sender);
    message.recipient !== void 0 && (obj.recipient = message.recipient);
    message.denom !== void 0 && (obj.denom = message.denom);
    message.amount !== void 0 && (obj.amount = (message.amount || BigInt("0")).toString());
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.creditTypeAbbreviation !== void 0 && (obj.creditTypeAbbreviation = message.creditTypeAbbreviation);
    return obj;
  },
  fromPartial(object) {
    var _object$sender, _object$recipient2, _object$denom2, _object$creditTypeAbb3;
    const message = createBaseEventTransferCredits();
    message.sender = (_object$sender = object.sender) !== null && _object$sender !== void 0 ? _object$sender : "";
    message.recipient = (_object$recipient2 = object.recipient) !== null && _object$recipient2 !== void 0 ? _object$recipient2 : "";
    message.denom = (_object$denom2 = object.denom) !== null && _object$denom2 !== void 0 ? _object$denom2 : "";
    message.amount = object.amount !== void 0 && object.amount !== null ? BigInt(object.amount.toString()) : BigInt("0");
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.creditTypeAbbreviation = (_object$creditTypeAbb3 = object.creditTypeAbbreviation) !== null && _object$creditTypeAbb3 !== void 0 ? _object$creditTypeAbb3 : "";
    return message;
  }
};
function createBaseEventRetiredCredits() {
  return {
    owner: "",
    denom: "",
    amount: BigInt("0"),
    issuerId: BigInt("0"),
    creditTypeAbbreviation: ""
  };
}
var EventRetiredCredits = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.amount !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.amount.toString()));
    }
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.creditTypeAbbreviation !== "") {
      writer.uint32(42).string(message.creditTypeAbbreviation);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventRetiredCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.owner = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.amount = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 5:
          message.creditTypeAbbreviation = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      owner: isSet(object.owner) ? String(object.owner) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? BigInt(object.amount.toString()) : BigInt("0"),
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      creditTypeAbbreviation: isSet(object.creditTypeAbbreviation) ? String(object.creditTypeAbbreviation) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.owner !== void 0 && (obj.owner = message.owner);
    message.denom !== void 0 && (obj.denom = message.denom);
    message.amount !== void 0 && (obj.amount = (message.amount || BigInt("0")).toString());
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.creditTypeAbbreviation !== void 0 && (obj.creditTypeAbbreviation = message.creditTypeAbbreviation);
    return obj;
  },
  fromPartial(object) {
    var _object$owner, _object$denom3, _object$creditTypeAbb4;
    const message = createBaseEventRetiredCredits();
    message.owner = (_object$owner = object.owner) !== null && _object$owner !== void 0 ? _object$owner : "";
    message.denom = (_object$denom3 = object.denom) !== null && _object$denom3 !== void 0 ? _object$denom3 : "";
    message.amount = object.amount !== void 0 && object.amount !== null ? BigInt(object.amount.toString()) : BigInt("0");
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.creditTypeAbbreviation = (_object$creditTypeAbb4 = object.creditTypeAbbreviation) !== null && _object$creditTypeAbb4 !== void 0 ? _object$creditTypeAbb4 : "";
    return message;
  }
};
function createBaseEventCreateApplicant() {
  return {
    applicantId: BigInt("0"),
    name: "",
    description: "",
    admin: ""
  };
}
var EventCreateApplicant = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.applicantId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.applicantId.toString()));
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateApplicant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.applicantId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.admin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      applicantId: isSet(object.applicantId) ? BigInt(object.applicantId.toString()) : BigInt("0"),
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      admin: isSet(object.admin) ? String(object.admin) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.applicantId !== void 0 && (obj.applicantId = (message.applicantId || BigInt("0")).toString());
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.admin !== void 0 && (obj.admin = message.admin);
    return obj;
  },
  fromPartial(object) {
    var _object$name5, _object$description3, _object$admin3;
    const message = createBaseEventCreateApplicant();
    message.applicantId = object.applicantId !== void 0 && object.applicantId !== null ? BigInt(object.applicantId.toString()) : BigInt("0");
    message.name = (_object$name5 = object.name) !== null && _object$name5 !== void 0 ? _object$name5 : "";
    message.description = (_object$description3 = object.description) !== null && _object$description3 !== void 0 ? _object$description3 : "";
    message.admin = (_object$admin3 = object.admin) !== null && _object$admin3 !== void 0 ? _object$admin3 : "";
    return message;
  }
};
function createBaseEventUpdateApplicant() {
  return {
    applicantId: BigInt("0"),
    name: "",
    description: "",
    admin: "",
    updater: ""
  };
}
var EventUpdateApplicant = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.applicantId !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.applicantId.toString()));
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    if (message.updater !== "") {
      writer.uint32(42).string(message.updater);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateApplicant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.applicantId = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.admin = reader.string();
          break;
        case 5:
          message.updater = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      applicantId: isSet(object.applicantId) ? BigInt(object.applicantId.toString()) : BigInt("0"),
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      admin: isSet(object.admin) ? String(object.admin) : "",
      updater: isSet(object.updater) ? String(object.updater) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.applicantId !== void 0 && (obj.applicantId = (message.applicantId || BigInt("0")).toString());
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.admin !== void 0 && (obj.admin = message.admin);
    message.updater !== void 0 && (obj.updater = message.updater);
    return obj;
  },
  fromPartial(object) {
    var _object$name6, _object$description4, _object$admin4, _object$updater2;
    const message = createBaseEventUpdateApplicant();
    message.applicantId = object.applicantId !== void 0 && object.applicantId !== null ? BigInt(object.applicantId.toString()) : BigInt("0");
    message.name = (_object$name6 = object.name) !== null && _object$name6 !== void 0 ? _object$name6 : "";
    message.description = (_object$description4 = object.description) !== null && _object$description4 !== void 0 ? _object$description4 : "";
    message.admin = (_object$admin4 = object.admin) !== null && _object$admin4 !== void 0 ? _object$admin4 : "";
    message.updater = (_object$updater2 = object.updater) !== null && _object$updater2 !== void 0 ? _object$updater2 : "";
    return message;
  }
};
function createBaseEventCreateCreditType() {
  return {
    creator: "",
    abbreviation: "",
    issuerId: BigInt("0"),
    name: ""
  };
}
var EventCreateCreditType = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.abbreviation !== "") {
      writer.uint32(18).string(message.abbreviation);
    }
    if (message.issuerId !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.issuerId.toString()));
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateCreditType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.creator = reader.string();
          break;
        case 2:
          message.abbreviation = reader.string();
          break;
        case 3:
          message.issuerId = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      creator: isSet(object.creator) ? String(object.creator) : "",
      abbreviation: isSet(object.abbreviation) ? String(object.abbreviation) : "",
      issuerId: isSet(object.issuerId) ? BigInt(object.issuerId.toString()) : BigInt("0"),
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.creator !== void 0 && (obj.creator = message.creator);
    message.abbreviation !== void 0 && (obj.abbreviation = message.abbreviation);
    message.issuerId !== void 0 && (obj.issuerId = (message.issuerId || BigInt("0")).toString());
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$creator4, _object$abbreviation, _object$name7;
    const message = createBaseEventCreateCreditType();
    message.creator = (_object$creator4 = object.creator) !== null && _object$creator4 !== void 0 ? _object$creator4 : "";
    message.abbreviation = (_object$abbreviation = object.abbreviation) !== null && _object$abbreviation !== void 0 ? _object$abbreviation : "";
    message.issuerId = object.issuerId !== void 0 && object.issuerId !== null ? BigInt(object.issuerId.toString()) : BigInt("0");
    message.name = (_object$name7 = object.name) !== null && _object$name7 !== void 0 ? _object$name7 : "";
    return message;
  }
};
function createBaseEventUpdateCreditType() {
  return {
    updater: "",
    abbreviation: "",
    name: ""
  };
}
var EventUpdateCreditType = {
  encode(message, writer = _m071.Writer.create()) {
    if (message.updater !== "") {
      writer.uint32(10).string(message.updater);
    }
    if (message.abbreviation !== "") {
      writer.uint32(18).string(message.abbreviation);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m071.Reader ? input : new _m071.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateCreditType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.updater = reader.string();
          break;
        case 2:
          message.abbreviation = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      updater: isSet(object.updater) ? String(object.updater) : "",
      abbreviation: isSet(object.abbreviation) ? String(object.abbreviation) : "",
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.updater !== void 0 && (obj.updater = message.updater);
    message.abbreviation !== void 0 && (obj.abbreviation = message.abbreviation);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    var _object$updater3, _object$abbreviation2, _object$name8;
    const message = createBaseEventUpdateCreditType();
    message.updater = (_object$updater3 = object.updater) !== null && _object$updater3 !== void 0 ? _object$updater3 : "";
    message.abbreviation = (_object$abbreviation2 = object.abbreviation) !== null && _object$abbreviation2 !== void 0 ? _object$abbreviation2 : "";
    message.name = (_object$name8 = object.name) !== null && _object$name8 !== void 0 ? _object$name8 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/plasticcredit/genesis.js
var genesis_exports20 = {};
__export(genesis_exports20, {
  GenesisState: () => GenesisState19
});
var _m072 = __toESM(require_minimal());
function createBaseGenesisState19() {
  return {
    params: void 0,
    idCounters: void 0,
    issuers: [],
    applicants: [],
    creditTypes: [],
    projects: [],
    creditCollections: [],
    creditBalances: []
  };
}
var GenesisState19 = {
  encode(message, writer = _m072.Writer.create()) {
    if (message.params !== void 0) {
      Params10.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    if (message.idCounters !== void 0) {
      IDCounters2.encode(message.idCounters, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.issuers) {
      Issuer.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.applicants) {
      Applicant.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.creditTypes) {
      CreditType.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.projects) {
      Project.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.creditCollections) {
      CreditCollection.encode(v, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.creditBalances) {
      CreditBalance.encode(v, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m072.Reader ? input : new _m072.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState19();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params10.decode(reader, reader.uint32());
          break;
        case 2:
          message.idCounters = IDCounters2.decode(reader, reader.uint32());
          break;
        case 3:
          message.issuers.push(Issuer.decode(reader, reader.uint32()));
          break;
        case 4:
          message.applicants.push(Applicant.decode(reader, reader.uint32()));
          break;
        case 5:
          message.creditTypes.push(CreditType.decode(reader, reader.uint32()));
          break;
        case 6:
          message.projects.push(Project.decode(reader, reader.uint32()));
          break;
        case 7:
          message.creditCollections.push(CreditCollection.decode(reader, reader.uint32()));
          break;
        case 8:
          message.creditBalances.push(CreditBalance.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet(object.params) ? Params10.fromJSON(object.params) : void 0,
      idCounters: isSet(object.idCounters) ? IDCounters2.fromJSON(object.idCounters) : void 0,
      issuers: Array.isArray(object === null || object === void 0 ? void 0 : object.issuers) ? object.issuers.map((e) => Issuer.fromJSON(e)) : [],
      applicants: Array.isArray(object === null || object === void 0 ? void 0 : object.applicants) ? object.applicants.map((e) => Applicant.fromJSON(e)) : [],
      creditTypes: Array.isArray(object === null || object === void 0 ? void 0 : object.creditTypes) ? object.creditTypes.map((e) => CreditType.fromJSON(e)) : [],
      projects: Array.isArray(object === null || object === void 0 ? void 0 : object.projects) ? object.projects.map((e) => Project.fromJSON(e)) : [],
      creditCollections: Array.isArray(object === null || object === void 0 ? void 0 : object.creditCollections) ? object.creditCollections.map((e) => CreditCollection.fromJSON(e)) : [],
      creditBalances: Array.isArray(object === null || object === void 0 ? void 0 : object.creditBalances) ? object.creditBalances.map((e) => CreditBalance.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params10.toJSON(message.params) : void 0);
    message.idCounters !== void 0 && (obj.idCounters = message.idCounters ? IDCounters2.toJSON(message.idCounters) : void 0);
    if (message.issuers) {
      obj.issuers = message.issuers.map((e) => e ? Issuer.toJSON(e) : void 0);
    } else {
      obj.issuers = [];
    }
    if (message.applicants) {
      obj.applicants = message.applicants.map((e) => e ? Applicant.toJSON(e) : void 0);
    } else {
      obj.applicants = [];
    }
    if (message.creditTypes) {
      obj.creditTypes = message.creditTypes.map((e) => e ? CreditType.toJSON(e) : void 0);
    } else {
      obj.creditTypes = [];
    }
    if (message.projects) {
      obj.projects = message.projects.map((e) => e ? Project.toJSON(e) : void 0);
    } else {
      obj.projects = [];
    }
    if (message.creditCollections) {
      obj.creditCollections = message.creditCollections.map((e) => e ? CreditCollection.toJSON(e) : void 0);
    } else {
      obj.creditCollections = [];
    }
    if (message.creditBalances) {
      obj.creditBalances = message.creditBalances.map((e) => e ? CreditBalance.toJSON(e) : void 0);
    } else {
      obj.creditBalances = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$issuers, _object$applicants, _object$creditTypes, _object$projects, _object$creditCollect, _object$creditBalance;
    const message = createBaseGenesisState19();
    message.params = object.params !== void 0 && object.params !== null ? Params10.fromPartial(object.params) : void 0;
    message.idCounters = object.idCounters !== void 0 && object.idCounters !== null ? IDCounters2.fromPartial(object.idCounters) : void 0;
    message.issuers = ((_object$issuers = object.issuers) === null || _object$issuers === void 0 ? void 0 : _object$issuers.map((e) => Issuer.fromPartial(e))) || [];
    message.applicants = ((_object$applicants = object.applicants) === null || _object$applicants === void 0 ? void 0 : _object$applicants.map((e) => Applicant.fromPartial(e))) || [];
    message.creditTypes = ((_object$creditTypes = object.creditTypes) === null || _object$creditTypes === void 0 ? void 0 : _object$creditTypes.map((e) => CreditType.fromPartial(e))) || [];
    message.projects = ((_object$projects = object.projects) === null || _object$projects === void 0 ? void 0 : _object$projects.map((e) => Project.fromPartial(e))) || [];
    message.creditCollections = ((_object$creditCollect = object.creditCollections) === null || _object$creditCollect === void 0 ? void 0 : _object$creditCollect.map((e) => CreditCollection.fromPartial(e))) || [];
    message.creditBalances = ((_object$creditBalance = object.creditBalances) === null || _object$creditBalance === void 0 ? void 0 : _object$creditBalance.map((e) => CreditBalance.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/proofofexistence/events.js
var events_exports4 = {};
__export(events_exports4, {
  EventCreateProof: () => EventCreateProof
});
var _m073 = __toESM(require_minimal());
function createBaseEventCreateProof() {
  return {
    hash: "",
    creator: ""
  };
}
var EventCreateProof = {
  encode(message, writer = _m073.Writer.create()) {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m073.Reader ? input : new _m073.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventCreateProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.string();
          break;
        case 2:
          message.creator = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet(object.hash) ? String(object.hash) : "",
      creator: isSet(object.creator) ? String(object.creator) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = message.hash);
    message.creator !== void 0 && (obj.creator = message.creator);
    return obj;
  },
  fromPartial(object) {
    var _object$hash, _object$creator;
    const message = createBaseEventCreateProof();
    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : "";
    message.creator = (_object$creator = object.creator) !== null && _object$creator !== void 0 ? _object$creator : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/proofofexistence/genesis.js
var genesis_exports21 = {};
__export(genesis_exports21, {
  GenesisState: () => GenesisState20,
  Proof: () => Proof
});
var _m074 = __toESM(require_minimal());
function createBaseGenesisState20() {
  return {
    proofList: []
  };
}
var GenesisState20 = {
  encode(message, writer = _m074.Writer.create()) {
    for (const v of message.proofList) {
      Proof.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m074.Reader ? input : new _m074.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState20();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proofList.push(Proof.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      proofList: Array.isArray(object === null || object === void 0 ? void 0 : object.proofList) ? object.proofList.map((e) => Proof.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.proofList) {
      obj.proofList = message.proofList.map((e) => e ? Proof.toJSON(e) : void 0);
    } else {
      obj.proofList = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$proofList;
    const message = createBaseGenesisState20();
    message.proofList = ((_object$proofList = object.proofList) === null || _object$proofList === void 0 ? void 0 : _object$proofList.map((e) => Proof.fromPartial(e))) || [];
    return message;
  }
};
function createBaseProof() {
  return {
    hash: "",
    metadata: void 0
  };
}
var Proof = {
  encode(message, writer = _m074.Writer.create()) {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.metadata !== void 0) {
      ProofMetadata.encode(message.metadata, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m074.Reader ? input : new _m074.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.string();
          break;
        case 2:
          message.metadata = ProofMetadata.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet(object.hash) ? String(object.hash) : "",
      metadata: isSet(object.metadata) ? ProofMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = message.hash);
    message.metadata !== void 0 && (obj.metadata = message.metadata ? ProofMetadata.toJSON(message.metadata) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$hash;
    const message = createBaseProof();
    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? ProofMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/certificates/tx.amino.js
var tx_amino_exports19 = {};
__export(tx_amino_exports19, {
  AminoConverter: () => AminoConverter19
});
var AminoConverter19 = {
  "/empowerchain.certificates.MsgUpdateParams": {
    aminoType: "/empowerchain.certificates.MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          allowed_issuers: params.allowedIssuers
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          allowedIssuers: params.allowed_issuers
        }
      };
    }
  },
  "/empowerchain.certificates.MsgCreateCertificate": {
    aminoType: "/empowerchain.certificates.MsgCreateCertificate",
    toAmino: ({
      issuer,
      type,
      owner,
      additionalData
    }) => {
      return {
        issuer,
        type,
        owner,
        additional_data: additionalData.map((el0) => ({
          key: el0.key,
          value: el0.value
        }))
      };
    },
    fromAmino: ({
      issuer,
      type,
      owner,
      additional_data
    }) => {
      return {
        issuer,
        type: certificateTypeFromJSON(type),
        owner,
        additionalData: additional_data.map((el0) => ({
          key: el0.key,
          value: el0.value
        }))
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/plasticcredit/tx.amino.js
var tx_amino_exports20 = {};
__export(tx_amino_exports20, {
  AminoConverter: () => AminoConverter20
});
var AminoConverter20 = {
  "/empowerchain.plasticcredit.MsgUpdateParams": {
    aminoType: "/empowerchain.plasticcredit.MsgUpdateParams",
    toAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          issuer_creator: params.issuerCreator,
          credit_type_creation_fee: {
            denom: params.creditTypeCreationFee.denom,
            amount: params.creditTypeCreationFee.amount
          }
        }
      };
    },
    fromAmino: ({
      authority,
      params
    }) => {
      return {
        authority,
        params: {
          issuerCreator: params.issuer_creator,
          creditTypeCreationFee: {
            denom: params.credit_type_creation_fee.denom,
            amount: params.credit_type_creation_fee.amount
          }
        }
      };
    }
  },
  "/empowerchain.plasticcredit.MsgCreateIssuer": {
    aminoType: "/empowerchain.plasticcredit.MsgCreateIssuer",
    toAmino: ({
      creator,
      name,
      description,
      admin
    }) => {
      return {
        creator,
        name,
        description,
        admin
      };
    },
    fromAmino: ({
      creator,
      name,
      description,
      admin
    }) => {
      return {
        creator,
        name,
        description,
        admin
      };
    }
  },
  "/empowerchain.plasticcredit.MsgUpdateIssuer": {
    aminoType: "/empowerchain.plasticcredit.MsgUpdateIssuer",
    toAmino: ({
      updater,
      issuerId,
      name,
      description,
      admin
    }) => {
      return {
        updater,
        issuer_id: issuerId.toString(),
        name,
        description,
        admin
      };
    },
    fromAmino: ({
      updater,
      issuer_id,
      name,
      description,
      admin
    }) => {
      return {
        updater,
        issuerId: BigInt(issuer_id),
        name,
        description,
        admin
      };
    }
  },
  "/empowerchain.plasticcredit.MsgCreateApplicant": {
    aminoType: "/empowerchain.plasticcredit.MsgCreateApplicant",
    toAmino: ({
      name,
      description,
      admin
    }) => {
      return {
        name,
        description,
        admin
      };
    },
    fromAmino: ({
      name,
      description,
      admin
    }) => {
      return {
        name,
        description,
        admin
      };
    }
  },
  "/empowerchain.plasticcredit.MsgUpdateApplicant": {
    aminoType: "/empowerchain.plasticcredit.MsgUpdateApplicant",
    toAmino: ({
      updater,
      applicantId,
      name,
      description,
      admin
    }) => {
      return {
        updater,
        applicant_id: applicantId.toString(),
        name,
        description,
        admin
      };
    },
    fromAmino: ({
      updater,
      applicant_id,
      name,
      description,
      admin
    }) => {
      return {
        updater,
        applicantId: BigInt(applicant_id),
        name,
        description,
        admin
      };
    }
  },
  "/empowerchain.plasticcredit.MsgCreateCreditType": {
    aminoType: "/empowerchain.plasticcredit.MsgCreateCreditType",
    toAmino: ({
      creator,
      abbreviation,
      issuerId,
      name
    }) => {
      return {
        creator,
        abbreviation,
        issuer_id: issuerId.toString(),
        name
      };
    },
    fromAmino: ({
      creator,
      abbreviation,
      issuer_id,
      name
    }) => {
      return {
        creator,
        abbreviation,
        issuerId: BigInt(issuer_id),
        name
      };
    }
  },
  "/empowerchain.plasticcredit.MsgUpdateCreditType": {
    aminoType: "/empowerchain.plasticcredit.MsgUpdateCreditType",
    toAmino: ({
      updater,
      abbreviation,
      name
    }) => {
      return {
        updater,
        abbreviation,
        name
      };
    },
    fromAmino: ({
      updater,
      abbreviation,
      name
    }) => {
      return {
        updater,
        abbreviation,
        name
      };
    }
  },
  "/empowerchain.plasticcredit.MsgCreateProject": {
    aminoType: "/empowerchain.plasticcredit.MsgCreateProject",
    toAmino: ({
      creator,
      applicantId,
      creditTypeAbbreviation,
      name
    }) => {
      return {
        creator,
        applicant_id: applicantId.toString(),
        credit_type_abbreviation: creditTypeAbbreviation,
        name
      };
    },
    fromAmino: ({
      creator,
      applicant_id,
      credit_type_abbreviation,
      name
    }) => {
      return {
        creator,
        applicantId: BigInt(applicant_id),
        creditTypeAbbreviation: credit_type_abbreviation,
        name
      };
    }
  },
  "/empowerchain.plasticcredit.MsgUpdateProject": {
    aminoType: "/empowerchain.plasticcredit.MsgUpdateProject",
    toAmino: ({
      updater,
      projectId,
      name
    }) => {
      return {
        updater,
        project_id: projectId.toString(),
        name
      };
    },
    fromAmino: ({
      updater,
      project_id,
      name
    }) => {
      return {
        updater,
        projectId: BigInt(project_id),
        name
      };
    }
  },
  "/empowerchain.plasticcredit.MsgApproveProject": {
    aminoType: "/empowerchain.plasticcredit.MsgApproveProject",
    toAmino: ({
      approver,
      projectId
    }) => {
      return {
        approver,
        project_id: projectId.toString()
      };
    },
    fromAmino: ({
      approver,
      project_id
    }) => {
      return {
        approver,
        projectId: BigInt(project_id)
      };
    }
  },
  "/empowerchain.plasticcredit.MsgRejectProject": {
    aminoType: "/empowerchain.plasticcredit.MsgRejectProject",
    toAmino: ({
      rejector,
      projectId
    }) => {
      return {
        rejector,
        project_id: projectId.toString()
      };
    },
    fromAmino: ({
      rejector,
      project_id
    }) => {
      return {
        rejector,
        projectId: BigInt(project_id)
      };
    }
  },
  "/empowerchain.plasticcredit.MsgSuspendProject": {
    aminoType: "/empowerchain.plasticcredit.MsgSuspendProject",
    toAmino: ({
      updater,
      projectId
    }) => {
      return {
        updater,
        project_id: projectId.toString()
      };
    },
    fromAmino: ({
      updater,
      project_id
    }) => {
      return {
        updater,
        projectId: BigInt(project_id)
      };
    }
  },
  "/empowerchain.plasticcredit.MsgIssueCredits": {
    aminoType: "/empowerchain.plasticcredit.MsgIssueCredits",
    toAmino: ({
      creator,
      projectId,
      serialNumber,
      creditAmount,
      metadataUris
    }) => {
      return {
        creator,
        project_id: projectId.toString(),
        serial_number: serialNumber,
        credit_amount: creditAmount.toString(),
        metadata_uris: metadataUris
      };
    },
    fromAmino: ({
      creator,
      project_id,
      serial_number,
      credit_amount,
      metadata_uris
    }) => {
      return {
        creator,
        projectId: BigInt(project_id),
        serialNumber: serial_number,
        creditAmount: BigInt(credit_amount),
        metadataUris: metadata_uris
      };
    }
  },
  "/empowerchain.plasticcredit.MsgTransferCredits": {
    aminoType: "/empowerchain.plasticcredit.MsgTransferCredits",
    toAmino: ({
      from,
      to,
      denom,
      amount,
      retire,
      retiringEntityName,
      retiringEntityAdditionalData
    }) => {
      return {
        from,
        to,
        denom,
        amount: amount.toString(),
        retire,
        retiring_entity_name: retiringEntityName,
        retiring_entity_additional_data: retiringEntityAdditionalData
      };
    },
    fromAmino: ({
      from,
      to,
      denom,
      amount,
      retire,
      retiring_entity_name,
      retiring_entity_additional_data
    }) => {
      return {
        from,
        to,
        denom,
        amount: BigInt(amount),
        retire,
        retiringEntityName: retiring_entity_name,
        retiringEntityAdditionalData: retiring_entity_additional_data
      };
    }
  },
  "/empowerchain.plasticcredit.MsgRetireCredits": {
    aminoType: "/empowerchain.plasticcredit.MsgRetireCredits",
    toAmino: ({
      owner,
      denom,
      amount,
      retiringEntityName,
      retiringEntityAdditionalData
    }) => {
      return {
        owner,
        denom,
        amount: amount.toString(),
        retiring_entity_name: retiringEntityName,
        retiring_entity_additional_data: retiringEntityAdditionalData
      };
    },
    fromAmino: ({
      owner,
      denom,
      amount,
      retiring_entity_name,
      retiring_entity_additional_data
    }) => {
      return {
        owner,
        denom,
        amount: BigInt(amount),
        retiringEntityName: retiring_entity_name,
        retiringEntityAdditionalData: retiring_entity_additional_data
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/proofofexistence/tx.amino.js
var tx_amino_exports21 = {};
__export(tx_amino_exports21, {
  AminoConverter: () => AminoConverter21
});
var AminoConverter21 = {
  "/empowerchain.proofofexistence.MsgCreateProof": {
    aminoType: "/empowerchain.proofofexistence.MsgCreateProof",
    toAmino: ({
      creator,
      hash
    }) => {
      return {
        creator,
        hash
      };
    },
    fromAmino: ({
      creator,
      hash
    }) => {
      return {
        creator,
        hash
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/certificates/tx.registry.js
var tx_registry_exports19 = {};
__export(tx_registry_exports19, {
  MessageComposer: () => MessageComposer19,
  load: () => load19,
  registry: () => registry19
});
var registry19 = [["/empowerchain.certificates.MsgUpdateParams", MsgUpdateParams11], ["/empowerchain.certificates.MsgCreateCertificate", MsgCreateCertificate]];
var load19 = (protoRegistry) => {
  registry19.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer19 = {
  encoded: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgUpdateParams",
        value: MsgUpdateParams11.encode(value).finish()
      };
    },
    createCertificate(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgCreateCertificate",
        value: MsgCreateCertificate.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgUpdateParams",
        value
      };
    },
    createCertificate(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgCreateCertificate",
        value
      };
    }
  },
  toJSON: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgUpdateParams",
        value: MsgUpdateParams11.toJSON(value)
      };
    },
    createCertificate(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgCreateCertificate",
        value: MsgCreateCertificate.toJSON(value)
      };
    }
  },
  fromJSON: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgUpdateParams",
        value: MsgUpdateParams11.fromJSON(value)
      };
    },
    createCertificate(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgCreateCertificate",
        value: MsgCreateCertificate.fromJSON(value)
      };
    }
  },
  fromPartial: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgUpdateParams",
        value: MsgUpdateParams11.fromPartial(value)
      };
    },
    createCertificate(value) {
      return {
        typeUrl: "/empowerchain.certificates.MsgCreateCertificate",
        value: MsgCreateCertificate.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/plasticcredit/tx.registry.js
var tx_registry_exports20 = {};
__export(tx_registry_exports20, {
  MessageComposer: () => MessageComposer20,
  load: () => load20,
  registry: () => registry20
});
var registry20 = [["/empowerchain.plasticcredit.MsgUpdateParams", MsgUpdateParams12], ["/empowerchain.plasticcredit.MsgCreateIssuer", MsgCreateIssuer], ["/empowerchain.plasticcredit.MsgUpdateIssuer", MsgUpdateIssuer], ["/empowerchain.plasticcredit.MsgCreateApplicant", MsgCreateApplicant], ["/empowerchain.plasticcredit.MsgUpdateApplicant", MsgUpdateApplicant], ["/empowerchain.plasticcredit.MsgCreateCreditType", MsgCreateCreditType], ["/empowerchain.plasticcredit.MsgUpdateCreditType", MsgUpdateCreditType], ["/empowerchain.plasticcredit.MsgCreateProject", MsgCreateProject], ["/empowerchain.plasticcredit.MsgUpdateProject", MsgUpdateProject], ["/empowerchain.plasticcredit.MsgApproveProject", MsgApproveProject], ["/empowerchain.plasticcredit.MsgRejectProject", MsgRejectProject], ["/empowerchain.plasticcredit.MsgSuspendProject", MsgSuspendProject], ["/empowerchain.plasticcredit.MsgIssueCredits", MsgIssueCredits], ["/empowerchain.plasticcredit.MsgTransferCredits", MsgTransferCredits], ["/empowerchain.plasticcredit.MsgRetireCredits", MsgRetireCredits]];
var load20 = (protoRegistry) => {
  registry20.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer20 = {
  encoded: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateParams",
        value: MsgUpdateParams12.encode(value).finish()
      };
    },
    createIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateIssuer",
        value: MsgCreateIssuer.encode(value).finish()
      };
    },
    updateIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateIssuer",
        value: MsgUpdateIssuer.encode(value).finish()
      };
    },
    createApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateApplicant",
        value: MsgCreateApplicant.encode(value).finish()
      };
    },
    updateApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateApplicant",
        value: MsgUpdateApplicant.encode(value).finish()
      };
    },
    createCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateCreditType",
        value: MsgCreateCreditType.encode(value).finish()
      };
    },
    updateCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateCreditType",
        value: MsgUpdateCreditType.encode(value).finish()
      };
    },
    createProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateProject",
        value: MsgCreateProject.encode(value).finish()
      };
    },
    updateProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateProject",
        value: MsgUpdateProject.encode(value).finish()
      };
    },
    approveProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgApproveProject",
        value: MsgApproveProject.encode(value).finish()
      };
    },
    rejectProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRejectProject",
        value: MsgRejectProject.encode(value).finish()
      };
    },
    suspendProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgSuspendProject",
        value: MsgSuspendProject.encode(value).finish()
      };
    },
    issueCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgIssueCredits",
        value: MsgIssueCredits.encode(value).finish()
      };
    },
    transferCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgTransferCredits",
        value: MsgTransferCredits.encode(value).finish()
      };
    },
    retireCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRetireCredits",
        value: MsgRetireCredits.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateParams",
        value
      };
    },
    createIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateIssuer",
        value
      };
    },
    updateIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateIssuer",
        value
      };
    },
    createApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateApplicant",
        value
      };
    },
    updateApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateApplicant",
        value
      };
    },
    createCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateCreditType",
        value
      };
    },
    updateCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateCreditType",
        value
      };
    },
    createProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateProject",
        value
      };
    },
    updateProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateProject",
        value
      };
    },
    approveProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgApproveProject",
        value
      };
    },
    rejectProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRejectProject",
        value
      };
    },
    suspendProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgSuspendProject",
        value
      };
    },
    issueCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgIssueCredits",
        value
      };
    },
    transferCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgTransferCredits",
        value
      };
    },
    retireCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRetireCredits",
        value
      };
    }
  },
  toJSON: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateParams",
        value: MsgUpdateParams12.toJSON(value)
      };
    },
    createIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateIssuer",
        value: MsgCreateIssuer.toJSON(value)
      };
    },
    updateIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateIssuer",
        value: MsgUpdateIssuer.toJSON(value)
      };
    },
    createApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateApplicant",
        value: MsgCreateApplicant.toJSON(value)
      };
    },
    updateApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateApplicant",
        value: MsgUpdateApplicant.toJSON(value)
      };
    },
    createCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateCreditType",
        value: MsgCreateCreditType.toJSON(value)
      };
    },
    updateCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateCreditType",
        value: MsgUpdateCreditType.toJSON(value)
      };
    },
    createProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateProject",
        value: MsgCreateProject.toJSON(value)
      };
    },
    updateProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateProject",
        value: MsgUpdateProject.toJSON(value)
      };
    },
    approveProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgApproveProject",
        value: MsgApproveProject.toJSON(value)
      };
    },
    rejectProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRejectProject",
        value: MsgRejectProject.toJSON(value)
      };
    },
    suspendProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgSuspendProject",
        value: MsgSuspendProject.toJSON(value)
      };
    },
    issueCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgIssueCredits",
        value: MsgIssueCredits.toJSON(value)
      };
    },
    transferCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgTransferCredits",
        value: MsgTransferCredits.toJSON(value)
      };
    },
    retireCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRetireCredits",
        value: MsgRetireCredits.toJSON(value)
      };
    }
  },
  fromJSON: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateParams",
        value: MsgUpdateParams12.fromJSON(value)
      };
    },
    createIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateIssuer",
        value: MsgCreateIssuer.fromJSON(value)
      };
    },
    updateIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateIssuer",
        value: MsgUpdateIssuer.fromJSON(value)
      };
    },
    createApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateApplicant",
        value: MsgCreateApplicant.fromJSON(value)
      };
    },
    updateApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateApplicant",
        value: MsgUpdateApplicant.fromJSON(value)
      };
    },
    createCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateCreditType",
        value: MsgCreateCreditType.fromJSON(value)
      };
    },
    updateCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateCreditType",
        value: MsgUpdateCreditType.fromJSON(value)
      };
    },
    createProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateProject",
        value: MsgCreateProject.fromJSON(value)
      };
    },
    updateProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateProject",
        value: MsgUpdateProject.fromJSON(value)
      };
    },
    approveProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgApproveProject",
        value: MsgApproveProject.fromJSON(value)
      };
    },
    rejectProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRejectProject",
        value: MsgRejectProject.fromJSON(value)
      };
    },
    suspendProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgSuspendProject",
        value: MsgSuspendProject.fromJSON(value)
      };
    },
    issueCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgIssueCredits",
        value: MsgIssueCredits.fromJSON(value)
      };
    },
    transferCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgTransferCredits",
        value: MsgTransferCredits.fromJSON(value)
      };
    },
    retireCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRetireCredits",
        value: MsgRetireCredits.fromJSON(value)
      };
    }
  },
  fromPartial: {
    updateParams(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateParams",
        value: MsgUpdateParams12.fromPartial(value)
      };
    },
    createIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateIssuer",
        value: MsgCreateIssuer.fromPartial(value)
      };
    },
    updateIssuer(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateIssuer",
        value: MsgUpdateIssuer.fromPartial(value)
      };
    },
    createApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateApplicant",
        value: MsgCreateApplicant.fromPartial(value)
      };
    },
    updateApplicant(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateApplicant",
        value: MsgUpdateApplicant.fromPartial(value)
      };
    },
    createCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateCreditType",
        value: MsgCreateCreditType.fromPartial(value)
      };
    },
    updateCreditType(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateCreditType",
        value: MsgUpdateCreditType.fromPartial(value)
      };
    },
    createProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgCreateProject",
        value: MsgCreateProject.fromPartial(value)
      };
    },
    updateProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgUpdateProject",
        value: MsgUpdateProject.fromPartial(value)
      };
    },
    approveProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgApproveProject",
        value: MsgApproveProject.fromPartial(value)
      };
    },
    rejectProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRejectProject",
        value: MsgRejectProject.fromPartial(value)
      };
    },
    suspendProject(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgSuspendProject",
        value: MsgSuspendProject.fromPartial(value)
      };
    },
    issueCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgIssueCredits",
        value: MsgIssueCredits.fromPartial(value)
      };
    },
    transferCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgTransferCredits",
        value: MsgTransferCredits.fromPartial(value)
      };
    },
    retireCredits(value) {
      return {
        typeUrl: "/empowerchain.plasticcredit.MsgRetireCredits",
        value: MsgRetireCredits.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/proofofexistence/tx.registry.js
var tx_registry_exports21 = {};
__export(tx_registry_exports21, {
  MessageComposer: () => MessageComposer21,
  load: () => load21,
  registry: () => registry21
});
var registry21 = [["/empowerchain.proofofexistence.MsgCreateProof", MsgCreateProof]];
var load21 = (protoRegistry) => {
  registry21.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer21 = {
  encoded: {
    createProof(value) {
      return {
        typeUrl: "/empowerchain.proofofexistence.MsgCreateProof",
        value: MsgCreateProof.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    createProof(value) {
      return {
        typeUrl: "/empowerchain.proofofexistence.MsgCreateProof",
        value
      };
    }
  },
  toJSON: {
    createProof(value) {
      return {
        typeUrl: "/empowerchain.proofofexistence.MsgCreateProof",
        value: MsgCreateProof.toJSON(value)
      };
    }
  },
  fromJSON: {
    createProof(value) {
      return {
        typeUrl: "/empowerchain.proofofexistence.MsgCreateProof",
        value: MsgCreateProof.fromJSON(value)
      };
    }
  },
  fromPartial: {
    createProof(value) {
      return {
        typeUrl: "/empowerchain.proofofexistence.MsgCreateProof",
        value: MsgCreateProof.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/rpc.query.js
var rpc_query_exports3 = {};
__export(rpc_query_exports3, {
  createRPCQueryClient: () => createRPCQueryClient3
});
var import_tendermint_rpc3 = __toESM(require_build7());
var import_stargate5 = __toESM(require_build8());
var createRPCQueryClient3 = async ({
  rpcEndpoint
}) => {
  const tmClient = await import_tendermint_rpc3.Tendermint34Client.connect(rpcEndpoint);
  const client = new import_stargate5.QueryClient(tmClient);
  return {
    cosmos: {
      app: {
        v1alpha1: (await import("./query.rpc.Query-Z645J2C5.js")).createRpcQueryExtension(client)
      },
      auth: {
        v1beta1: (await import("./query.rpc.Query-HSLFEKVN.js")).createRpcQueryExtension(client)
      },
      authz: {
        v1beta1: (await import("./query.rpc.Query-VOBALZII.js")).createRpcQueryExtension(client)
      },
      autocli: {
        v1: (await import("./query.rpc.Query-3ECKZXP6.js")).createRpcQueryExtension(client)
      },
      bank: {
        v1beta1: (await import("./query.rpc.Query-IKLKUQBX.js")).createRpcQueryExtension(client)
      },
      base: {
        node: {
          v1beta1: (await import("./query.rpc.Service-OGSDUVYD.js")).createRpcQueryExtension(client)
        },
        tendermint: {
          v1beta1: (await import("./query.rpc.Service-UMVNZL3P.js")).createRpcQueryExtension(client)
        }
      },
      consensus: {
        v1: (await import("./query.rpc.Query-3VII2VNJ.js")).createRpcQueryExtension(client)
      },
      distribution: {
        v1beta1: (await import("./query.rpc.Query-OHEFBXHH.js")).createRpcQueryExtension(client)
      },
      evidence: {
        v1beta1: (await import("./query.rpc.Query-XMO4CSIX.js")).createRpcQueryExtension(client)
      },
      feegrant: {
        v1beta1: (await import("./query.rpc.Query-75IUKG33.js")).createRpcQueryExtension(client)
      },
      gov: {
        v1: (await import("./query.rpc.Query-4R3ETNBS.js")).createRpcQueryExtension(client),
        v1beta1: (await import("./query.rpc.Query-LMLDHT3F.js")).createRpcQueryExtension(client)
      },
      group: {
        v1: (await import("./query.rpc.Query-YAFZXBYA.js")).createRpcQueryExtension(client)
      },
      mint: {
        v1beta1: (await import("./query.rpc.Query-HMTMFHXZ.js")).createRpcQueryExtension(client)
      },
      nft: {
        v1beta1: (await import("./query.rpc.Query-FGSDCMTH.js")).createRpcQueryExtension(client)
      },
      orm: {
        query: {
          v1alpha1: (await import("./query.rpc.Query-PE7Q6FYK.js")).createRpcQueryExtension(client)
        }
      },
      params: {
        v1beta1: (await import("./query.rpc.Query-AEFB4JOF.js")).createRpcQueryExtension(client)
      },
      slashing: {
        v1beta1: (await import("./query.rpc.Query-S22SWOLR.js")).createRpcQueryExtension(client)
      },
      staking: {
        v1beta1: (await import("./query.rpc.Query-5LB62TJJ.js")).createRpcQueryExtension(client)
      },
      tx: {
        v1beta1: (await import("./service.rpc.Service-5OSPDZTY.js")).createRpcQueryExtension(client)
      },
      upgrade: {
        v1beta1: (await import("./query.rpc.Query-MKAFUIMA.js")).createRpcQueryExtension(client)
      }
    },
    empowerchain: {
      certificates: (await import("./query.rpc.Query-H4BGYSDH.js")).createRpcQueryExtension(client),
      plasticcredit: (await import("./query.rpc.Query-7XTGAJAH.js")).createRpcQueryExtension(client),
      proofofexistence: (await import("./query.rpc.Query-4FNXCZPX.js")).createRpcQueryExtension(client)
    }
  };
};

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/rpc.tx.js
var rpc_tx_exports3 = {};
__export(rpc_tx_exports3, {
  createRPCMsgClient: () => createRPCMsgClient3
});
var createRPCMsgClient3 = async ({
  rpc
}) => ({
  cosmos: {
    auth: {
      v1beta1: new (await import("./tx.rpc.msg-BKM7GIDF.js")).MsgClientImpl(rpc)
    },
    authz: {
      v1beta1: new (await import("./tx.rpc.msg-4IOFIOJT.js")).MsgClientImpl(rpc)
    },
    bank: {
      v1beta1: new (await import("./tx.rpc.msg-GY3AG57M.js")).MsgClientImpl(rpc)
    },
    consensus: {
      v1: new (await import("./tx.rpc.msg-7IS2XNHP.js")).MsgClientImpl(rpc)
    },
    crisis: {
      v1beta1: new (await import("./tx.rpc.msg-2P7C25FF.js")).MsgClientImpl(rpc)
    },
    distribution: {
      v1beta1: new (await import("./tx.rpc.msg-5N6UVCQE.js")).MsgClientImpl(rpc)
    },
    evidence: {
      v1beta1: new (await import("./tx.rpc.msg-AIXRTESQ.js")).MsgClientImpl(rpc)
    },
    feegrant: {
      v1beta1: new (await import("./tx.rpc.msg-F3E4UQKA.js")).MsgClientImpl(rpc)
    },
    gov: {
      v1: new (await import("./tx.rpc.msg-EPAYKNRX.js")).MsgClientImpl(rpc),
      v1beta1: new (await import("./tx.rpc.msg-WTSROBNU.js")).MsgClientImpl(rpc)
    },
    group: {
      v1: new (await import("./tx.rpc.msg-3CXHGTHS.js")).MsgClientImpl(rpc)
    },
    mint: {
      v1beta1: new (await import("./tx.rpc.msg-7L6KBKRN.js")).MsgClientImpl(rpc)
    },
    nft: {
      v1beta1: new (await import("./tx.rpc.msg-PDAZEZ2U.js")).MsgClientImpl(rpc)
    },
    slashing: {
      v1beta1: new (await import("./tx.rpc.msg-GQQ4TSDM.js")).MsgClientImpl(rpc)
    },
    staking: {
      v1beta1: new (await import("./tx.rpc.msg-2OHK3UTX.js")).MsgClientImpl(rpc)
    },
    upgrade: {
      v1beta1: new (await import("./tx.rpc.msg-FXRHAFBV.js")).MsgClientImpl(rpc)
    },
    vesting: {
      v1beta1: new (await import("./tx.rpc.msg-DIHQBATM.js")).MsgClientImpl(rpc)
    }
  },
  empowerchain: {
    certificates: new (await import("./tx.rpc.msg-474JNMUB.js")).MsgClientImpl(rpc),
    plasticcredit: new (await import("./tx.rpc.msg-EX5ZPUME.js")).MsgClientImpl(rpc),
    proofofexistence: new (await import("./tx.rpc.msg-TJONGR7S.js")).MsgClientImpl(rpc)
  }
});

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/bundle.js
function ownKeys7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var empowerchain;
(function(_empowerchain) {
  const certificates = _empowerchain.certificates = _objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7({}, events_exports2), genesis_exports19), query_exports23), tx_exports20), types_exports8), tx_amino_exports19), tx_registry_exports19), query_rpc_Query_exports21), tx_rpc_msg_exports19);
  const plasticcredit = _empowerchain.plasticcredit = _objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7({}, authz_exports5), events_exports3), genesis_exports20), query_exports24), tx_exports21), types_exports9), tx_amino_exports20), tx_registry_exports20), query_rpc_Query_exports22), tx_rpc_msg_exports20);
  const proofofexistence = _empowerchain.proofofexistence = _objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7(_objectSpread7({}, events_exports4), genesis_exports21), query_exports25), tx_exports22), types_exports10), tx_amino_exports21), tx_registry_exports21), query_rpc_Query_exports23), tx_rpc_msg_exports21);
  const ClientFactory = _empowerchain.ClientFactory = _objectSpread7(_objectSpread7({}, rpc_query_exports3), rpc_tx_exports3);
})(empowerchain || (empowerchain = {}));

// node_modules/@empower-plastic/empowerjs/module/codegen/empowerchain/client.js
var import_proto_signing3 = __toESM(require_build6());
var import_stargate6 = __toESM(require_build8());
function ownKeys8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys8(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var empowerchainAminoConverters = _objectSpread8(_objectSpread8(_objectSpread8({}, AminoConverter19), AminoConverter20), AminoConverter21);
var empowerchainProtoRegistry = [...registry19, ...registry20, ...registry21];
var getSigningEmpowerchainClientOptions = ({
  defaultTypes = import_stargate6.defaultRegistryTypes
} = {}) => {
  const registry28 = new import_proto_signing3.Registry([...defaultTypes, ...empowerchainProtoRegistry]);
  const aminoTypes = new import_stargate6.AminoTypes(_objectSpread8({}, empowerchainAminoConverters));
  return {
    registry: registry28,
    aminoTypes
  };
};
var getSigningEmpowerchainClient = async ({
  rpcEndpoint,
  signer,
  defaultTypes = import_stargate6.defaultRegistryTypes
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningEmpowerchainClientOptions({
    defaultTypes
  });
  const client = await import_stargate6.SigningStargateClient.connectWithSigner(rpcEndpoint, signer, {
    registry: registry28,
    aminoTypes
  });
  return client;
};

// node_modules/@empower-plastic/empowerjs/module/codegen/gogoproto/gogo.js
var gogo_exports = {};

// node_modules/@empower-plastic/empowerjs/module/codegen/gogoproto/bundle.js
function ownKeys9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys9(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var gogoproto = _objectSpread9({}, gogo_exports);

// node_modules/@empower-plastic/empowerjs/module/codegen/google/api/annotations.js
var annotations_exports = {};

// node_modules/@empower-plastic/empowerjs/module/codegen/google/api/http.js
var http_exports = {};
__export(http_exports, {
  CustomHttpPattern: () => CustomHttpPattern,
  Http: () => Http,
  HttpRule: () => HttpRule
});
var _m075 = __toESM(require_minimal());
function createBaseHttp() {
  return {
    rules: [],
    fullyDecodeReservedExpansion: false
  };
}
var Http = {
  encode(message, writer = _m075.Writer.create()) {
    for (const v of message.rules) {
      HttpRule.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.fullyDecodeReservedExpansion === true) {
      writer.uint32(16).bool(message.fullyDecodeReservedExpansion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m075.Reader ? input : new _m075.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHttp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rules.push(HttpRule.decode(reader, reader.uint32()));
          break;
        case 2:
          message.fullyDecodeReservedExpansion = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      rules: Array.isArray(object === null || object === void 0 ? void 0 : object.rules) ? object.rules.map((e) => HttpRule.fromJSON(e)) : [],
      fullyDecodeReservedExpansion: isSet(object.fullyDecodeReservedExpansion) ? Boolean(object.fullyDecodeReservedExpansion) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rules) {
      obj.rules = message.rules.map((e) => e ? HttpRule.toJSON(e) : void 0);
    } else {
      obj.rules = [];
    }
    message.fullyDecodeReservedExpansion !== void 0 && (obj.fullyDecodeReservedExpansion = message.fullyDecodeReservedExpansion);
    return obj;
  },
  fromPartial(object) {
    var _object$rules, _object$fullyDecodeRe;
    const message = createBaseHttp();
    message.rules = ((_object$rules = object.rules) === null || _object$rules === void 0 ? void 0 : _object$rules.map((e) => HttpRule.fromPartial(e))) || [];
    message.fullyDecodeReservedExpansion = (_object$fullyDecodeRe = object.fullyDecodeReservedExpansion) !== null && _object$fullyDecodeRe !== void 0 ? _object$fullyDecodeRe : false;
    return message;
  }
};
function createBaseHttpRule() {
  return {
    selector: "",
    get: void 0,
    put: void 0,
    post: void 0,
    delete: void 0,
    patch: void 0,
    custom: void 0,
    body: "",
    responseBody: "",
    additionalBindings: []
  };
}
var HttpRule = {
  encode(message, writer = _m075.Writer.create()) {
    if (message.selector !== "") {
      writer.uint32(10).string(message.selector);
    }
    if (message.get !== void 0) {
      writer.uint32(18).string(message.get);
    }
    if (message.put !== void 0) {
      writer.uint32(26).string(message.put);
    }
    if (message.post !== void 0) {
      writer.uint32(34).string(message.post);
    }
    if (message.delete !== void 0) {
      writer.uint32(42).string(message.delete);
    }
    if (message.patch !== void 0) {
      writer.uint32(50).string(message.patch);
    }
    if (message.custom !== void 0) {
      CustomHttpPattern.encode(message.custom, writer.uint32(66).fork()).ldelim();
    }
    if (message.body !== "") {
      writer.uint32(58).string(message.body);
    }
    if (message.responseBody !== "") {
      writer.uint32(98).string(message.responseBody);
    }
    for (const v of message.additionalBindings) {
      HttpRule.encode(v, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m075.Reader ? input : new _m075.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHttpRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.selector = reader.string();
          break;
        case 2:
          message.get = reader.string();
          break;
        case 3:
          message.put = reader.string();
          break;
        case 4:
          message.post = reader.string();
          break;
        case 5:
          message.delete = reader.string();
          break;
        case 6:
          message.patch = reader.string();
          break;
        case 8:
          message.custom = CustomHttpPattern.decode(reader, reader.uint32());
          break;
        case 7:
          message.body = reader.string();
          break;
        case 12:
          message.responseBody = reader.string();
          break;
        case 11:
          message.additionalBindings.push(HttpRule.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      selector: isSet(object.selector) ? String(object.selector) : "",
      get: isSet(object.get) ? String(object.get) : void 0,
      put: isSet(object.put) ? String(object.put) : void 0,
      post: isSet(object.post) ? String(object.post) : void 0,
      delete: isSet(object.delete) ? String(object.delete) : void 0,
      patch: isSet(object.patch) ? String(object.patch) : void 0,
      custom: isSet(object.custom) ? CustomHttpPattern.fromJSON(object.custom) : void 0,
      body: isSet(object.body) ? String(object.body) : "",
      responseBody: isSet(object.responseBody) ? String(object.responseBody) : "",
      additionalBindings: Array.isArray(object === null || object === void 0 ? void 0 : object.additionalBindings) ? object.additionalBindings.map((e) => HttpRule.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.selector !== void 0 && (obj.selector = message.selector);
    message.get !== void 0 && (obj.get = message.get);
    message.put !== void 0 && (obj.put = message.put);
    message.post !== void 0 && (obj.post = message.post);
    message.delete !== void 0 && (obj.delete = message.delete);
    message.patch !== void 0 && (obj.patch = message.patch);
    message.custom !== void 0 && (obj.custom = message.custom ? CustomHttpPattern.toJSON(message.custom) : void 0);
    message.body !== void 0 && (obj.body = message.body);
    message.responseBody !== void 0 && (obj.responseBody = message.responseBody);
    if (message.additionalBindings) {
      obj.additionalBindings = message.additionalBindings.map((e) => e ? HttpRule.toJSON(e) : void 0);
    } else {
      obj.additionalBindings = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$selector, _object$get, _object$put, _object$post, _object$delete, _object$patch, _object$body, _object$responseBody, _object$additionalBin;
    const message = createBaseHttpRule();
    message.selector = (_object$selector = object.selector) !== null && _object$selector !== void 0 ? _object$selector : "";
    message.get = (_object$get = object.get) !== null && _object$get !== void 0 ? _object$get : void 0;
    message.put = (_object$put = object.put) !== null && _object$put !== void 0 ? _object$put : void 0;
    message.post = (_object$post = object.post) !== null && _object$post !== void 0 ? _object$post : void 0;
    message.delete = (_object$delete = object.delete) !== null && _object$delete !== void 0 ? _object$delete : void 0;
    message.patch = (_object$patch = object.patch) !== null && _object$patch !== void 0 ? _object$patch : void 0;
    message.custom = object.custom !== void 0 && object.custom !== null ? CustomHttpPattern.fromPartial(object.custom) : void 0;
    message.body = (_object$body = object.body) !== null && _object$body !== void 0 ? _object$body : "";
    message.responseBody = (_object$responseBody = object.responseBody) !== null && _object$responseBody !== void 0 ? _object$responseBody : "";
    message.additionalBindings = ((_object$additionalBin = object.additionalBindings) === null || _object$additionalBin === void 0 ? void 0 : _object$additionalBin.map((e) => HttpRule.fromPartial(e))) || [];
    return message;
  }
};
function createBaseCustomHttpPattern() {
  return {
    kind: "",
    path: ""
  };
}
var CustomHttpPattern = {
  encode(message, writer = _m075.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m075.Reader ? input : new _m075.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomHttpPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.path = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet(object.kind) ? String(object.kind) : "",
      path: isSet(object.path) ? String(object.path) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.path !== void 0 && (obj.path = message.path);
    return obj;
  },
  fromPartial(object) {
    var _object$kind, _object$path;
    const message = createBaseCustomHttpPattern();
    message.kind = (_object$kind = object.kind) !== null && _object$kind !== void 0 ? _object$kind : "";
    message.path = (_object$path = object.path) !== null && _object$path !== void 0 ? _object$path : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/google/protobuf/empty.js
var empty_exports = {};
__export(empty_exports, {
  Empty: () => Empty
});
var _m076 = __toESM(require_minimal());
function createBaseEmpty() {
  return {};
}
var Empty = {
  encode(_, writer = _m076.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m076.Reader ? input : new _m076.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseEmpty();
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/google/bundle.js
function ownKeys10(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread10(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys10(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys10(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var google;
(function(_google) {
  const api = _google.api = _objectSpread10(_objectSpread10({}, annotations_exports), http_exports);
  const protobuf = _google.protobuf = _objectSpread10(_objectSpread10(_objectSpread10(_objectSpread10(_objectSpread10({}, any_exports), descriptor_exports), duration_exports), empty_exports), timestamp_exports);
})(google || (google = {}));

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/fee/v1/ack.js
var ack_exports = {};
__export(ack_exports, {
  IncentivizedAcknowledgement: () => IncentivizedAcknowledgement
});
var _m077 = __toESM(require_minimal());
function createBaseIncentivizedAcknowledgement() {
  return {
    appAcknowledgement: new Uint8Array(),
    forwardRelayerAddress: "",
    underlyingAppSuccess: false
  };
}
var IncentivizedAcknowledgement = {
  encode(message, writer = _m077.Writer.create()) {
    if (message.appAcknowledgement.length !== 0) {
      writer.uint32(10).bytes(message.appAcknowledgement);
    }
    if (message.forwardRelayerAddress !== "") {
      writer.uint32(18).string(message.forwardRelayerAddress);
    }
    if (message.underlyingAppSuccess === true) {
      writer.uint32(24).bool(message.underlyingAppSuccess);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m077.Reader ? input : new _m077.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIncentivizedAcknowledgement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appAcknowledgement = reader.bytes();
          break;
        case 2:
          message.forwardRelayerAddress = reader.string();
          break;
        case 3:
          message.underlyingAppSuccess = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appAcknowledgement: isSet(object.appAcknowledgement) ? bytesFromBase64(object.appAcknowledgement) : new Uint8Array(),
      forwardRelayerAddress: isSet(object.forwardRelayerAddress) ? String(object.forwardRelayerAddress) : "",
      underlyingAppSuccess: isSet(object.underlyingAppSuccess) ? Boolean(object.underlyingAppSuccess) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.appAcknowledgement !== void 0 && (obj.appAcknowledgement = base64FromBytes(message.appAcknowledgement !== void 0 ? message.appAcknowledgement : new Uint8Array()));
    message.forwardRelayerAddress !== void 0 && (obj.forwardRelayerAddress = message.forwardRelayerAddress);
    message.underlyingAppSuccess !== void 0 && (obj.underlyingAppSuccess = message.underlyingAppSuccess);
    return obj;
  },
  fromPartial(object) {
    var _object$appAcknowledg, _object$forwardRelaye, _object$underlyingApp;
    const message = createBaseIncentivizedAcknowledgement();
    message.appAcknowledgement = (_object$appAcknowledg = object.appAcknowledgement) !== null && _object$appAcknowledg !== void 0 ? _object$appAcknowledg : new Uint8Array();
    message.forwardRelayerAddress = (_object$forwardRelaye = object.forwardRelayerAddress) !== null && _object$forwardRelaye !== void 0 ? _object$forwardRelaye : "";
    message.underlyingAppSuccess = (_object$underlyingApp = object.underlyingAppSuccess) !== null && _object$underlyingApp !== void 0 ? _object$underlyingApp : false;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/fee/v1/metadata.js
var metadata_exports = {};
__export(metadata_exports, {
  Metadata: () => Metadata3
});
var _m078 = __toESM(require_minimal());
function createBaseMetadata2() {
  return {
    feeVersion: "",
    appVersion: ""
  };
}
var Metadata3 = {
  encode(message, writer = _m078.Writer.create()) {
    if (message.feeVersion !== "") {
      writer.uint32(10).string(message.feeVersion);
    }
    if (message.appVersion !== "") {
      writer.uint32(18).string(message.appVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m078.Reader ? input : new _m078.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMetadata2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feeVersion = reader.string();
          break;
        case 2:
          message.appVersion = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      feeVersion: isSet(object.feeVersion) ? String(object.feeVersion) : "",
      appVersion: isSet(object.appVersion) ? String(object.appVersion) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.feeVersion !== void 0 && (obj.feeVersion = message.feeVersion);
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion);
    return obj;
  },
  fromPartial(object) {
    var _object$feeVersion, _object$appVersion;
    const message = createBaseMetadata2();
    message.feeVersion = (_object$feeVersion = object.feeVersion) !== null && _object$feeVersion !== void 0 ? _object$feeVersion : "";
    message.appVersion = (_object$appVersion = object.appVersion) !== null && _object$appVersion !== void 0 ? _object$appVersion : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/interchain_accounts/genesis/v1/genesis.js
var genesis_exports22 = {};
__export(genesis_exports22, {
  ActiveChannel: () => ActiveChannel,
  ControllerGenesisState: () => ControllerGenesisState,
  GenesisState: () => GenesisState21,
  HostGenesisState: () => HostGenesisState,
  RegisteredInterchainAccount: () => RegisteredInterchainAccount
});
var _m079 = __toESM(require_minimal());
function createBaseGenesisState21() {
  return {
    controllerGenesisState: void 0,
    hostGenesisState: void 0
  };
}
var GenesisState21 = {
  encode(message, writer = _m079.Writer.create()) {
    if (message.controllerGenesisState !== void 0) {
      ControllerGenesisState.encode(message.controllerGenesisState, writer.uint32(10).fork()).ldelim();
    }
    if (message.hostGenesisState !== void 0) {
      HostGenesisState.encode(message.hostGenesisState, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m079.Reader ? input : new _m079.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState21();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.controllerGenesisState = ControllerGenesisState.decode(reader, reader.uint32());
          break;
        case 2:
          message.hostGenesisState = HostGenesisState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      controllerGenesisState: isSet(object.controllerGenesisState) ? ControllerGenesisState.fromJSON(object.controllerGenesisState) : void 0,
      hostGenesisState: isSet(object.hostGenesisState) ? HostGenesisState.fromJSON(object.hostGenesisState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.controllerGenesisState !== void 0 && (obj.controllerGenesisState = message.controllerGenesisState ? ControllerGenesisState.toJSON(message.controllerGenesisState) : void 0);
    message.hostGenesisState !== void 0 && (obj.hostGenesisState = message.hostGenesisState ? HostGenesisState.toJSON(message.hostGenesisState) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenesisState21();
    message.controllerGenesisState = object.controllerGenesisState !== void 0 && object.controllerGenesisState !== null ? ControllerGenesisState.fromPartial(object.controllerGenesisState) : void 0;
    message.hostGenesisState = object.hostGenesisState !== void 0 && object.hostGenesisState !== null ? HostGenesisState.fromPartial(object.hostGenesisState) : void 0;
    return message;
  }
};
function createBaseControllerGenesisState() {
  return {
    activeChannels: [],
    interchainAccounts: [],
    ports: [],
    params: void 0
  };
}
var ControllerGenesisState = {
  encode(message, writer = _m079.Writer.create()) {
    for (const v of message.activeChannels) {
      ActiveChannel.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.interchainAccounts) {
      RegisteredInterchainAccount.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.ports) {
      writer.uint32(26).string(v);
    }
    if (message.params !== void 0) {
      Params12.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m079.Reader ? input : new _m079.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseControllerGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.activeChannels.push(ActiveChannel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.interchainAccounts.push(RegisteredInterchainAccount.decode(reader, reader.uint32()));
          break;
        case 3:
          message.ports.push(reader.string());
          break;
        case 4:
          message.params = Params12.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      activeChannels: Array.isArray(object === null || object === void 0 ? void 0 : object.activeChannels) ? object.activeChannels.map((e) => ActiveChannel.fromJSON(e)) : [],
      interchainAccounts: Array.isArray(object === null || object === void 0 ? void 0 : object.interchainAccounts) ? object.interchainAccounts.map((e) => RegisteredInterchainAccount.fromJSON(e)) : [],
      ports: Array.isArray(object === null || object === void 0 ? void 0 : object.ports) ? object.ports.map((e) => String(e)) : [],
      params: isSet(object.params) ? Params12.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.activeChannels) {
      obj.activeChannels = message.activeChannels.map((e) => e ? ActiveChannel.toJSON(e) : void 0);
    } else {
      obj.activeChannels = [];
    }
    if (message.interchainAccounts) {
      obj.interchainAccounts = message.interchainAccounts.map((e) => e ? RegisteredInterchainAccount.toJSON(e) : void 0);
    } else {
      obj.interchainAccounts = [];
    }
    if (message.ports) {
      obj.ports = message.ports.map((e) => e);
    } else {
      obj.ports = [];
    }
    message.params !== void 0 && (obj.params = message.params ? Params12.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$activeChannel, _object$interchainAcc, _object$ports;
    const message = createBaseControllerGenesisState();
    message.activeChannels = ((_object$activeChannel = object.activeChannels) === null || _object$activeChannel === void 0 ? void 0 : _object$activeChannel.map((e) => ActiveChannel.fromPartial(e))) || [];
    message.interchainAccounts = ((_object$interchainAcc = object.interchainAccounts) === null || _object$interchainAcc === void 0 ? void 0 : _object$interchainAcc.map((e) => RegisteredInterchainAccount.fromPartial(e))) || [];
    message.ports = ((_object$ports = object.ports) === null || _object$ports === void 0 ? void 0 : _object$ports.map((e) => e)) || [];
    message.params = object.params !== void 0 && object.params !== null ? Params12.fromPartial(object.params) : void 0;
    return message;
  }
};
function createBaseHostGenesisState() {
  return {
    activeChannels: [],
    interchainAccounts: [],
    port: "",
    params: void 0
  };
}
var HostGenesisState = {
  encode(message, writer = _m079.Writer.create()) {
    for (const v of message.activeChannels) {
      ActiveChannel.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.interchainAccounts) {
      RegisteredInterchainAccount.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.params !== void 0) {
      Params13.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m079.Reader ? input : new _m079.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHostGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.activeChannels.push(ActiveChannel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.interchainAccounts.push(RegisteredInterchainAccount.decode(reader, reader.uint32()));
          break;
        case 3:
          message.port = reader.string();
          break;
        case 4:
          message.params = Params13.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      activeChannels: Array.isArray(object === null || object === void 0 ? void 0 : object.activeChannels) ? object.activeChannels.map((e) => ActiveChannel.fromJSON(e)) : [],
      interchainAccounts: Array.isArray(object === null || object === void 0 ? void 0 : object.interchainAccounts) ? object.interchainAccounts.map((e) => RegisteredInterchainAccount.fromJSON(e)) : [],
      port: isSet(object.port) ? String(object.port) : "",
      params: isSet(object.params) ? Params13.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.activeChannels) {
      obj.activeChannels = message.activeChannels.map((e) => e ? ActiveChannel.toJSON(e) : void 0);
    } else {
      obj.activeChannels = [];
    }
    if (message.interchainAccounts) {
      obj.interchainAccounts = message.interchainAccounts.map((e) => e ? RegisteredInterchainAccount.toJSON(e) : void 0);
    } else {
      obj.interchainAccounts = [];
    }
    message.port !== void 0 && (obj.port = message.port);
    message.params !== void 0 && (obj.params = message.params ? Params13.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$activeChannel2, _object$interchainAcc2, _object$port;
    const message = createBaseHostGenesisState();
    message.activeChannels = ((_object$activeChannel2 = object.activeChannels) === null || _object$activeChannel2 === void 0 ? void 0 : _object$activeChannel2.map((e) => ActiveChannel.fromPartial(e))) || [];
    message.interchainAccounts = ((_object$interchainAcc2 = object.interchainAccounts) === null || _object$interchainAcc2 === void 0 ? void 0 : _object$interchainAcc2.map((e) => RegisteredInterchainAccount.fromPartial(e))) || [];
    message.port = (_object$port = object.port) !== null && _object$port !== void 0 ? _object$port : "";
    message.params = object.params !== void 0 && object.params !== null ? Params13.fromPartial(object.params) : void 0;
    return message;
  }
};
function createBaseActiveChannel() {
  return {
    connectionId: "",
    portId: "",
    channelId: "",
    isMiddlewareEnabled: false
  };
}
var ActiveChannel = {
  encode(message, writer = _m079.Writer.create()) {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.portId !== "") {
      writer.uint32(18).string(message.portId);
    }
    if (message.channelId !== "") {
      writer.uint32(26).string(message.channelId);
    }
    if (message.isMiddlewareEnabled === true) {
      writer.uint32(32).bool(message.isMiddlewareEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m079.Reader ? input : new _m079.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActiveChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.connectionId = reader.string();
          break;
        case 2:
          message.portId = reader.string();
          break;
        case 3:
          message.channelId = reader.string();
          break;
        case 4:
          message.isMiddlewareEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
      portId: isSet(object.portId) ? String(object.portId) : "",
      channelId: isSet(object.channelId) ? String(object.channelId) : "",
      isMiddlewareEnabled: isSet(object.isMiddlewareEnabled) ? Boolean(object.isMiddlewareEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
    message.portId !== void 0 && (obj.portId = message.portId);
    message.channelId !== void 0 && (obj.channelId = message.channelId);
    message.isMiddlewareEnabled !== void 0 && (obj.isMiddlewareEnabled = message.isMiddlewareEnabled);
    return obj;
  },
  fromPartial(object) {
    var _object$connectionId, _object$portId, _object$channelId, _object$isMiddlewareE;
    const message = createBaseActiveChannel();
    message.connectionId = (_object$connectionId = object.connectionId) !== null && _object$connectionId !== void 0 ? _object$connectionId : "";
    message.portId = (_object$portId = object.portId) !== null && _object$portId !== void 0 ? _object$portId : "";
    message.channelId = (_object$channelId = object.channelId) !== null && _object$channelId !== void 0 ? _object$channelId : "";
    message.isMiddlewareEnabled = (_object$isMiddlewareE = object.isMiddlewareEnabled) !== null && _object$isMiddlewareE !== void 0 ? _object$isMiddlewareE : false;
    return message;
  }
};
function createBaseRegisteredInterchainAccount() {
  return {
    connectionId: "",
    portId: "",
    accountAddress: ""
  };
}
var RegisteredInterchainAccount = {
  encode(message, writer = _m079.Writer.create()) {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.portId !== "") {
      writer.uint32(18).string(message.portId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(26).string(message.accountAddress);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m079.Reader ? input : new _m079.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRegisteredInterchainAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.connectionId = reader.string();
          break;
        case 2:
          message.portId = reader.string();
          break;
        case 3:
          message.accountAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
      portId: isSet(object.portId) ? String(object.portId) : "",
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
    message.portId !== void 0 && (obj.portId = message.portId);
    message.accountAddress !== void 0 && (obj.accountAddress = message.accountAddress);
    return obj;
  },
  fromPartial(object) {
    var _object$connectionId2, _object$portId2, _object$accountAddres;
    const message = createBaseRegisteredInterchainAccount();
    message.connectionId = (_object$connectionId2 = object.connectionId) !== null && _object$connectionId2 !== void 0 ? _object$connectionId2 : "";
    message.portId = (_object$portId2 = object.portId) !== null && _object$portId2 !== void 0 ? _object$portId2 : "";
    message.accountAddress = (_object$accountAddres = object.accountAddress) !== null && _object$accountAddres !== void 0 ? _object$accountAddres : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/interchain_accounts/v1/account.js
var account_exports = {};
__export(account_exports, {
  InterchainAccount: () => InterchainAccount
});
var _m080 = __toESM(require_minimal());
function createBaseInterchainAccount() {
  return {
    baseAccount: void 0,
    accountOwner: ""
  };
}
var InterchainAccount = {
  encode(message, writer = _m080.Writer.create()) {
    if (message.baseAccount !== void 0) {
      BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
    }
    if (message.accountOwner !== "") {
      writer.uint32(18).string(message.accountOwner);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m080.Reader ? input : new _m080.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInterchainAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAccount = BaseAccount.decode(reader, reader.uint32());
          break;
        case 2:
          message.accountOwner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      baseAccount: isSet(object.baseAccount) ? BaseAccount.fromJSON(object.baseAccount) : void 0,
      accountOwner: isSet(object.accountOwner) ? String(object.accountOwner) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? BaseAccount.toJSON(message.baseAccount) : void 0);
    message.accountOwner !== void 0 && (obj.accountOwner = message.accountOwner);
    return obj;
  },
  fromPartial(object) {
    var _object$accountOwner;
    const message = createBaseInterchainAccount();
    message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? BaseAccount.fromPartial(object.baseAccount) : void 0;
    message.accountOwner = (_object$accountOwner = object.accountOwner) !== null && _object$accountOwner !== void 0 ? _object$accountOwner : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/interchain_accounts/v1/metadata.js
var metadata_exports2 = {};
__export(metadata_exports2, {
  Metadata: () => Metadata4
});
var _m081 = __toESM(require_minimal());
function createBaseMetadata3() {
  return {
    version: "",
    controllerConnectionId: "",
    hostConnectionId: "",
    address: "",
    encoding: "",
    txType: ""
  };
}
var Metadata4 = {
  encode(message, writer = _m081.Writer.create()) {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.controllerConnectionId !== "") {
      writer.uint32(18).string(message.controllerConnectionId);
    }
    if (message.hostConnectionId !== "") {
      writer.uint32(26).string(message.hostConnectionId);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.encoding !== "") {
      writer.uint32(42).string(message.encoding);
    }
    if (message.txType !== "") {
      writer.uint32(50).string(message.txType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m081.Reader ? input : new _m081.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMetadata3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.string();
          break;
        case 2:
          message.controllerConnectionId = reader.string();
          break;
        case 3:
          message.hostConnectionId = reader.string();
          break;
        case 4:
          message.address = reader.string();
          break;
        case 5:
          message.encoding = reader.string();
          break;
        case 6:
          message.txType = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet(object.version) ? String(object.version) : "",
      controllerConnectionId: isSet(object.controllerConnectionId) ? String(object.controllerConnectionId) : "",
      hostConnectionId: isSet(object.hostConnectionId) ? String(object.hostConnectionId) : "",
      address: isSet(object.address) ? String(object.address) : "",
      encoding: isSet(object.encoding) ? String(object.encoding) : "",
      txType: isSet(object.txType) ? String(object.txType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = message.version);
    message.controllerConnectionId !== void 0 && (obj.controllerConnectionId = message.controllerConnectionId);
    message.hostConnectionId !== void 0 && (obj.hostConnectionId = message.hostConnectionId);
    message.address !== void 0 && (obj.address = message.address);
    message.encoding !== void 0 && (obj.encoding = message.encoding);
    message.txType !== void 0 && (obj.txType = message.txType);
    return obj;
  },
  fromPartial(object) {
    var _object$version, _object$controllerCon, _object$hostConnectio, _object$address, _object$encoding, _object$txType;
    const message = createBaseMetadata3();
    message.version = (_object$version = object.version) !== null && _object$version !== void 0 ? _object$version : "";
    message.controllerConnectionId = (_object$controllerCon = object.controllerConnectionId) !== null && _object$controllerCon !== void 0 ? _object$controllerCon : "";
    message.hostConnectionId = (_object$hostConnectio = object.hostConnectionId) !== null && _object$hostConnectio !== void 0 ? _object$hostConnectio : "";
    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : "";
    message.encoding = (_object$encoding = object.encoding) !== null && _object$encoding !== void 0 ? _object$encoding : "";
    message.txType = (_object$txType = object.txType) !== null && _object$txType !== void 0 ? _object$txType : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/transfer/v1/authz.js
var authz_exports6 = {};
__export(authz_exports6, {
  Allocation: () => Allocation,
  TransferAuthorization: () => TransferAuthorization2
});
var _m082 = __toESM(require_minimal());
function createBaseAllocation() {
  return {
    sourcePort: "",
    sourceChannel: "",
    spendLimit: [],
    allowList: []
  };
}
var Allocation = {
  encode(message, writer = _m082.Writer.create()) {
    if (message.sourcePort !== "") {
      writer.uint32(10).string(message.sourcePort);
    }
    if (message.sourceChannel !== "") {
      writer.uint32(18).string(message.sourceChannel);
    }
    for (const v of message.spendLimit) {
      Coin.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.allowList) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m082.Reader ? input : new _m082.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sourcePort = reader.string();
          break;
        case 2:
          message.sourceChannel = reader.string();
          break;
        case 3:
          message.spendLimit.push(Coin.decode(reader, reader.uint32()));
          break;
        case 4:
          message.allowList.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sourcePort: isSet(object.sourcePort) ? String(object.sourcePort) : "",
      sourceChannel: isSet(object.sourceChannel) ? String(object.sourceChannel) : "",
      spendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.spendLimit) ? object.spendLimit.map((e) => Coin.fromJSON(e)) : [],
      allowList: Array.isArray(object === null || object === void 0 ? void 0 : object.allowList) ? object.allowList.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
    message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
    if (message.spendLimit) {
      obj.spendLimit = message.spendLimit.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.spendLimit = [];
    }
    if (message.allowList) {
      obj.allowList = message.allowList.map((e) => e);
    } else {
      obj.allowList = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$sourcePort, _object$sourceChannel, _object$spendLimit, _object$allowList;
    const message = createBaseAllocation();
    message.sourcePort = (_object$sourcePort = object.sourcePort) !== null && _object$sourcePort !== void 0 ? _object$sourcePort : "";
    message.sourceChannel = (_object$sourceChannel = object.sourceChannel) !== null && _object$sourceChannel !== void 0 ? _object$sourceChannel : "";
    message.spendLimit = ((_object$spendLimit = object.spendLimit) === null || _object$spendLimit === void 0 ? void 0 : _object$spendLimit.map((e) => Coin.fromPartial(e))) || [];
    message.allowList = ((_object$allowList = object.allowList) === null || _object$allowList === void 0 ? void 0 : _object$allowList.map((e) => e)) || [];
    return message;
  }
};
function createBaseTransferAuthorization2() {
  return {
    allocations: []
  };
}
var TransferAuthorization2 = {
  encode(message, writer = _m082.Writer.create()) {
    for (const v of message.allocations) {
      Allocation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m082.Reader ? input : new _m082.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransferAuthorization2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allocations.push(Allocation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allocations: Array.isArray(object === null || object === void 0 ? void 0 : object.allocations) ? object.allocations.map((e) => Allocation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allocations) {
      obj.allocations = message.allocations.map((e) => e ? Allocation.toJSON(e) : void 0);
    } else {
      obj.allocations = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$allocations;
    const message = createBaseTransferAuthorization2();
    message.allocations = ((_object$allocations = object.allocations) === null || _object$allocations === void 0 ? void 0 : _object$allocations.map((e) => Allocation.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/transfer/v1/genesis.js
var genesis_exports23 = {};
__export(genesis_exports23, {
  GenesisState: () => GenesisState22
});
var _m083 = __toESM(require_minimal());
function createBaseGenesisState22() {
  return {
    portId: "",
    denomTraces: [],
    params: void 0
  };
}
var GenesisState22 = {
  encode(message, writer = _m083.Writer.create()) {
    if (message.portId !== "") {
      writer.uint32(10).string(message.portId);
    }
    for (const v of message.denomTraces) {
      DenomTrace.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.params !== void 0) {
      Params14.encode(message.params, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m083.Reader ? input : new _m083.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState22();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.portId = reader.string();
          break;
        case 2:
          message.denomTraces.push(DenomTrace.decode(reader, reader.uint32()));
          break;
        case 3:
          message.params = Params14.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      portId: isSet(object.portId) ? String(object.portId) : "",
      denomTraces: Array.isArray(object === null || object === void 0 ? void 0 : object.denomTraces) ? object.denomTraces.map((e) => DenomTrace.fromJSON(e)) : [],
      params: isSet(object.params) ? Params14.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.portId !== void 0 && (obj.portId = message.portId);
    if (message.denomTraces) {
      obj.denomTraces = message.denomTraces.map((e) => e ? DenomTrace.toJSON(e) : void 0);
    } else {
      obj.denomTraces = [];
    }
    message.params !== void 0 && (obj.params = message.params ? Params14.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$portId, _object$denomTraces;
    const message = createBaseGenesisState22();
    message.portId = (_object$portId = object.portId) !== null && _object$portId !== void 0 ? _object$portId : "";
    message.denomTraces = ((_object$denomTraces = object.denomTraces) === null || _object$denomTraces === void 0 ? void 0 : _object$denomTraces.map((e) => DenomTrace.fromPartial(e))) || [];
    message.params = object.params !== void 0 && object.params !== null ? Params14.fromPartial(object.params) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/transfer/v2/packet.js
var packet_exports2 = {};
__export(packet_exports2, {
  FungibleTokenPacketData: () => FungibleTokenPacketData
});
var _m084 = __toESM(require_minimal());
function createBaseFungibleTokenPacketData() {
  return {
    denom: "",
    amount: "",
    sender: "",
    receiver: "",
    memo: ""
  };
}
var FungibleTokenPacketData = {
  encode(message, writer = _m084.Writer.create()) {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    if (message.receiver !== "") {
      writer.uint32(34).string(message.receiver);
    }
    if (message.memo !== "") {
      writer.uint32(42).string(message.memo);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m084.Reader ? input : new _m084.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenPacketData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        case 3:
          message.sender = reader.string();
          break;
        case 4:
          message.receiver = reader.string();
          break;
        case 5:
          message.memo = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
      sender: isSet(object.sender) ? String(object.sender) : "",
      receiver: isSet(object.receiver) ? String(object.receiver) : "",
      memo: isSet(object.memo) ? String(object.memo) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    message.amount !== void 0 && (obj.amount = message.amount);
    message.sender !== void 0 && (obj.sender = message.sender);
    message.receiver !== void 0 && (obj.receiver = message.receiver);
    message.memo !== void 0 && (obj.memo = message.memo);
    return obj;
  },
  fromPartial(object) {
    var _object$denom, _object$amount, _object$sender, _object$receiver, _object$memo;
    const message = createBaseFungibleTokenPacketData();
    message.denom = (_object$denom = object.denom) !== null && _object$denom !== void 0 ? _object$denom : "";
    message.amount = (_object$amount = object.amount) !== null && _object$amount !== void 0 ? _object$amount : "";
    message.sender = (_object$sender = object.sender) !== null && _object$sender !== void 0 ? _object$sender : "";
    message.receiver = (_object$receiver = object.receiver) !== null && _object$receiver !== void 0 ? _object$receiver : "";
    message.memo = (_object$memo = object.memo) !== null && _object$memo !== void 0 ? _object$memo : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/channel/v1/genesis.js
var genesis_exports24 = {};
__export(genesis_exports24, {
  GenesisState: () => GenesisState23,
  PacketSequence: () => PacketSequence
});
var _m085 = __toESM(require_minimal());
function createBaseGenesisState23() {
  return {
    channels: [],
    acknowledgements: [],
    commitments: [],
    receipts: [],
    sendSequences: [],
    recvSequences: [],
    ackSequences: [],
    nextChannelSequence: BigInt("0")
  };
}
var GenesisState23 = {
  encode(message, writer = _m085.Writer.create()) {
    for (const v of message.channels) {
      IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.acknowledgements) {
      PacketState.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.commitments) {
      PacketState.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.receipts) {
      PacketState.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.sendSequences) {
      PacketSequence.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.recvSequences) {
      PacketSequence.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.ackSequences) {
      PacketSequence.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.nextChannelSequence !== BigInt(0)) {
      writer.uint32(64).uint64(import_long.default.fromString(message.nextChannelSequence.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m085.Reader ? input : new _m085.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState23();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channels.push(IdentifiedChannel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.acknowledgements.push(PacketState.decode(reader, reader.uint32()));
          break;
        case 3:
          message.commitments.push(PacketState.decode(reader, reader.uint32()));
          break;
        case 4:
          message.receipts.push(PacketState.decode(reader, reader.uint32()));
          break;
        case 5:
          message.sendSequences.push(PacketSequence.decode(reader, reader.uint32()));
          break;
        case 6:
          message.recvSequences.push(PacketSequence.decode(reader, reader.uint32()));
          break;
        case 7:
          message.ackSequences.push(PacketSequence.decode(reader, reader.uint32()));
          break;
        case 8:
          message.nextChannelSequence = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      channels: Array.isArray(object === null || object === void 0 ? void 0 : object.channels) ? object.channels.map((e) => IdentifiedChannel.fromJSON(e)) : [],
      acknowledgements: Array.isArray(object === null || object === void 0 ? void 0 : object.acknowledgements) ? object.acknowledgements.map((e) => PacketState.fromJSON(e)) : [],
      commitments: Array.isArray(object === null || object === void 0 ? void 0 : object.commitments) ? object.commitments.map((e) => PacketState.fromJSON(e)) : [],
      receipts: Array.isArray(object === null || object === void 0 ? void 0 : object.receipts) ? object.receipts.map((e) => PacketState.fromJSON(e)) : [],
      sendSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.sendSequences) ? object.sendSequences.map((e) => PacketSequence.fromJSON(e)) : [],
      recvSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.recvSequences) ? object.recvSequences.map((e) => PacketSequence.fromJSON(e)) : [],
      ackSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.ackSequences) ? object.ackSequences.map((e) => PacketSequence.fromJSON(e)) : [],
      nextChannelSequence: isSet(object.nextChannelSequence) ? BigInt(object.nextChannelSequence.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.channels) {
      obj.channels = message.channels.map((e) => e ? IdentifiedChannel.toJSON(e) : void 0);
    } else {
      obj.channels = [];
    }
    if (message.acknowledgements) {
      obj.acknowledgements = message.acknowledgements.map((e) => e ? PacketState.toJSON(e) : void 0);
    } else {
      obj.acknowledgements = [];
    }
    if (message.commitments) {
      obj.commitments = message.commitments.map((e) => e ? PacketState.toJSON(e) : void 0);
    } else {
      obj.commitments = [];
    }
    if (message.receipts) {
      obj.receipts = message.receipts.map((e) => e ? PacketState.toJSON(e) : void 0);
    } else {
      obj.receipts = [];
    }
    if (message.sendSequences) {
      obj.sendSequences = message.sendSequences.map((e) => e ? PacketSequence.toJSON(e) : void 0);
    } else {
      obj.sendSequences = [];
    }
    if (message.recvSequences) {
      obj.recvSequences = message.recvSequences.map((e) => e ? PacketSequence.toJSON(e) : void 0);
    } else {
      obj.recvSequences = [];
    }
    if (message.ackSequences) {
      obj.ackSequences = message.ackSequences.map((e) => e ? PacketSequence.toJSON(e) : void 0);
    } else {
      obj.ackSequences = [];
    }
    message.nextChannelSequence !== void 0 && (obj.nextChannelSequence = (message.nextChannelSequence || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$channels, _object$acknowledgeme, _object$commitments, _object$receipts, _object$sendSequences, _object$recvSequences, _object$ackSequences;
    const message = createBaseGenesisState23();
    message.channels = ((_object$channels = object.channels) === null || _object$channels === void 0 ? void 0 : _object$channels.map((e) => IdentifiedChannel.fromPartial(e))) || [];
    message.acknowledgements = ((_object$acknowledgeme = object.acknowledgements) === null || _object$acknowledgeme === void 0 ? void 0 : _object$acknowledgeme.map((e) => PacketState.fromPartial(e))) || [];
    message.commitments = ((_object$commitments = object.commitments) === null || _object$commitments === void 0 ? void 0 : _object$commitments.map((e) => PacketState.fromPartial(e))) || [];
    message.receipts = ((_object$receipts = object.receipts) === null || _object$receipts === void 0 ? void 0 : _object$receipts.map((e) => PacketState.fromPartial(e))) || [];
    message.sendSequences = ((_object$sendSequences = object.sendSequences) === null || _object$sendSequences === void 0 ? void 0 : _object$sendSequences.map((e) => PacketSequence.fromPartial(e))) || [];
    message.recvSequences = ((_object$recvSequences = object.recvSequences) === null || _object$recvSequences === void 0 ? void 0 : _object$recvSequences.map((e) => PacketSequence.fromPartial(e))) || [];
    message.ackSequences = ((_object$ackSequences = object.ackSequences) === null || _object$ackSequences === void 0 ? void 0 : _object$ackSequences.map((e) => PacketSequence.fromPartial(e))) || [];
    message.nextChannelSequence = object.nextChannelSequence !== void 0 && object.nextChannelSequence !== null ? BigInt(object.nextChannelSequence.toString()) : BigInt("0");
    return message;
  }
};
function createBasePacketSequence() {
  return {
    portId: "",
    channelId: "",
    sequence: BigInt("0")
  };
}
var PacketSequence = {
  encode(message, writer = _m085.Writer.create()) {
    if (message.portId !== "") {
      writer.uint32(10).string(message.portId);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.sequence !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m085.Reader ? input : new _m085.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePacketSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.portId = reader.string();
          break;
        case 2:
          message.channelId = reader.string();
          break;
        case 3:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      portId: isSet(object.portId) ? String(object.portId) : "",
      channelId: isSet(object.channelId) ? String(object.channelId) : "",
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.portId !== void 0 && (obj.portId = message.portId);
    message.channelId !== void 0 && (obj.channelId = message.channelId);
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$portId, _object$channelId;
    const message = createBasePacketSequence();
    message.portId = (_object$portId = object.portId) !== null && _object$portId !== void 0 ? _object$portId : "";
    message.channelId = (_object$channelId = object.channelId) !== null && _object$channelId !== void 0 ? _object$channelId : "";
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/client/v1/genesis.js
var genesis_exports25 = {};
__export(genesis_exports25, {
  GenesisMetadata: () => GenesisMetadata,
  GenesisState: () => GenesisState24,
  IdentifiedGenesisMetadata: () => IdentifiedGenesisMetadata
});
var _m086 = __toESM(require_minimal());
function createBaseGenesisState24() {
  return {
    clients: [],
    clientsConsensus: [],
    clientsMetadata: [],
    params: void 0,
    createLocalhost: false,
    nextClientSequence: BigInt("0")
  };
}
var GenesisState24 = {
  encode(message, writer = _m086.Writer.create()) {
    for (const v of message.clients) {
      IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.clientsConsensus) {
      ClientConsensusStates.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.clientsMetadata) {
      IdentifiedGenesisMetadata.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.params !== void 0) {
      Params11.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    if (message.createLocalhost === true) {
      writer.uint32(40).bool(message.createLocalhost);
    }
    if (message.nextClientSequence !== BigInt(0)) {
      writer.uint32(48).uint64(import_long.default.fromString(message.nextClientSequence.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m086.Reader ? input : new _m086.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState24();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clients.push(IdentifiedClientState.decode(reader, reader.uint32()));
          break;
        case 2:
          message.clientsConsensus.push(ClientConsensusStates.decode(reader, reader.uint32()));
          break;
        case 3:
          message.clientsMetadata.push(IdentifiedGenesisMetadata.decode(reader, reader.uint32()));
          break;
        case 4:
          message.params = Params11.decode(reader, reader.uint32());
          break;
        case 5:
          message.createLocalhost = reader.bool();
          break;
        case 6:
          message.nextClientSequence = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      clients: Array.isArray(object === null || object === void 0 ? void 0 : object.clients) ? object.clients.map((e) => IdentifiedClientState.fromJSON(e)) : [],
      clientsConsensus: Array.isArray(object === null || object === void 0 ? void 0 : object.clientsConsensus) ? object.clientsConsensus.map((e) => ClientConsensusStates.fromJSON(e)) : [],
      clientsMetadata: Array.isArray(object === null || object === void 0 ? void 0 : object.clientsMetadata) ? object.clientsMetadata.map((e) => IdentifiedGenesisMetadata.fromJSON(e)) : [],
      params: isSet(object.params) ? Params11.fromJSON(object.params) : void 0,
      createLocalhost: isSet(object.createLocalhost) ? Boolean(object.createLocalhost) : false,
      nextClientSequence: isSet(object.nextClientSequence) ? BigInt(object.nextClientSequence.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clients) {
      obj.clients = message.clients.map((e) => e ? IdentifiedClientState.toJSON(e) : void 0);
    } else {
      obj.clients = [];
    }
    if (message.clientsConsensus) {
      obj.clientsConsensus = message.clientsConsensus.map((e) => e ? ClientConsensusStates.toJSON(e) : void 0);
    } else {
      obj.clientsConsensus = [];
    }
    if (message.clientsMetadata) {
      obj.clientsMetadata = message.clientsMetadata.map((e) => e ? IdentifiedGenesisMetadata.toJSON(e) : void 0);
    } else {
      obj.clientsMetadata = [];
    }
    message.params !== void 0 && (obj.params = message.params ? Params11.toJSON(message.params) : void 0);
    message.createLocalhost !== void 0 && (obj.createLocalhost = message.createLocalhost);
    message.nextClientSequence !== void 0 && (obj.nextClientSequence = (message.nextClientSequence || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$clients, _object$clientsConsen, _object$clientsMetada, _object$createLocalho;
    const message = createBaseGenesisState24();
    message.clients = ((_object$clients = object.clients) === null || _object$clients === void 0 ? void 0 : _object$clients.map((e) => IdentifiedClientState.fromPartial(e))) || [];
    message.clientsConsensus = ((_object$clientsConsen = object.clientsConsensus) === null || _object$clientsConsen === void 0 ? void 0 : _object$clientsConsen.map((e) => ClientConsensusStates.fromPartial(e))) || [];
    message.clientsMetadata = ((_object$clientsMetada = object.clientsMetadata) === null || _object$clientsMetada === void 0 ? void 0 : _object$clientsMetada.map((e) => IdentifiedGenesisMetadata.fromPartial(e))) || [];
    message.params = object.params !== void 0 && object.params !== null ? Params11.fromPartial(object.params) : void 0;
    message.createLocalhost = (_object$createLocalho = object.createLocalhost) !== null && _object$createLocalho !== void 0 ? _object$createLocalho : false;
    message.nextClientSequence = object.nextClientSequence !== void 0 && object.nextClientSequence !== null ? BigInt(object.nextClientSequence.toString()) : BigInt("0");
    return message;
  }
};
function createBaseGenesisMetadata() {
  return {
    key: new Uint8Array(),
    value: new Uint8Array()
  };
}
var GenesisMetadata = {
  encode(message, writer = _m086.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m086.Reader ? input : new _m086.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$key, _object$value;
    const message = createBaseGenesisMetadata();
    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();
    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();
    return message;
  }
};
function createBaseIdentifiedGenesisMetadata() {
  return {
    clientId: "",
    clientMetadata: []
  };
}
var IdentifiedGenesisMetadata = {
  encode(message, writer = _m086.Writer.create()) {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    for (const v of message.clientMetadata) {
      GenesisMetadata.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m086.Reader ? input : new _m086.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIdentifiedGenesisMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clientId = reader.string();
          break;
        case 2:
          message.clientMetadata.push(GenesisMetadata.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      clientId: isSet(object.clientId) ? String(object.clientId) : "",
      clientMetadata: Array.isArray(object === null || object === void 0 ? void 0 : object.clientMetadata) ? object.clientMetadata.map((e) => GenesisMetadata.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.clientId !== void 0 && (obj.clientId = message.clientId);
    if (message.clientMetadata) {
      obj.clientMetadata = message.clientMetadata.map((e) => e ? GenesisMetadata.toJSON(e) : void 0);
    } else {
      obj.clientMetadata = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$clientId, _object$clientMetadat;
    const message = createBaseIdentifiedGenesisMetadata();
    message.clientId = (_object$clientId = object.clientId) !== null && _object$clientId !== void 0 ? _object$clientId : "";
    message.clientMetadata = ((_object$clientMetadat = object.clientMetadata) === null || _object$clientMetadat === void 0 ? void 0 : _object$clientMetadat.map((e) => GenesisMetadata.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/connection/v1/genesis.js
var genesis_exports26 = {};
__export(genesis_exports26, {
  GenesisState: () => GenesisState25
});
var _m087 = __toESM(require_minimal());
function createBaseGenesisState25() {
  return {
    connections: [],
    clientConnectionPaths: [],
    nextConnectionSequence: BigInt("0"),
    params: void 0
  };
}
var GenesisState25 = {
  encode(message, writer = _m087.Writer.create()) {
    for (const v of message.connections) {
      IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.clientConnectionPaths) {
      ConnectionPaths.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.nextConnectionSequence !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.nextConnectionSequence.toString()));
    }
    if (message.params !== void 0) {
      Params15.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m087.Reader ? input : new _m087.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState25();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.connections.push(IdentifiedConnection.decode(reader, reader.uint32()));
          break;
        case 2:
          message.clientConnectionPaths.push(ConnectionPaths.decode(reader, reader.uint32()));
          break;
        case 3:
          message.nextConnectionSequence = BigInt(reader.uint64().toString());
          break;
        case 4:
          message.params = Params15.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      connections: Array.isArray(object === null || object === void 0 ? void 0 : object.connections) ? object.connections.map((e) => IdentifiedConnection.fromJSON(e)) : [],
      clientConnectionPaths: Array.isArray(object === null || object === void 0 ? void 0 : object.clientConnectionPaths) ? object.clientConnectionPaths.map((e) => ConnectionPaths.fromJSON(e)) : [],
      nextConnectionSequence: isSet(object.nextConnectionSequence) ? BigInt(object.nextConnectionSequence.toString()) : BigInt("0"),
      params: isSet(object.params) ? Params15.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.connections) {
      obj.connections = message.connections.map((e) => e ? IdentifiedConnection.toJSON(e) : void 0);
    } else {
      obj.connections = [];
    }
    if (message.clientConnectionPaths) {
      obj.clientConnectionPaths = message.clientConnectionPaths.map((e) => e ? ConnectionPaths.toJSON(e) : void 0);
    } else {
      obj.clientConnectionPaths = [];
    }
    message.nextConnectionSequence !== void 0 && (obj.nextConnectionSequence = (message.nextConnectionSequence || BigInt("0")).toString());
    message.params !== void 0 && (obj.params = message.params ? Params15.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$connections, _object$clientConnect;
    const message = createBaseGenesisState25();
    message.connections = ((_object$connections = object.connections) === null || _object$connections === void 0 ? void 0 : _object$connections.map((e) => IdentifiedConnection.fromPartial(e))) || [];
    message.clientConnectionPaths = ((_object$clientConnect = object.clientConnectionPaths) === null || _object$clientConnect === void 0 ? void 0 : _object$clientConnect.map((e) => ConnectionPaths.fromPartial(e))) || [];
    message.nextConnectionSequence = object.nextConnectionSequence !== void 0 && object.nextConnectionSequence !== null ? BigInt(object.nextConnectionSequence.toString()) : BigInt("0");
    message.params = object.params !== void 0 && object.params !== null ? Params15.fromPartial(object.params) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/types/v1/genesis.js
var genesis_exports27 = {};
__export(genesis_exports27, {
  GenesisState: () => GenesisState26
});
var _m088 = __toESM(require_minimal());
function createBaseGenesisState26() {
  return {
    clientGenesis: void 0,
    connectionGenesis: void 0,
    channelGenesis: void 0
  };
}
var GenesisState26 = {
  encode(message, writer = _m088.Writer.create()) {
    if (message.clientGenesis !== void 0) {
      GenesisState24.encode(message.clientGenesis, writer.uint32(10).fork()).ldelim();
    }
    if (message.connectionGenesis !== void 0) {
      GenesisState25.encode(message.connectionGenesis, writer.uint32(18).fork()).ldelim();
    }
    if (message.channelGenesis !== void 0) {
      GenesisState23.encode(message.channelGenesis, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m088.Reader ? input : new _m088.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenesisState26();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clientGenesis = GenesisState24.decode(reader, reader.uint32());
          break;
        case 2:
          message.connectionGenesis = GenesisState25.decode(reader, reader.uint32());
          break;
        case 3:
          message.channelGenesis = GenesisState23.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      clientGenesis: isSet(object.clientGenesis) ? GenesisState24.fromJSON(object.clientGenesis) : void 0,
      connectionGenesis: isSet(object.connectionGenesis) ? GenesisState25.fromJSON(object.connectionGenesis) : void 0,
      channelGenesis: isSet(object.channelGenesis) ? GenesisState23.fromJSON(object.channelGenesis) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.clientGenesis !== void 0 && (obj.clientGenesis = message.clientGenesis ? GenesisState24.toJSON(message.clientGenesis) : void 0);
    message.connectionGenesis !== void 0 && (obj.connectionGenesis = message.connectionGenesis ? GenesisState25.toJSON(message.connectionGenesis) : void 0);
    message.channelGenesis !== void 0 && (obj.channelGenesis = message.channelGenesis ? GenesisState23.toJSON(message.channelGenesis) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenesisState26();
    message.clientGenesis = object.clientGenesis !== void 0 && object.clientGenesis !== null ? GenesisState24.fromPartial(object.clientGenesis) : void 0;
    message.connectionGenesis = object.connectionGenesis !== void 0 && object.connectionGenesis !== null ? GenesisState25.fromPartial(object.connectionGenesis) : void 0;
    message.channelGenesis = object.channelGenesis !== void 0 && object.channelGenesis !== null ? GenesisState23.fromPartial(object.channelGenesis) : void 0;
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/lightclients/solomachine/v2/solomachine.js
var solomachine_exports = {};
__export(solomachine_exports, {
  ChannelStateData: () => ChannelStateData,
  ClientState: () => ClientState,
  ClientStateData: () => ClientStateData,
  ConnectionStateData: () => ConnectionStateData,
  ConsensusState: () => ConsensusState,
  ConsensusStateData: () => ConsensusStateData,
  DataType: () => DataType,
  DataTypeSDKType: () => DataTypeSDKType,
  Header: () => Header,
  HeaderData: () => HeaderData,
  Misbehaviour: () => Misbehaviour,
  NextSequenceRecvData: () => NextSequenceRecvData,
  PacketAcknowledgementData: () => PacketAcknowledgementData,
  PacketCommitmentData: () => PacketCommitmentData,
  PacketReceiptAbsenceData: () => PacketReceiptAbsenceData,
  SignBytes: () => SignBytes,
  SignatureAndData: () => SignatureAndData,
  TimestampedSignatureData: () => TimestampedSignatureData,
  dataTypeFromJSON: () => dataTypeFromJSON,
  dataTypeToJSON: () => dataTypeToJSON
});
var _m089 = __toESM(require_minimal());
var DataType = function(DataType2) {
  DataType2[DataType2["DATA_TYPE_UNINITIALIZED_UNSPECIFIED"] = 0] = "DATA_TYPE_UNINITIALIZED_UNSPECIFIED";
  DataType2[DataType2["DATA_TYPE_CLIENT_STATE"] = 1] = "DATA_TYPE_CLIENT_STATE";
  DataType2[DataType2["DATA_TYPE_CONSENSUS_STATE"] = 2] = "DATA_TYPE_CONSENSUS_STATE";
  DataType2[DataType2["DATA_TYPE_CONNECTION_STATE"] = 3] = "DATA_TYPE_CONNECTION_STATE";
  DataType2[DataType2["DATA_TYPE_CHANNEL_STATE"] = 4] = "DATA_TYPE_CHANNEL_STATE";
  DataType2[DataType2["DATA_TYPE_PACKET_COMMITMENT"] = 5] = "DATA_TYPE_PACKET_COMMITMENT";
  DataType2[DataType2["DATA_TYPE_PACKET_ACKNOWLEDGEMENT"] = 6] = "DATA_TYPE_PACKET_ACKNOWLEDGEMENT";
  DataType2[DataType2["DATA_TYPE_PACKET_RECEIPT_ABSENCE"] = 7] = "DATA_TYPE_PACKET_RECEIPT_ABSENCE";
  DataType2[DataType2["DATA_TYPE_NEXT_SEQUENCE_RECV"] = 8] = "DATA_TYPE_NEXT_SEQUENCE_RECV";
  DataType2[DataType2["DATA_TYPE_HEADER"] = 9] = "DATA_TYPE_HEADER";
  DataType2[DataType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return DataType2;
}({});
var DataTypeSDKType = DataType;
function dataTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNINITIALIZED_UNSPECIFIED":
      return DataType.DATA_TYPE_UNINITIALIZED_UNSPECIFIED;
    case 1:
    case "DATA_TYPE_CLIENT_STATE":
      return DataType.DATA_TYPE_CLIENT_STATE;
    case 2:
    case "DATA_TYPE_CONSENSUS_STATE":
      return DataType.DATA_TYPE_CONSENSUS_STATE;
    case 3:
    case "DATA_TYPE_CONNECTION_STATE":
      return DataType.DATA_TYPE_CONNECTION_STATE;
    case 4:
    case "DATA_TYPE_CHANNEL_STATE":
      return DataType.DATA_TYPE_CHANNEL_STATE;
    case 5:
    case "DATA_TYPE_PACKET_COMMITMENT":
      return DataType.DATA_TYPE_PACKET_COMMITMENT;
    case 6:
    case "DATA_TYPE_PACKET_ACKNOWLEDGEMENT":
      return DataType.DATA_TYPE_PACKET_ACKNOWLEDGEMENT;
    case 7:
    case "DATA_TYPE_PACKET_RECEIPT_ABSENCE":
      return DataType.DATA_TYPE_PACKET_RECEIPT_ABSENCE;
    case 8:
    case "DATA_TYPE_NEXT_SEQUENCE_RECV":
      return DataType.DATA_TYPE_NEXT_SEQUENCE_RECV;
    case 9:
    case "DATA_TYPE_HEADER":
      return DataType.DATA_TYPE_HEADER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}
function dataTypeToJSON(object) {
  switch (object) {
    case DataType.DATA_TYPE_UNINITIALIZED_UNSPECIFIED:
      return "DATA_TYPE_UNINITIALIZED_UNSPECIFIED";
    case DataType.DATA_TYPE_CLIENT_STATE:
      return "DATA_TYPE_CLIENT_STATE";
    case DataType.DATA_TYPE_CONSENSUS_STATE:
      return "DATA_TYPE_CONSENSUS_STATE";
    case DataType.DATA_TYPE_CONNECTION_STATE:
      return "DATA_TYPE_CONNECTION_STATE";
    case DataType.DATA_TYPE_CHANNEL_STATE:
      return "DATA_TYPE_CHANNEL_STATE";
    case DataType.DATA_TYPE_PACKET_COMMITMENT:
      return "DATA_TYPE_PACKET_COMMITMENT";
    case DataType.DATA_TYPE_PACKET_ACKNOWLEDGEMENT:
      return "DATA_TYPE_PACKET_ACKNOWLEDGEMENT";
    case DataType.DATA_TYPE_PACKET_RECEIPT_ABSENCE:
      return "DATA_TYPE_PACKET_RECEIPT_ABSENCE";
    case DataType.DATA_TYPE_NEXT_SEQUENCE_RECV:
      return "DATA_TYPE_NEXT_SEQUENCE_RECV";
    case DataType.DATA_TYPE_HEADER:
      return "DATA_TYPE_HEADER";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseClientState() {
  return {
    sequence: BigInt("0"),
    isFrozen: false,
    consensusState: void 0,
    allowUpdateAfterProposal: false
  };
}
var ClientState = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.isFrozen === true) {
      writer.uint32(16).bool(message.isFrozen);
    }
    if (message.consensusState !== void 0) {
      ConsensusState.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
    }
    if (message.allowUpdateAfterProposal === true) {
      writer.uint32(32).bool(message.allowUpdateAfterProposal);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.isFrozen = reader.bool();
          break;
        case 3:
          message.consensusState = ConsensusState.decode(reader, reader.uint32());
          break;
        case 4:
          message.allowUpdateAfterProposal = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      isFrozen: isSet(object.isFrozen) ? Boolean(object.isFrozen) : false,
      consensusState: isSet(object.consensusState) ? ConsensusState.fromJSON(object.consensusState) : void 0,
      allowUpdateAfterProposal: isSet(object.allowUpdateAfterProposal) ? Boolean(object.allowUpdateAfterProposal) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.isFrozen !== void 0 && (obj.isFrozen = message.isFrozen);
    message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? ConsensusState.toJSON(message.consensusState) : void 0);
    message.allowUpdateAfterProposal !== void 0 && (obj.allowUpdateAfterProposal = message.allowUpdateAfterProposal);
    return obj;
  },
  fromPartial(object) {
    var _object$isFrozen, _object$allowUpdateAf;
    const message = createBaseClientState();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.isFrozen = (_object$isFrozen = object.isFrozen) !== null && _object$isFrozen !== void 0 ? _object$isFrozen : false;
    message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? ConsensusState.fromPartial(object.consensusState) : void 0;
    message.allowUpdateAfterProposal = (_object$allowUpdateAf = object.allowUpdateAfterProposal) !== null && _object$allowUpdateAf !== void 0 ? _object$allowUpdateAf : false;
    return message;
  }
};
function createBaseConsensusState() {
  return {
    publicKey: void 0,
    diversifier: "",
    timestamp: BigInt("0")
  };
}
var ConsensusState = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.publicKey !== void 0) {
      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.diversifier !== "") {
      writer.uint32(18).string(message.diversifier);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConsensusState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.publicKey = Any.decode(reader, reader.uint32());
          break;
        case 2:
          message.diversifier = reader.string();
          break;
        case 3:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      publicKey: isSet(object.publicKey) ? Any.fromJSON(object.publicKey) : void 0,
      diversifier: isSet(object.diversifier) ? String(object.diversifier) : "",
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? Any.toJSON(message.publicKey) : void 0);
    message.diversifier !== void 0 && (obj.diversifier = message.diversifier);
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$diversifier;
    const message = createBaseConsensusState();
    message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? Any.fromPartial(object.publicKey) : void 0;
    message.diversifier = (_object$diversifier = object.diversifier) !== null && _object$diversifier !== void 0 ? _object$diversifier : "";
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseHeader() {
  return {
    sequence: BigInt("0"),
    timestamp: BigInt("0"),
    signature: new Uint8Array(),
    newPublicKey: void 0,
    newDiversifier: ""
  };
}
var Header = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.newPublicKey !== void 0) {
      Any.encode(message.newPublicKey, writer.uint32(34).fork()).ldelim();
    }
    if (message.newDiversifier !== "") {
      writer.uint32(42).string(message.newDiversifier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.signature = reader.bytes();
          break;
        case 4:
          message.newPublicKey = Any.decode(reader, reader.uint32());
          break;
        case 5:
          message.newDiversifier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0"),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      newPublicKey: isSet(object.newPublicKey) ? Any.fromJSON(object.newPublicKey) : void 0,
      newDiversifier: isSet(object.newDiversifier) ? String(object.newDiversifier) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.newPublicKey !== void 0 && (obj.newPublicKey = message.newPublicKey ? Any.toJSON(message.newPublicKey) : void 0);
    message.newDiversifier !== void 0 && (obj.newDiversifier = message.newDiversifier);
    return obj;
  },
  fromPartial(object) {
    var _object$signature, _object$newDiversifie;
    const message = createBaseHeader();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    message.signature = (_object$signature = object.signature) !== null && _object$signature !== void 0 ? _object$signature : new Uint8Array();
    message.newPublicKey = object.newPublicKey !== void 0 && object.newPublicKey !== null ? Any.fromPartial(object.newPublicKey) : void 0;
    message.newDiversifier = (_object$newDiversifie = object.newDiversifier) !== null && _object$newDiversifie !== void 0 ? _object$newDiversifie : "";
    return message;
  }
};
function createBaseMisbehaviour() {
  return {
    clientId: "",
    sequence: BigInt("0"),
    signatureOne: void 0,
    signatureTwo: void 0
  };
}
var Misbehaviour = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.sequence !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.signatureOne !== void 0) {
      SignatureAndData.encode(message.signatureOne, writer.uint32(26).fork()).ldelim();
    }
    if (message.signatureTwo !== void 0) {
      SignatureAndData.encode(message.signatureTwo, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMisbehaviour();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clientId = reader.string();
          break;
        case 2:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.signatureOne = SignatureAndData.decode(reader, reader.uint32());
          break;
        case 4:
          message.signatureTwo = SignatureAndData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      clientId: isSet(object.clientId) ? String(object.clientId) : "",
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      signatureOne: isSet(object.signatureOne) ? SignatureAndData.fromJSON(object.signatureOne) : void 0,
      signatureTwo: isSet(object.signatureTwo) ? SignatureAndData.fromJSON(object.signatureTwo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.clientId !== void 0 && (obj.clientId = message.clientId);
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.signatureOne !== void 0 && (obj.signatureOne = message.signatureOne ? SignatureAndData.toJSON(message.signatureOne) : void 0);
    message.signatureTwo !== void 0 && (obj.signatureTwo = message.signatureTwo ? SignatureAndData.toJSON(message.signatureTwo) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$clientId;
    const message = createBaseMisbehaviour();
    message.clientId = (_object$clientId = object.clientId) !== null && _object$clientId !== void 0 ? _object$clientId : "";
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.signatureOne = object.signatureOne !== void 0 && object.signatureOne !== null ? SignatureAndData.fromPartial(object.signatureOne) : void 0;
    message.signatureTwo = object.signatureTwo !== void 0 && object.signatureTwo !== null ? SignatureAndData.fromPartial(object.signatureTwo) : void 0;
    return message;
  }
};
function createBaseSignatureAndData() {
  return {
    signature: new Uint8Array(),
    dataType: 0,
    data: new Uint8Array(),
    timestamp: BigInt("0")
  };
}
var SignatureAndData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignatureAndData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signature = reader.bytes();
          break;
        case 2:
          message.dataType = reader.int32();
          break;
        case 3:
          message.data = reader.bytes();
          break;
        case 4:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.dataType !== void 0 && (obj.dataType = dataTypeToJSON(message.dataType));
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$signature2, _object$dataType, _object$data;
    const message = createBaseSignatureAndData();
    message.signature = (_object$signature2 = object.signature) !== null && _object$signature2 !== void 0 ? _object$signature2 : new Uint8Array();
    message.dataType = (_object$dataType = object.dataType) !== null && _object$dataType !== void 0 ? _object$dataType : 0;
    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseTimestampedSignatureData() {
  return {
    signatureData: new Uint8Array(),
    timestamp: BigInt("0")
  };
}
var TimestampedSignatureData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.signatureData.length !== 0) {
      writer.uint32(10).bytes(message.signatureData);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestampedSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signatureData = reader.bytes();
          break;
        case 2:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signatureData: isSet(object.signatureData) ? bytesFromBase64(object.signatureData) : new Uint8Array(),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.signatureData !== void 0 && (obj.signatureData = base64FromBytes(message.signatureData !== void 0 ? message.signatureData : new Uint8Array()));
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$signatureData;
    const message = createBaseTimestampedSignatureData();
    message.signatureData = (_object$signatureData = object.signatureData) !== null && _object$signatureData !== void 0 ? _object$signatureData : new Uint8Array();
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseSignBytes() {
  return {
    sequence: BigInt("0"),
    timestamp: BigInt("0"),
    diversifier: "",
    dataType: 0,
    data: new Uint8Array()
  };
}
var SignBytes = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    if (message.diversifier !== "") {
      writer.uint32(26).string(message.diversifier);
    }
    if (message.dataType !== 0) {
      writer.uint32(32).int32(message.dataType);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.diversifier = reader.string();
          break;
        case 4:
          message.dataType = reader.int32();
          break;
        case 5:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0"),
      diversifier: isSet(object.diversifier) ? String(object.diversifier) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    message.diversifier !== void 0 && (obj.diversifier = message.diversifier);
    message.dataType !== void 0 && (obj.dataType = dataTypeToJSON(message.dataType));
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$diversifier2, _object$dataType2, _object$data2;
    const message = createBaseSignBytes();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    message.diversifier = (_object$diversifier2 = object.diversifier) !== null && _object$diversifier2 !== void 0 ? _object$diversifier2 : "";
    message.dataType = (_object$dataType2 = object.dataType) !== null && _object$dataType2 !== void 0 ? _object$dataType2 : 0;
    message.data = (_object$data2 = object.data) !== null && _object$data2 !== void 0 ? _object$data2 : new Uint8Array();
    return message;
  }
};
function createBaseHeaderData() {
  return {
    newPubKey: void 0,
    newDiversifier: ""
  };
}
var HeaderData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.newPubKey !== void 0) {
      Any.encode(message.newPubKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.newDiversifier !== "") {
      writer.uint32(18).string(message.newDiversifier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeaderData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.newPubKey = Any.decode(reader, reader.uint32());
          break;
        case 2:
          message.newDiversifier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      newPubKey: isSet(object.newPubKey) ? Any.fromJSON(object.newPubKey) : void 0,
      newDiversifier: isSet(object.newDiversifier) ? String(object.newDiversifier) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.newPubKey !== void 0 && (obj.newPubKey = message.newPubKey ? Any.toJSON(message.newPubKey) : void 0);
    message.newDiversifier !== void 0 && (obj.newDiversifier = message.newDiversifier);
    return obj;
  },
  fromPartial(object) {
    var _object$newDiversifie2;
    const message = createBaseHeaderData();
    message.newPubKey = object.newPubKey !== void 0 && object.newPubKey !== null ? Any.fromPartial(object.newPubKey) : void 0;
    message.newDiversifier = (_object$newDiversifie2 = object.newDiversifier) !== null && _object$newDiversifie2 !== void 0 ? _object$newDiversifie2 : "";
    return message;
  }
};
function createBaseClientStateData() {
  return {
    path: new Uint8Array(),
    clientState: void 0
  };
}
var ClientStateData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.clientState !== void 0) {
      Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientStateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.clientState = Any.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      clientState: isSet(object.clientState) ? Any.fromJSON(object.clientState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.clientState !== void 0 && (obj.clientState = message.clientState ? Any.toJSON(message.clientState) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$path;
    const message = createBaseClientStateData();
    message.path = (_object$path = object.path) !== null && _object$path !== void 0 ? _object$path : new Uint8Array();
    message.clientState = object.clientState !== void 0 && object.clientState !== null ? Any.fromPartial(object.clientState) : void 0;
    return message;
  }
};
function createBaseConsensusStateData() {
  return {
    path: new Uint8Array(),
    consensusState: void 0
  };
}
var ConsensusStateData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.consensusState !== void 0) {
      Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConsensusStateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.consensusState = Any.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      consensusState: isSet(object.consensusState) ? Any.fromJSON(object.consensusState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? Any.toJSON(message.consensusState) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$path2;
    const message = createBaseConsensusStateData();
    message.path = (_object$path2 = object.path) !== null && _object$path2 !== void 0 ? _object$path2 : new Uint8Array();
    message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? Any.fromPartial(object.consensusState) : void 0;
    return message;
  }
};
function createBaseConnectionStateData() {
  return {
    path: new Uint8Array(),
    connection: void 0
  };
}
var ConnectionStateData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.connection !== void 0) {
      ConnectionEnd.encode(message.connection, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConnectionStateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.connection = ConnectionEnd.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      connection: isSet(object.connection) ? ConnectionEnd.fromJSON(object.connection) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.connection !== void 0 && (obj.connection = message.connection ? ConnectionEnd.toJSON(message.connection) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$path3;
    const message = createBaseConnectionStateData();
    message.path = (_object$path3 = object.path) !== null && _object$path3 !== void 0 ? _object$path3 : new Uint8Array();
    message.connection = object.connection !== void 0 && object.connection !== null ? ConnectionEnd.fromPartial(object.connection) : void 0;
    return message;
  }
};
function createBaseChannelStateData() {
  return {
    path: new Uint8Array(),
    channel: void 0
  };
}
var ChannelStateData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.channel !== void 0) {
      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseChannelStateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.channel = Channel.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.channel !== void 0 && (obj.channel = message.channel ? Channel.toJSON(message.channel) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$path4;
    const message = createBaseChannelStateData();
    message.path = (_object$path4 = object.path) !== null && _object$path4 !== void 0 ? _object$path4 : new Uint8Array();
    message.channel = object.channel !== void 0 && object.channel !== null ? Channel.fromPartial(object.channel) : void 0;
    return message;
  }
};
function createBasePacketCommitmentData() {
  return {
    path: new Uint8Array(),
    commitment: new Uint8Array()
  };
}
var PacketCommitmentData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.commitment.length !== 0) {
      writer.uint32(18).bytes(message.commitment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePacketCommitmentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.commitment = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.commitment !== void 0 && (obj.commitment = base64FromBytes(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$path5, _object$commitment;
    const message = createBasePacketCommitmentData();
    message.path = (_object$path5 = object.path) !== null && _object$path5 !== void 0 ? _object$path5 : new Uint8Array();
    message.commitment = (_object$commitment = object.commitment) !== null && _object$commitment !== void 0 ? _object$commitment : new Uint8Array();
    return message;
  }
};
function createBasePacketAcknowledgementData() {
  return {
    path: new Uint8Array(),
    acknowledgement: new Uint8Array()
  };
}
var PacketAcknowledgementData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.acknowledgement.length !== 0) {
      writer.uint32(18).bytes(message.acknowledgement);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePacketAcknowledgementData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.acknowledgement = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      acknowledgement: isSet(object.acknowledgement) ? bytesFromBase64(object.acknowledgement) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.acknowledgement !== void 0 && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$path6, _object$acknowledgeme;
    const message = createBasePacketAcknowledgementData();
    message.path = (_object$path6 = object.path) !== null && _object$path6 !== void 0 ? _object$path6 : new Uint8Array();
    message.acknowledgement = (_object$acknowledgeme = object.acknowledgement) !== null && _object$acknowledgeme !== void 0 ? _object$acknowledgeme : new Uint8Array();
    return message;
  }
};
function createBasePacketReceiptAbsenceData() {
  return {
    path: new Uint8Array()
  };
}
var PacketReceiptAbsenceData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePacketReceiptAbsenceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$path7;
    const message = createBasePacketReceiptAbsenceData();
    message.path = (_object$path7 = object.path) !== null && _object$path7 !== void 0 ? _object$path7 : new Uint8Array();
    return message;
  }
};
function createBaseNextSequenceRecvData() {
  return {
    path: new Uint8Array(),
    nextSeqRecv: BigInt("0")
  };
}
var NextSequenceRecvData = {
  encode(message, writer = _m089.Writer.create()) {
    if (message.path.length !== 0) {
      writer.uint32(10).bytes(message.path);
    }
    if (message.nextSeqRecv !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.nextSeqRecv.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m089.Reader ? input : new _m089.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNextSequenceRecvData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.bytes();
          break;
        case 2:
          message.nextSeqRecv = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      nextSeqRecv: isSet(object.nextSeqRecv) ? BigInt(object.nextSeqRecv.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.nextSeqRecv !== void 0 && (obj.nextSeqRecv = (message.nextSeqRecv || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$path8;
    const message = createBaseNextSequenceRecvData();
    message.path = (_object$path8 = object.path) !== null && _object$path8 !== void 0 ? _object$path8 : new Uint8Array();
    message.nextSeqRecv = object.nextSeqRecv !== void 0 && object.nextSeqRecv !== null ? BigInt(object.nextSeqRecv.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/lightclients/solomachine/v3/solomachine.js
var solomachine_exports2 = {};
__export(solomachine_exports2, {
  ClientState: () => ClientState2,
  ConsensusState: () => ConsensusState2,
  Header: () => Header2,
  HeaderData: () => HeaderData2,
  Misbehaviour: () => Misbehaviour2,
  SignBytes: () => SignBytes2,
  SignatureAndData: () => SignatureAndData2,
  TimestampedSignatureData: () => TimestampedSignatureData2
});
var _m090 = __toESM(require_minimal());
function createBaseClientState2() {
  return {
    sequence: BigInt("0"),
    isFrozen: false,
    consensusState: void 0
  };
}
var ClientState2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.isFrozen === true) {
      writer.uint32(16).bool(message.isFrozen);
    }
    if (message.consensusState !== void 0) {
      ConsensusState2.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientState2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.isFrozen = reader.bool();
          break;
        case 3:
          message.consensusState = ConsensusState2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      isFrozen: isSet(object.isFrozen) ? Boolean(object.isFrozen) : false,
      consensusState: isSet(object.consensusState) ? ConsensusState2.fromJSON(object.consensusState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.isFrozen !== void 0 && (obj.isFrozen = message.isFrozen);
    message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? ConsensusState2.toJSON(message.consensusState) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$isFrozen;
    const message = createBaseClientState2();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.isFrozen = (_object$isFrozen = object.isFrozen) !== null && _object$isFrozen !== void 0 ? _object$isFrozen : false;
    message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? ConsensusState2.fromPartial(object.consensusState) : void 0;
    return message;
  }
};
function createBaseConsensusState2() {
  return {
    publicKey: void 0,
    diversifier: "",
    timestamp: BigInt("0")
  };
}
var ConsensusState2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.publicKey !== void 0) {
      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.diversifier !== "") {
      writer.uint32(18).string(message.diversifier);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(24).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConsensusState2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.publicKey = Any.decode(reader, reader.uint32());
          break;
        case 2:
          message.diversifier = reader.string();
          break;
        case 3:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      publicKey: isSet(object.publicKey) ? Any.fromJSON(object.publicKey) : void 0,
      diversifier: isSet(object.diversifier) ? String(object.diversifier) : "",
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? Any.toJSON(message.publicKey) : void 0);
    message.diversifier !== void 0 && (obj.diversifier = message.diversifier);
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$diversifier;
    const message = createBaseConsensusState2();
    message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? Any.fromPartial(object.publicKey) : void 0;
    message.diversifier = (_object$diversifier = object.diversifier) !== null && _object$diversifier !== void 0 ? _object$diversifier : "";
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseHeader2() {
  return {
    timestamp: BigInt("0"),
    signature: new Uint8Array(),
    newPublicKey: void 0,
    newDiversifier: ""
  };
}
var Header2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.newPublicKey !== void 0) {
      Any.encode(message.newPublicKey, writer.uint32(26).fork()).ldelim();
    }
    if (message.newDiversifier !== "") {
      writer.uint32(34).string(message.newDiversifier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeader2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.signature = reader.bytes();
          break;
        case 3:
          message.newPublicKey = Any.decode(reader, reader.uint32());
          break;
        case 4:
          message.newDiversifier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0"),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      newPublicKey: isSet(object.newPublicKey) ? Any.fromJSON(object.newPublicKey) : void 0,
      newDiversifier: isSet(object.newDiversifier) ? String(object.newDiversifier) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.newPublicKey !== void 0 && (obj.newPublicKey = message.newPublicKey ? Any.toJSON(message.newPublicKey) : void 0);
    message.newDiversifier !== void 0 && (obj.newDiversifier = message.newDiversifier);
    return obj;
  },
  fromPartial(object) {
    var _object$signature, _object$newDiversifie;
    const message = createBaseHeader2();
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    message.signature = (_object$signature = object.signature) !== null && _object$signature !== void 0 ? _object$signature : new Uint8Array();
    message.newPublicKey = object.newPublicKey !== void 0 && object.newPublicKey !== null ? Any.fromPartial(object.newPublicKey) : void 0;
    message.newDiversifier = (_object$newDiversifie = object.newDiversifier) !== null && _object$newDiversifie !== void 0 ? _object$newDiversifie : "";
    return message;
  }
};
function createBaseMisbehaviour2() {
  return {
    sequence: BigInt("0"),
    signatureOne: void 0,
    signatureTwo: void 0
  };
}
var Misbehaviour2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.signatureOne !== void 0) {
      SignatureAndData2.encode(message.signatureOne, writer.uint32(18).fork()).ldelim();
    }
    if (message.signatureTwo !== void 0) {
      SignatureAndData2.encode(message.signatureTwo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMisbehaviour2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.signatureOne = SignatureAndData2.decode(reader, reader.uint32());
          break;
        case 3:
          message.signatureTwo = SignatureAndData2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      signatureOne: isSet(object.signatureOne) ? SignatureAndData2.fromJSON(object.signatureOne) : void 0,
      signatureTwo: isSet(object.signatureTwo) ? SignatureAndData2.fromJSON(object.signatureTwo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.signatureOne !== void 0 && (obj.signatureOne = message.signatureOne ? SignatureAndData2.toJSON(message.signatureOne) : void 0);
    message.signatureTwo !== void 0 && (obj.signatureTwo = message.signatureTwo ? SignatureAndData2.toJSON(message.signatureTwo) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMisbehaviour2();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.signatureOne = object.signatureOne !== void 0 && object.signatureOne !== null ? SignatureAndData2.fromPartial(object.signatureOne) : void 0;
    message.signatureTwo = object.signatureTwo !== void 0 && object.signatureTwo !== null ? SignatureAndData2.fromPartial(object.signatureTwo) : void 0;
    return message;
  }
};
function createBaseSignatureAndData2() {
  return {
    signature: new Uint8Array(),
    path: new Uint8Array(),
    data: new Uint8Array(),
    timestamp: BigInt("0")
  };
}
var SignatureAndData2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.path.length !== 0) {
      writer.uint32(18).bytes(message.path);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(32).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignatureAndData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signature = reader.bytes();
          break;
        case 2:
          message.path = reader.bytes();
          break;
        case 3:
          message.data = reader.bytes();
          break;
        case 4:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$signature2, _object$path, _object$data;
    const message = createBaseSignatureAndData2();
    message.signature = (_object$signature2 = object.signature) !== null && _object$signature2 !== void 0 ? _object$signature2 : new Uint8Array();
    message.path = (_object$path = object.path) !== null && _object$path !== void 0 ? _object$path : new Uint8Array();
    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseTimestampedSignatureData2() {
  return {
    signatureData: new Uint8Array(),
    timestamp: BigInt("0")
  };
}
var TimestampedSignatureData2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.signatureData.length !== 0) {
      writer.uint32(10).bytes(message.signatureData);
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestampedSignatureData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signatureData = reader.bytes();
          break;
        case 2:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signatureData: isSet(object.signatureData) ? bytesFromBase64(object.signatureData) : new Uint8Array(),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.signatureData !== void 0 && (obj.signatureData = base64FromBytes(message.signatureData !== void 0 ? message.signatureData : new Uint8Array()));
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    var _object$signatureData;
    const message = createBaseTimestampedSignatureData2();
    message.signatureData = (_object$signatureData = object.signatureData) !== null && _object$signatureData !== void 0 ? _object$signatureData : new Uint8Array();
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    return message;
  }
};
function createBaseSignBytes2() {
  return {
    sequence: BigInt("0"),
    timestamp: BigInt("0"),
    diversifier: "",
    path: new Uint8Array(),
    data: new Uint8Array()
  };
}
var SignBytes2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.sequence !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.sequence.toString()));
    }
    if (message.timestamp !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.timestamp.toString()));
    }
    if (message.diversifier !== "") {
      writer.uint32(26).string(message.diversifier);
    }
    if (message.path.length !== 0) {
      writer.uint32(34).bytes(message.path);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignBytes2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequence = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.timestamp = BigInt(reader.uint64().toString());
          break;
        case 3:
          message.diversifier = reader.string();
          break;
        case 4:
          message.path = reader.bytes();
          break;
        case 5:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sequence: isSet(object.sequence) ? BigInt(object.sequence.toString()) : BigInt("0"),
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp.toString()) : BigInt("0"),
      diversifier: isSet(object.diversifier) ? String(object.diversifier) : "",
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt("0")).toString());
    message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt("0")).toString());
    message.diversifier !== void 0 && (obj.diversifier = message.diversifier);
    message.path !== void 0 && (obj.path = base64FromBytes(message.path !== void 0 ? message.path : new Uint8Array()));
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$diversifier2, _object$path2, _object$data2;
    const message = createBaseSignBytes2();
    message.sequence = object.sequence !== void 0 && object.sequence !== null ? BigInt(object.sequence.toString()) : BigInt("0");
    message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? BigInt(object.timestamp.toString()) : BigInt("0");
    message.diversifier = (_object$diversifier2 = object.diversifier) !== null && _object$diversifier2 !== void 0 ? _object$diversifier2 : "";
    message.path = (_object$path2 = object.path) !== null && _object$path2 !== void 0 ? _object$path2 : new Uint8Array();
    message.data = (_object$data2 = object.data) !== null && _object$data2 !== void 0 ? _object$data2 : new Uint8Array();
    return message;
  }
};
function createBaseHeaderData2() {
  return {
    newPubKey: void 0,
    newDiversifier: ""
  };
}
var HeaderData2 = {
  encode(message, writer = _m090.Writer.create()) {
    if (message.newPubKey !== void 0) {
      Any.encode(message.newPubKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.newDiversifier !== "") {
      writer.uint32(18).string(message.newDiversifier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m090.Reader ? input : new _m090.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeaderData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.newPubKey = Any.decode(reader, reader.uint32());
          break;
        case 2:
          message.newDiversifier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      newPubKey: isSet(object.newPubKey) ? Any.fromJSON(object.newPubKey) : void 0,
      newDiversifier: isSet(object.newDiversifier) ? String(object.newDiversifier) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.newPubKey !== void 0 && (obj.newPubKey = message.newPubKey ? Any.toJSON(message.newPubKey) : void 0);
    message.newDiversifier !== void 0 && (obj.newDiversifier = message.newDiversifier);
    return obj;
  },
  fromPartial(object) {
    var _object$newDiversifie2;
    const message = createBaseHeaderData2();
    message.newPubKey = object.newPubKey !== void 0 && object.newPubKey !== null ? Any.fromPartial(object.newPubKey) : void 0;
    message.newDiversifier = (_object$newDiversifie2 = object.newDiversifier) !== null && _object$newDiversifie2 !== void 0 ? _object$newDiversifie2 : "";
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/lightclients/tendermint/v1/tendermint.js
var tendermint_exports = {};
__export(tendermint_exports, {
  ClientState: () => ClientState3,
  ConsensusState: () => ConsensusState3,
  Fraction: () => Fraction,
  Header: () => Header3,
  Misbehaviour: () => Misbehaviour3
});
var _m091 = __toESM(require_minimal());
function createBaseClientState3() {
  return {
    chainId: "",
    trustLevel: void 0,
    trustingPeriod: void 0,
    unbondingPeriod: void 0,
    maxClockDrift: void 0,
    frozenHeight: void 0,
    latestHeight: void 0,
    proofSpecs: [],
    upgradePath: [],
    allowUpdateAfterExpiry: false,
    allowUpdateAfterMisbehaviour: false
  };
}
var ClientState3 = {
  encode(message, writer = _m091.Writer.create()) {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.trustLevel !== void 0) {
      Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
    }
    if (message.trustingPeriod !== void 0) {
      Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
    }
    if (message.unbondingPeriod !== void 0) {
      Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
    }
    if (message.maxClockDrift !== void 0) {
      Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
    }
    if (message.frozenHeight !== void 0) {
      Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
    }
    if (message.latestHeight !== void 0) {
      Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.proofSpecs) {
      ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.upgradePath) {
      writer.uint32(74).string(v);
    }
    if (message.allowUpdateAfterExpiry === true) {
      writer.uint32(80).bool(message.allowUpdateAfterExpiry);
    }
    if (message.allowUpdateAfterMisbehaviour === true) {
      writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m091.Reader ? input : new _m091.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientState3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chainId = reader.string();
          break;
        case 2:
          message.trustLevel = Fraction.decode(reader, reader.uint32());
          break;
        case 3:
          message.trustingPeriod = Duration.decode(reader, reader.uint32());
          break;
        case 4:
          message.unbondingPeriod = Duration.decode(reader, reader.uint32());
          break;
        case 5:
          message.maxClockDrift = Duration.decode(reader, reader.uint32());
          break;
        case 6:
          message.frozenHeight = Height.decode(reader, reader.uint32());
          break;
        case 7:
          message.latestHeight = Height.decode(reader, reader.uint32());
          break;
        case 8:
          message.proofSpecs.push(ProofSpec.decode(reader, reader.uint32()));
          break;
        case 9:
          message.upgradePath.push(reader.string());
          break;
        case 10:
          message.allowUpdateAfterExpiry = reader.bool();
          break;
        case 11:
          message.allowUpdateAfterMisbehaviour = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "",
      trustLevel: isSet(object.trustLevel) ? Fraction.fromJSON(object.trustLevel) : void 0,
      trustingPeriod: isSet(object.trustingPeriod) ? Duration.fromJSON(object.trustingPeriod) : void 0,
      unbondingPeriod: isSet(object.unbondingPeriod) ? Duration.fromJSON(object.unbondingPeriod) : void 0,
      maxClockDrift: isSet(object.maxClockDrift) ? Duration.fromJSON(object.maxClockDrift) : void 0,
      frozenHeight: isSet(object.frozenHeight) ? Height.fromJSON(object.frozenHeight) : void 0,
      latestHeight: isSet(object.latestHeight) ? Height.fromJSON(object.latestHeight) : void 0,
      proofSpecs: Array.isArray(object === null || object === void 0 ? void 0 : object.proofSpecs) ? object.proofSpecs.map((e) => ProofSpec.fromJSON(e)) : [],
      upgradePath: Array.isArray(object === null || object === void 0 ? void 0 : object.upgradePath) ? object.upgradePath.map((e) => String(e)) : [],
      allowUpdateAfterExpiry: isSet(object.allowUpdateAfterExpiry) ? Boolean(object.allowUpdateAfterExpiry) : false,
      allowUpdateAfterMisbehaviour: isSet(object.allowUpdateAfterMisbehaviour) ? Boolean(object.allowUpdateAfterMisbehaviour) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.chainId !== void 0 && (obj.chainId = message.chainId);
    message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? Fraction.toJSON(message.trustLevel) : void 0);
    message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? Duration.toJSON(message.trustingPeriod) : void 0);
    message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? Duration.toJSON(message.unbondingPeriod) : void 0);
    message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? Duration.toJSON(message.maxClockDrift) : void 0);
    message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? Height.toJSON(message.frozenHeight) : void 0);
    message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? Height.toJSON(message.latestHeight) : void 0);
    if (message.proofSpecs) {
      obj.proofSpecs = message.proofSpecs.map((e) => e ? ProofSpec.toJSON(e) : void 0);
    } else {
      obj.proofSpecs = [];
    }
    if (message.upgradePath) {
      obj.upgradePath = message.upgradePath.map((e) => e);
    } else {
      obj.upgradePath = [];
    }
    message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
    message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
    return obj;
  },
  fromPartial(object) {
    var _object$chainId, _object$proofSpecs, _object$upgradePath, _object$allowUpdateAf, _object$allowUpdateAf2;
    const message = createBaseClientState3();
    message.chainId = (_object$chainId = object.chainId) !== null && _object$chainId !== void 0 ? _object$chainId : "";
    message.trustLevel = object.trustLevel !== void 0 && object.trustLevel !== null ? Fraction.fromPartial(object.trustLevel) : void 0;
    message.trustingPeriod = object.trustingPeriod !== void 0 && object.trustingPeriod !== null ? Duration.fromPartial(object.trustingPeriod) : void 0;
    message.unbondingPeriod = object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null ? Duration.fromPartial(object.unbondingPeriod) : void 0;
    message.maxClockDrift = object.maxClockDrift !== void 0 && object.maxClockDrift !== null ? Duration.fromPartial(object.maxClockDrift) : void 0;
    message.frozenHeight = object.frozenHeight !== void 0 && object.frozenHeight !== null ? Height.fromPartial(object.frozenHeight) : void 0;
    message.latestHeight = object.latestHeight !== void 0 && object.latestHeight !== null ? Height.fromPartial(object.latestHeight) : void 0;
    message.proofSpecs = ((_object$proofSpecs = object.proofSpecs) === null || _object$proofSpecs === void 0 ? void 0 : _object$proofSpecs.map((e) => ProofSpec.fromPartial(e))) || [];
    message.upgradePath = ((_object$upgradePath = object.upgradePath) === null || _object$upgradePath === void 0 ? void 0 : _object$upgradePath.map((e) => e)) || [];
    message.allowUpdateAfterExpiry = (_object$allowUpdateAf = object.allowUpdateAfterExpiry) !== null && _object$allowUpdateAf !== void 0 ? _object$allowUpdateAf : false;
    message.allowUpdateAfterMisbehaviour = (_object$allowUpdateAf2 = object.allowUpdateAfterMisbehaviour) !== null && _object$allowUpdateAf2 !== void 0 ? _object$allowUpdateAf2 : false;
    return message;
  }
};
function createBaseConsensusState3() {
  return {
    timestamp: void 0,
    root: void 0,
    nextValidatorsHash: new Uint8Array()
  };
}
var ConsensusState3 = {
  encode(message, writer = _m091.Writer.create()) {
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    if (message.root !== void 0) {
      MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
    }
    if (message.nextValidatorsHash.length !== 0) {
      writer.uint32(26).bytes(message.nextValidatorsHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m091.Reader ? input : new _m091.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConsensusState3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.root = MerkleRoot.decode(reader, reader.uint32());
          break;
        case 3:
          message.nextValidatorsHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
      root: isSet(object.root) ? MerkleRoot.fromJSON(object.root) : void 0,
      nextValidatorsHash: isSet(object.nextValidatorsHash) ? bytesFromBase64(object.nextValidatorsHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    message.root !== void 0 && (obj.root = message.root ? MerkleRoot.toJSON(message.root) : void 0);
    message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _object$timestamp, _object$nextValidator;
    const message = createBaseConsensusState3();
    message.timestamp = (_object$timestamp = object.timestamp) !== null && _object$timestamp !== void 0 ? _object$timestamp : void 0;
    message.root = object.root !== void 0 && object.root !== null ? MerkleRoot.fromPartial(object.root) : void 0;
    message.nextValidatorsHash = (_object$nextValidator = object.nextValidatorsHash) !== null && _object$nextValidator !== void 0 ? _object$nextValidator : new Uint8Array();
    return message;
  }
};
function createBaseMisbehaviour3() {
  return {
    clientId: "",
    header1: void 0,
    header2: void 0
  };
}
var Misbehaviour3 = {
  encode(message, writer = _m091.Writer.create()) {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.header1 !== void 0) {
      Header3.encode(message.header1, writer.uint32(18).fork()).ldelim();
    }
    if (message.header2 !== void 0) {
      Header3.encode(message.header2, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m091.Reader ? input : new _m091.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMisbehaviour3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clientId = reader.string();
          break;
        case 2:
          message.header1 = Header3.decode(reader, reader.uint32());
          break;
        case 3:
          message.header2 = Header3.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      clientId: isSet(object.clientId) ? String(object.clientId) : "",
      header1: isSet(object.header1) ? Header3.fromJSON(object.header1) : void 0,
      header2: isSet(object.header2) ? Header3.fromJSON(object.header2) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.clientId !== void 0 && (obj.clientId = message.clientId);
    message.header1 !== void 0 && (obj.header1 = message.header1 ? Header3.toJSON(message.header1) : void 0);
    message.header2 !== void 0 && (obj.header2 = message.header2 ? Header3.toJSON(message.header2) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _object$clientId;
    const message = createBaseMisbehaviour3();
    message.clientId = (_object$clientId = object.clientId) !== null && _object$clientId !== void 0 ? _object$clientId : "";
    message.header1 = object.header1 !== void 0 && object.header1 !== null ? Header3.fromPartial(object.header1) : void 0;
    message.header2 = object.header2 !== void 0 && object.header2 !== null ? Header3.fromPartial(object.header2) : void 0;
    return message;
  }
};
function createBaseHeader3() {
  return {
    signedHeader: void 0,
    validatorSet: void 0,
    trustedHeight: void 0,
    trustedValidators: void 0
  };
}
var Header3 = {
  encode(message, writer = _m091.Writer.create()) {
    if (message.signedHeader !== void 0) {
      SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorSet !== void 0) {
      ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
    }
    if (message.trustedHeight !== void 0) {
      Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
    }
    if (message.trustedValidators !== void 0) {
      ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m091.Reader ? input : new _m091.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeader3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signedHeader = SignedHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.validatorSet = ValidatorSet.decode(reader, reader.uint32());
          break;
        case 3:
          message.trustedHeight = Height.decode(reader, reader.uint32());
          break;
        case 4:
          message.trustedValidators = ValidatorSet.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signedHeader: isSet(object.signedHeader) ? SignedHeader.fromJSON(object.signedHeader) : void 0,
      validatorSet: isSet(object.validatorSet) ? ValidatorSet.fromJSON(object.validatorSet) : void 0,
      trustedHeight: isSet(object.trustedHeight) ? Height.fromJSON(object.trustedHeight) : void 0,
      trustedValidators: isSet(object.trustedValidators) ? ValidatorSet.fromJSON(object.trustedValidators) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? SignedHeader.toJSON(message.signedHeader) : void 0);
    message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? ValidatorSet.toJSON(message.validatorSet) : void 0);
    message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? Height.toJSON(message.trustedHeight) : void 0);
    message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? ValidatorSet.toJSON(message.trustedValidators) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHeader3();
    message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? SignedHeader.fromPartial(object.signedHeader) : void 0;
    message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? ValidatorSet.fromPartial(object.validatorSet) : void 0;
    message.trustedHeight = object.trustedHeight !== void 0 && object.trustedHeight !== null ? Height.fromPartial(object.trustedHeight) : void 0;
    message.trustedValidators = object.trustedValidators !== void 0 && object.trustedValidators !== null ? ValidatorSet.fromPartial(object.trustedValidators) : void 0;
    return message;
  }
};
function createBaseFraction() {
  return {
    numerator: BigInt("0"),
    denominator: BigInt("0")
  };
}
var Fraction = {
  encode(message, writer = _m091.Writer.create()) {
    if (message.numerator !== BigInt(0)) {
      writer.uint32(8).uint64(import_long.default.fromString(message.numerator.toString()));
    }
    if (message.denominator !== BigInt(0)) {
      writer.uint32(16).uint64(import_long.default.fromString(message.denominator.toString()));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m091.Reader ? input : new _m091.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.numerator = BigInt(reader.uint64().toString());
          break;
        case 2:
          message.denominator = BigInt(reader.uint64().toString());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      numerator: isSet(object.numerator) ? BigInt(object.numerator.toString()) : BigInt("0"),
      denominator: isSet(object.denominator) ? BigInt(object.denominator.toString()) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    message.numerator !== void 0 && (obj.numerator = (message.numerator || BigInt("0")).toString());
    message.denominator !== void 0 && (obj.denominator = (message.denominator || BigInt("0")).toString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFraction();
    message.numerator = object.numerator !== void 0 && object.numerator !== null ? BigInt(object.numerator.toString()) : BigInt("0");
    message.denominator = object.denominator !== void 0 && object.denominator !== null ? BigInt(object.denominator.toString()) : BigInt("0");
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/fee/v1/tx.amino.js
var tx_amino_exports22 = {};
__export(tx_amino_exports22, {
  AminoConverter: () => AminoConverter22
});
var AminoConverter22 = {
  "/ibc.applications.fee.v1.MsgRegisterPayee": {
    aminoType: "cosmos-sdk/MsgRegisterPayee",
    toAmino: ({
      portId,
      channelId,
      relayer,
      payee
    }) => {
      return {
        port_id: portId,
        channel_id: channelId,
        relayer,
        payee
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      relayer,
      payee
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        relayer,
        payee
      };
    }
  },
  "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee": {
    aminoType: "cosmos-sdk/MsgRegisterCounterpartyPayee",
    toAmino: ({
      portId,
      channelId,
      relayer,
      counterpartyPayee
    }) => {
      return {
        port_id: portId,
        channel_id: channelId,
        relayer,
        counterparty_payee: counterpartyPayee
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      relayer,
      counterparty_payee
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        relayer,
        counterpartyPayee: counterparty_payee
      };
    }
  },
  "/ibc.applications.fee.v1.MsgPayPacketFee": {
    aminoType: "cosmos-sdk/MsgPayPacketFee",
    toAmino: ({
      fee,
      sourcePortId,
      sourceChannelId,
      signer,
      relayers
    }) => {
      return {
        fee: {
          recv_fee: fee.recvFee.map((el0) => ({
            denom: el0.denom,
            amount: el0.amount
          })),
          ack_fee: fee.ackFee.map((el0) => ({
            denom: el0.denom,
            amount: el0.amount
          })),
          timeout_fee: fee.timeoutFee.map((el0) => ({
            denom: el0.denom,
            amount: el0.amount
          }))
        },
        source_port_id: sourcePortId,
        source_channel_id: sourceChannelId,
        signer,
        relayers
      };
    },
    fromAmino: ({
      fee,
      source_port_id,
      source_channel_id,
      signer,
      relayers
    }) => {
      return {
        fee: {
          recvFee: fee.recv_fee.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          })),
          ackFee: fee.ack_fee.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          })),
          timeoutFee: fee.timeout_fee.map((el1) => ({
            denom: el1.denom,
            amount: el1.amount
          }))
        },
        sourcePortId: source_port_id,
        sourceChannelId: source_channel_id,
        signer,
        relayers
      };
    }
  },
  "/ibc.applications.fee.v1.MsgPayPacketFeeAsync": {
    aminoType: "cosmos-sdk/MsgPayPacketFeeAsync",
    toAmino: ({
      packetId,
      packetFee
    }) => {
      return {
        packet_id: {
          port_id: packetId.portId,
          channel_id: packetId.channelId,
          sequence: packetId.sequence.toString()
        },
        packet_fee: {
          fee: {
            recv_fee: packetFee.fee.recvFee.map((el0) => ({
              denom: el0.denom,
              amount: el0.amount
            })),
            ack_fee: packetFee.fee.ackFee.map((el0) => ({
              denom: el0.denom,
              amount: el0.amount
            })),
            timeout_fee: packetFee.fee.timeoutFee.map((el0) => ({
              denom: el0.denom,
              amount: el0.amount
            }))
          },
          refund_address: packetFee.refundAddress,
          relayers: packetFee.relayers
        }
      };
    },
    fromAmino: ({
      packet_id,
      packet_fee
    }) => {
      return {
        packetId: {
          portId: packet_id.port_id,
          channelId: packet_id.channel_id,
          sequence: BigInt(packet_id.sequence)
        },
        packetFee: {
          fee: {
            recvFee: packet_fee.fee.recv_fee.map((el2) => ({
              denom: el2.denom,
              amount: el2.amount
            })),
            ackFee: packet_fee.fee.ack_fee.map((el2) => ({
              denom: el2.denom,
              amount: el2.amount
            })),
            timeoutFee: packet_fee.fee.timeout_fee.map((el2) => ({
              denom: el2.denom,
              amount: el2.amount
            }))
          },
          refundAddress: packet_fee.refund_address,
          relayers: packet_fee.relayers
        }
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/interchain_accounts/controller/v1/tx.amino.js
var tx_amino_exports23 = {};
__export(tx_amino_exports23, {
  AminoConverter: () => AminoConverter23
});
var AminoConverter23 = {
  "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount": {
    aminoType: "cosmos-sdk/MsgRegisterInterchainAccount",
    toAmino: ({
      owner,
      connectionId,
      version
    }) => {
      return {
        owner,
        connection_id: connectionId,
        version
      };
    },
    fromAmino: ({
      owner,
      connection_id,
      version
    }) => {
      return {
        owner,
        connectionId: connection_id,
        version
      };
    }
  },
  "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx": {
    aminoType: "cosmos-sdk/MsgSendTx",
    toAmino: ({
      owner,
      connectionId,
      packetData,
      relativeTimeout
    }) => {
      return {
        owner,
        connection_id: connectionId,
        packet_data: {
          type: packetData.type,
          data: packetData.data,
          memo: packetData.memo
        },
        relative_timeout: relativeTimeout.toString()
      };
    },
    fromAmino: ({
      owner,
      connection_id,
      packet_data,
      relative_timeout
    }) => {
      return {
        owner,
        connectionId: connection_id,
        packetData: {
          type: typeFromJSON(packet_data.type),
          data: packet_data.data,
          memo: packet_data.memo
        },
        relativeTimeout: BigInt(relative_timeout)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/transfer/v1/tx.amino.js
var tx_amino_exports24 = {};
__export(tx_amino_exports24, {
  AminoConverter: () => AminoConverter24
});
var AminoConverter24 = {
  "/ibc.applications.transfer.v1.MsgTransfer": {
    aminoType: "cosmos-sdk/MsgTransfer",
    toAmino: ({
      sourcePort,
      sourceChannel,
      token,
      sender,
      receiver,
      timeoutHeight,
      timeoutTimestamp,
      memo
    }) => {
      var _omitDefault, _omitDefault2;
      return {
        source_port: sourcePort,
        source_channel: sourceChannel,
        token: {
          denom: token.denom,
          amount: token.amount
        },
        sender,
        receiver,
        timeout_height: timeoutHeight ? {
          revision_height: (_omitDefault = omitDefault(timeoutHeight.revisionHeight)) === null || _omitDefault === void 0 ? void 0 : _omitDefault.toString(),
          revision_number: (_omitDefault2 = omitDefault(timeoutHeight.revisionNumber)) === null || _omitDefault2 === void 0 ? void 0 : _omitDefault2.toString()
        } : {},
        timeout_timestamp: timeoutTimestamp.toString(),
        memo
      };
    },
    fromAmino: ({
      source_port,
      source_channel,
      token,
      sender,
      receiver,
      timeout_height,
      timeout_timestamp,
      memo
    }) => {
      return {
        sourcePort: source_port,
        sourceChannel: source_channel,
        token: {
          denom: token.denom,
          amount: token.amount
        },
        sender,
        receiver,
        timeoutHeight: timeout_height ? {
          revisionHeight: BigInt(timeout_height.revision_height || "0", true),
          revisionNumber: BigInt(timeout_height.revision_number || "0", true)
        } : void 0,
        timeoutTimestamp: BigInt(timeout_timestamp),
        memo
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/channel/v1/tx.amino.js
var tx_amino_exports25 = {};
__export(tx_amino_exports25, {
  AminoConverter: () => AminoConverter25
});
var AminoConverter25 = {
  "/ibc.core.channel.v1.MsgChannelOpenInit": {
    aminoType: "cosmos-sdk/MsgChannelOpenInit",
    toAmino: ({
      portId,
      channel,
      signer
    }) => {
      return {
        port_id: portId,
        channel: {
          state: channel.state,
          ordering: channel.ordering,
          counterparty: {
            port_id: channel.counterparty.portId,
            channel_id: channel.counterparty.channelId
          },
          connection_hops: channel.connectionHops,
          version: channel.version
        },
        signer
      };
    },
    fromAmino: ({
      port_id,
      channel,
      signer
    }) => {
      return {
        portId: port_id,
        channel: {
          state: stateFromJSON(channel.state),
          ordering: orderFromJSON(channel.ordering),
          counterparty: {
            portId: channel.counterparty.port_id,
            channelId: channel.counterparty.channel_id
          },
          connectionHops: channel.connection_hops,
          version: channel.version
        },
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgChannelOpenTry": {
    aminoType: "cosmos-sdk/MsgChannelOpenTry",
    toAmino: ({
      portId,
      previousChannelId,
      channel,
      counterpartyVersion,
      proofInit,
      proofHeight,
      signer
    }) => {
      var _omitDefault, _omitDefault2;
      return {
        port_id: portId,
        previous_channel_id: previousChannelId,
        channel: {
          state: channel.state,
          ordering: channel.ordering,
          counterparty: {
            port_id: channel.counterparty.portId,
            channel_id: channel.counterparty.channelId
          },
          connection_hops: channel.connectionHops,
          version: channel.version
        },
        counterparty_version: counterpartyVersion,
        proof_init: proofInit,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault === void 0 ? void 0 : _omitDefault.toString(),
          revision_number: (_omitDefault2 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault2 === void 0 ? void 0 : _omitDefault2.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      port_id,
      previous_channel_id,
      channel,
      counterparty_version,
      proof_init,
      proof_height,
      signer
    }) => {
      return {
        portId: port_id,
        previousChannelId: previous_channel_id,
        channel: {
          state: stateFromJSON(channel.state),
          ordering: orderFromJSON(channel.ordering),
          counterparty: {
            portId: channel.counterparty.port_id,
            channelId: channel.counterparty.channel_id
          },
          connectionHops: channel.connection_hops,
          version: channel.version
        },
        counterpartyVersion: counterparty_version,
        proofInit: proof_init,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgChannelOpenAck": {
    aminoType: "cosmos-sdk/MsgChannelOpenAck",
    toAmino: ({
      portId,
      channelId,
      counterpartyChannelId,
      counterpartyVersion,
      proofTry,
      proofHeight,
      signer
    }) => {
      var _omitDefault3, _omitDefault4;
      return {
        port_id: portId,
        channel_id: channelId,
        counterparty_channel_id: counterpartyChannelId,
        counterparty_version: counterpartyVersion,
        proof_try: proofTry,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault3 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault3 === void 0 ? void 0 : _omitDefault3.toString(),
          revision_number: (_omitDefault4 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault4 === void 0 ? void 0 : _omitDefault4.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      counterparty_channel_id,
      counterparty_version,
      proof_try,
      proof_height,
      signer
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        counterpartyChannelId: counterparty_channel_id,
        counterpartyVersion: counterparty_version,
        proofTry: proof_try,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgChannelOpenConfirm": {
    aminoType: "cosmos-sdk/MsgChannelOpenConfirm",
    toAmino: ({
      portId,
      channelId,
      proofAck,
      proofHeight,
      signer
    }) => {
      var _omitDefault5, _omitDefault6;
      return {
        port_id: portId,
        channel_id: channelId,
        proof_ack: proofAck,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault5 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault5 === void 0 ? void 0 : _omitDefault5.toString(),
          revision_number: (_omitDefault6 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault6 === void 0 ? void 0 : _omitDefault6.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      proof_ack,
      proof_height,
      signer
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        proofAck: proof_ack,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgChannelCloseInit": {
    aminoType: "cosmos-sdk/MsgChannelCloseInit",
    toAmino: ({
      portId,
      channelId,
      signer
    }) => {
      return {
        port_id: portId,
        channel_id: channelId,
        signer
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      signer
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgChannelCloseConfirm": {
    aminoType: "cosmos-sdk/MsgChannelCloseConfirm",
    toAmino: ({
      portId,
      channelId,
      proofInit,
      proofHeight,
      signer
    }) => {
      var _omitDefault7, _omitDefault8;
      return {
        port_id: portId,
        channel_id: channelId,
        proof_init: proofInit,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault7 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault7 === void 0 ? void 0 : _omitDefault7.toString(),
          revision_number: (_omitDefault8 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault8 === void 0 ? void 0 : _omitDefault8.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      port_id,
      channel_id,
      proof_init,
      proof_height,
      signer
    }) => {
      return {
        portId: port_id,
        channelId: channel_id,
        proofInit: proof_init,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgRecvPacket": {
    aminoType: "cosmos-sdk/MsgRecvPacket",
    toAmino: ({
      packet,
      proofCommitment,
      proofHeight,
      signer
    }) => {
      var _omitDefault9, _omitDefault10, _omitDefault11, _omitDefault12;
      return {
        packet: {
          sequence: packet.sequence.toString(),
          source_port: packet.sourcePort,
          source_channel: packet.sourceChannel,
          destination_port: packet.destinationPort,
          destination_channel: packet.destinationChannel,
          data: packet.data,
          timeout_height: packet.timeoutHeight ? {
            revision_height: (_omitDefault9 = omitDefault(packet.timeoutHeight.revisionHeight)) === null || _omitDefault9 === void 0 ? void 0 : _omitDefault9.toString(),
            revision_number: (_omitDefault10 = omitDefault(packet.timeoutHeight.revisionNumber)) === null || _omitDefault10 === void 0 ? void 0 : _omitDefault10.toString()
          } : {},
          timeout_timestamp: packet.timeoutTimestamp.toString()
        },
        proof_commitment: proofCommitment,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault11 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault11 === void 0 ? void 0 : _omitDefault11.toString(),
          revision_number: (_omitDefault12 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault12 === void 0 ? void 0 : _omitDefault12.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      packet,
      proof_commitment,
      proof_height,
      signer
    }) => {
      return {
        packet: {
          sequence: BigInt(packet.sequence),
          sourcePort: packet.source_port,
          sourceChannel: packet.source_channel,
          destinationPort: packet.destination_port,
          destinationChannel: packet.destination_channel,
          data: packet.data,
          timeoutHeight: packet.timeout_height ? {
            revisionHeight: BigInt(packet.timeout_height.revision_height || "0", true),
            revisionNumber: BigInt(packet.timeout_height.revision_number || "0", true)
          } : void 0,
          timeoutTimestamp: BigInt(packet.timeout_timestamp)
        },
        proofCommitment: proof_commitment,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgTimeout": {
    aminoType: "cosmos-sdk/MsgTimeout",
    toAmino: ({
      packet,
      proofUnreceived,
      proofHeight,
      nextSequenceRecv,
      signer
    }) => {
      var _omitDefault13, _omitDefault14, _omitDefault15, _omitDefault16;
      return {
        packet: {
          sequence: packet.sequence.toString(),
          source_port: packet.sourcePort,
          source_channel: packet.sourceChannel,
          destination_port: packet.destinationPort,
          destination_channel: packet.destinationChannel,
          data: packet.data,
          timeout_height: packet.timeoutHeight ? {
            revision_height: (_omitDefault13 = omitDefault(packet.timeoutHeight.revisionHeight)) === null || _omitDefault13 === void 0 ? void 0 : _omitDefault13.toString(),
            revision_number: (_omitDefault14 = omitDefault(packet.timeoutHeight.revisionNumber)) === null || _omitDefault14 === void 0 ? void 0 : _omitDefault14.toString()
          } : {},
          timeout_timestamp: packet.timeoutTimestamp.toString()
        },
        proof_unreceived: proofUnreceived,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault15 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault15 === void 0 ? void 0 : _omitDefault15.toString(),
          revision_number: (_omitDefault16 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault16 === void 0 ? void 0 : _omitDefault16.toString()
        } : {},
        next_sequence_recv: nextSequenceRecv.toString(),
        signer
      };
    },
    fromAmino: ({
      packet,
      proof_unreceived,
      proof_height,
      next_sequence_recv,
      signer
    }) => {
      return {
        packet: {
          sequence: BigInt(packet.sequence),
          sourcePort: packet.source_port,
          sourceChannel: packet.source_channel,
          destinationPort: packet.destination_port,
          destinationChannel: packet.destination_channel,
          data: packet.data,
          timeoutHeight: packet.timeout_height ? {
            revisionHeight: BigInt(packet.timeout_height.revision_height || "0", true),
            revisionNumber: BigInt(packet.timeout_height.revision_number || "0", true)
          } : void 0,
          timeoutTimestamp: BigInt(packet.timeout_timestamp)
        },
        proofUnreceived: proof_unreceived,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        nextSequenceRecv: BigInt(next_sequence_recv),
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgTimeoutOnClose": {
    aminoType: "cosmos-sdk/MsgTimeoutOnClose",
    toAmino: ({
      packet,
      proofUnreceived,
      proofClose,
      proofHeight,
      nextSequenceRecv,
      signer
    }) => {
      var _omitDefault17, _omitDefault18, _omitDefault19, _omitDefault20;
      return {
        packet: {
          sequence: packet.sequence.toString(),
          source_port: packet.sourcePort,
          source_channel: packet.sourceChannel,
          destination_port: packet.destinationPort,
          destination_channel: packet.destinationChannel,
          data: packet.data,
          timeout_height: packet.timeoutHeight ? {
            revision_height: (_omitDefault17 = omitDefault(packet.timeoutHeight.revisionHeight)) === null || _omitDefault17 === void 0 ? void 0 : _omitDefault17.toString(),
            revision_number: (_omitDefault18 = omitDefault(packet.timeoutHeight.revisionNumber)) === null || _omitDefault18 === void 0 ? void 0 : _omitDefault18.toString()
          } : {},
          timeout_timestamp: packet.timeoutTimestamp.toString()
        },
        proof_unreceived: proofUnreceived,
        proof_close: proofClose,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault19 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault19 === void 0 ? void 0 : _omitDefault19.toString(),
          revision_number: (_omitDefault20 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault20 === void 0 ? void 0 : _omitDefault20.toString()
        } : {},
        next_sequence_recv: nextSequenceRecv.toString(),
        signer
      };
    },
    fromAmino: ({
      packet,
      proof_unreceived,
      proof_close,
      proof_height,
      next_sequence_recv,
      signer
    }) => {
      return {
        packet: {
          sequence: BigInt(packet.sequence),
          sourcePort: packet.source_port,
          sourceChannel: packet.source_channel,
          destinationPort: packet.destination_port,
          destinationChannel: packet.destination_channel,
          data: packet.data,
          timeoutHeight: packet.timeout_height ? {
            revisionHeight: BigInt(packet.timeout_height.revision_height || "0", true),
            revisionNumber: BigInt(packet.timeout_height.revision_number || "0", true)
          } : void 0,
          timeoutTimestamp: BigInt(packet.timeout_timestamp)
        },
        proofUnreceived: proof_unreceived,
        proofClose: proof_close,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        nextSequenceRecv: BigInt(next_sequence_recv),
        signer
      };
    }
  },
  "/ibc.core.channel.v1.MsgAcknowledgement": {
    aminoType: "cosmos-sdk/MsgAcknowledgement",
    toAmino: ({
      packet,
      acknowledgement,
      proofAcked,
      proofHeight,
      signer
    }) => {
      var _omitDefault21, _omitDefault22, _omitDefault23, _omitDefault24;
      return {
        packet: {
          sequence: packet.sequence.toString(),
          source_port: packet.sourcePort,
          source_channel: packet.sourceChannel,
          destination_port: packet.destinationPort,
          destination_channel: packet.destinationChannel,
          data: packet.data,
          timeout_height: packet.timeoutHeight ? {
            revision_height: (_omitDefault21 = omitDefault(packet.timeoutHeight.revisionHeight)) === null || _omitDefault21 === void 0 ? void 0 : _omitDefault21.toString(),
            revision_number: (_omitDefault22 = omitDefault(packet.timeoutHeight.revisionNumber)) === null || _omitDefault22 === void 0 ? void 0 : _omitDefault22.toString()
          } : {},
          timeout_timestamp: packet.timeoutTimestamp.toString()
        },
        acknowledgement,
        proof_acked: proofAcked,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault23 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault23 === void 0 ? void 0 : _omitDefault23.toString(),
          revision_number: (_omitDefault24 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault24 === void 0 ? void 0 : _omitDefault24.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      packet,
      acknowledgement,
      proof_acked,
      proof_height,
      signer
    }) => {
      return {
        packet: {
          sequence: BigInt(packet.sequence),
          sourcePort: packet.source_port,
          sourceChannel: packet.source_channel,
          destinationPort: packet.destination_port,
          destinationChannel: packet.destination_channel,
          data: packet.data,
          timeoutHeight: packet.timeout_height ? {
            revisionHeight: BigInt(packet.timeout_height.revision_height || "0", true),
            revisionNumber: BigInt(packet.timeout_height.revision_number || "0", true)
          } : void 0,
          timeoutTimestamp: BigInt(packet.timeout_timestamp)
        },
        acknowledgement,
        proofAcked: proof_acked,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/client/v1/tx.amino.js
var tx_amino_exports26 = {};
__export(tx_amino_exports26, {
  AminoConverter: () => AminoConverter26
});
var AminoConverter26 = {
  "/ibc.core.client.v1.MsgCreateClient": {
    aminoType: "cosmos-sdk/MsgCreateClient",
    toAmino: ({
      clientState,
      consensusState,
      signer
    }) => {
      return {
        client_state: {
          type_url: clientState.typeUrl,
          value: clientState.value
        },
        consensus_state: {
          type_url: consensusState.typeUrl,
          value: consensusState.value
        },
        signer
      };
    },
    fromAmino: ({
      client_state,
      consensus_state,
      signer
    }) => {
      return {
        clientState: {
          typeUrl: client_state.type_url,
          value: client_state.value
        },
        consensusState: {
          typeUrl: consensus_state.type_url,
          value: consensus_state.value
        },
        signer
      };
    }
  },
  "/ibc.core.client.v1.MsgUpdateClient": {
    aminoType: "cosmos-sdk/MsgUpdateClient",
    toAmino: ({
      clientId,
      clientMessage,
      signer
    }) => {
      return {
        client_id: clientId,
        client_message: {
          type_url: clientMessage.typeUrl,
          value: clientMessage.value
        },
        signer
      };
    },
    fromAmino: ({
      client_id,
      client_message,
      signer
    }) => {
      return {
        clientId: client_id,
        clientMessage: {
          typeUrl: client_message.type_url,
          value: client_message.value
        },
        signer
      };
    }
  },
  "/ibc.core.client.v1.MsgUpgradeClient": {
    aminoType: "cosmos-sdk/MsgUpgradeClient",
    toAmino: ({
      clientId,
      clientState,
      consensusState,
      proofUpgradeClient,
      proofUpgradeConsensusState,
      signer
    }) => {
      return {
        client_id: clientId,
        client_state: {
          type_url: clientState.typeUrl,
          value: clientState.value
        },
        consensus_state: {
          type_url: consensusState.typeUrl,
          value: consensusState.value
        },
        proof_upgrade_client: proofUpgradeClient,
        proof_upgrade_consensus_state: proofUpgradeConsensusState,
        signer
      };
    },
    fromAmino: ({
      client_id,
      client_state,
      consensus_state,
      proof_upgrade_client,
      proof_upgrade_consensus_state,
      signer
    }) => {
      return {
        clientId: client_id,
        clientState: {
          typeUrl: client_state.type_url,
          value: client_state.value
        },
        consensusState: {
          typeUrl: consensus_state.type_url,
          value: consensus_state.value
        },
        proofUpgradeClient: proof_upgrade_client,
        proofUpgradeConsensusState: proof_upgrade_consensus_state,
        signer
      };
    }
  },
  "/ibc.core.client.v1.MsgSubmitMisbehaviour": {
    aminoType: "cosmos-sdk/MsgSubmitMisbehaviour",
    toAmino: ({
      clientId,
      misbehaviour,
      signer
    }) => {
      return {
        client_id: clientId,
        misbehaviour: {
          type_url: misbehaviour.typeUrl,
          value: misbehaviour.value
        },
        signer
      };
    },
    fromAmino: ({
      client_id,
      misbehaviour,
      signer
    }) => {
      return {
        clientId: client_id,
        misbehaviour: {
          typeUrl: misbehaviour.type_url,
          value: misbehaviour.value
        },
        signer
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/connection/v1/tx.amino.js
var tx_amino_exports27 = {};
__export(tx_amino_exports27, {
  AminoConverter: () => AminoConverter27
});
var AminoConverter27 = {
  "/ibc.core.connection.v1.MsgConnectionOpenInit": {
    aminoType: "cosmos-sdk/MsgConnectionOpenInit",
    toAmino: ({
      clientId,
      counterparty,
      version,
      delayPeriod,
      signer
    }) => {
      return {
        client_id: clientId,
        counterparty: {
          client_id: counterparty.clientId,
          connection_id: counterparty.connectionId,
          prefix: {
            key_prefix: counterparty.prefix.keyPrefix
          }
        },
        version: {
          identifier: version.identifier,
          features: version.features
        },
        delay_period: delayPeriod.toString(),
        signer
      };
    },
    fromAmino: ({
      client_id,
      counterparty,
      version,
      delay_period,
      signer
    }) => {
      return {
        clientId: client_id,
        counterparty: {
          clientId: counterparty.client_id,
          connectionId: counterparty.connection_id,
          prefix: {
            keyPrefix: counterparty.prefix.key_prefix
          }
        },
        version: {
          identifier: version.identifier,
          features: version.features
        },
        delayPeriod: BigInt(delay_period),
        signer
      };
    }
  },
  "/ibc.core.connection.v1.MsgConnectionOpenTry": {
    aminoType: "cosmos-sdk/MsgConnectionOpenTry",
    toAmino: ({
      clientId,
      previousConnectionId,
      clientState,
      counterparty,
      delayPeriod,
      counterpartyVersions,
      proofHeight,
      proofInit,
      proofClient,
      proofConsensus,
      consensusHeight,
      signer,
      hostConsensusStateProof
    }) => {
      var _omitDefault, _omitDefault2, _omitDefault3, _omitDefault4;
      return {
        client_id: clientId,
        previous_connection_id: previousConnectionId,
        client_state: {
          type_url: clientState.typeUrl,
          value: clientState.value
        },
        counterparty: {
          client_id: counterparty.clientId,
          connection_id: counterparty.connectionId,
          prefix: {
            key_prefix: counterparty.prefix.keyPrefix
          }
        },
        delay_period: delayPeriod.toString(),
        counterparty_versions: counterpartyVersions.map((el0) => ({
          identifier: el0.identifier,
          features: el0.features
        })),
        proof_height: proofHeight ? {
          revision_height: (_omitDefault = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault === void 0 ? void 0 : _omitDefault.toString(),
          revision_number: (_omitDefault2 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault2 === void 0 ? void 0 : _omitDefault2.toString()
        } : {},
        proof_init: proofInit,
        proof_client: proofClient,
        proof_consensus: proofConsensus,
        consensus_height: consensusHeight ? {
          revision_height: (_omitDefault3 = omitDefault(consensusHeight.revisionHeight)) === null || _omitDefault3 === void 0 ? void 0 : _omitDefault3.toString(),
          revision_number: (_omitDefault4 = omitDefault(consensusHeight.revisionNumber)) === null || _omitDefault4 === void 0 ? void 0 : _omitDefault4.toString()
        } : {},
        signer,
        host_consensus_state_proof: hostConsensusStateProof
      };
    },
    fromAmino: ({
      client_id,
      previous_connection_id,
      client_state,
      counterparty,
      delay_period,
      counterparty_versions,
      proof_height,
      proof_init,
      proof_client,
      proof_consensus,
      consensus_height,
      signer,
      host_consensus_state_proof
    }) => {
      return {
        clientId: client_id,
        previousConnectionId: previous_connection_id,
        clientState: {
          typeUrl: client_state.type_url,
          value: client_state.value
        },
        counterparty: {
          clientId: counterparty.client_id,
          connectionId: counterparty.connection_id,
          prefix: {
            keyPrefix: counterparty.prefix.key_prefix
          }
        },
        delayPeriod: BigInt(delay_period),
        counterpartyVersions: counterparty_versions.map((el0) => ({
          identifier: el0.identifier,
          features: el0.features
        })),
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        proofInit: proof_init,
        proofClient: proof_client,
        proofConsensus: proof_consensus,
        consensusHeight: consensus_height ? {
          revisionHeight: BigInt(consensus_height.revision_height || "0", true),
          revisionNumber: BigInt(consensus_height.revision_number || "0", true)
        } : void 0,
        signer,
        hostConsensusStateProof: host_consensus_state_proof
      };
    }
  },
  "/ibc.core.connection.v1.MsgConnectionOpenAck": {
    aminoType: "cosmos-sdk/MsgConnectionOpenAck",
    toAmino: ({
      connectionId,
      counterpartyConnectionId,
      version,
      clientState,
      proofHeight,
      proofTry,
      proofClient,
      proofConsensus,
      consensusHeight,
      signer,
      hostConsensusStateProof
    }) => {
      var _omitDefault5, _omitDefault6, _omitDefault7, _omitDefault8;
      return {
        connection_id: connectionId,
        counterparty_connection_id: counterpartyConnectionId,
        version: {
          identifier: version.identifier,
          features: version.features
        },
        client_state: {
          type_url: clientState.typeUrl,
          value: clientState.value
        },
        proof_height: proofHeight ? {
          revision_height: (_omitDefault5 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault5 === void 0 ? void 0 : _omitDefault5.toString(),
          revision_number: (_omitDefault6 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault6 === void 0 ? void 0 : _omitDefault6.toString()
        } : {},
        proof_try: proofTry,
        proof_client: proofClient,
        proof_consensus: proofConsensus,
        consensus_height: consensusHeight ? {
          revision_height: (_omitDefault7 = omitDefault(consensusHeight.revisionHeight)) === null || _omitDefault7 === void 0 ? void 0 : _omitDefault7.toString(),
          revision_number: (_omitDefault8 = omitDefault(consensusHeight.revisionNumber)) === null || _omitDefault8 === void 0 ? void 0 : _omitDefault8.toString()
        } : {},
        signer,
        host_consensus_state_proof: hostConsensusStateProof
      };
    },
    fromAmino: ({
      connection_id,
      counterparty_connection_id,
      version,
      client_state,
      proof_height,
      proof_try,
      proof_client,
      proof_consensus,
      consensus_height,
      signer,
      host_consensus_state_proof
    }) => {
      return {
        connectionId: connection_id,
        counterpartyConnectionId: counterparty_connection_id,
        version: {
          identifier: version.identifier,
          features: version.features
        },
        clientState: {
          typeUrl: client_state.type_url,
          value: client_state.value
        },
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        proofTry: proof_try,
        proofClient: proof_client,
        proofConsensus: proof_consensus,
        consensusHeight: consensus_height ? {
          revisionHeight: BigInt(consensus_height.revision_height || "0", true),
          revisionNumber: BigInt(consensus_height.revision_number || "0", true)
        } : void 0,
        signer,
        hostConsensusStateProof: host_consensus_state_proof
      };
    }
  },
  "/ibc.core.connection.v1.MsgConnectionOpenConfirm": {
    aminoType: "cosmos-sdk/MsgConnectionOpenConfirm",
    toAmino: ({
      connectionId,
      proofAck,
      proofHeight,
      signer
    }) => {
      var _omitDefault9, _omitDefault10;
      return {
        connection_id: connectionId,
        proof_ack: proofAck,
        proof_height: proofHeight ? {
          revision_height: (_omitDefault9 = omitDefault(proofHeight.revisionHeight)) === null || _omitDefault9 === void 0 ? void 0 : _omitDefault9.toString(),
          revision_number: (_omitDefault10 = omitDefault(proofHeight.revisionNumber)) === null || _omitDefault10 === void 0 ? void 0 : _omitDefault10.toString()
        } : {},
        signer
      };
    },
    fromAmino: ({
      connection_id,
      proof_ack,
      proof_height,
      signer
    }) => {
      return {
        connectionId: connection_id,
        proofAck: proof_ack,
        proofHeight: proof_height ? {
          revisionHeight: BigInt(proof_height.revision_height || "0", true),
          revisionNumber: BigInt(proof_height.revision_number || "0", true)
        } : void 0,
        signer
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/fee/v1/tx.registry.js
var tx_registry_exports22 = {};
__export(tx_registry_exports22, {
  MessageComposer: () => MessageComposer22,
  load: () => load22,
  registry: () => registry22
});
var registry22 = [["/ibc.applications.fee.v1.MsgRegisterPayee", MsgRegisterPayee], ["/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee", MsgRegisterCounterpartyPayee], ["/ibc.applications.fee.v1.MsgPayPacketFee", MsgPayPacketFee], ["/ibc.applications.fee.v1.MsgPayPacketFeeAsync", MsgPayPacketFeeAsync]];
var load22 = (protoRegistry) => {
  registry22.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer22 = {
  encoded: {
    registerPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterPayee",
        value: MsgRegisterPayee.encode(value).finish()
      };
    },
    registerCounterpartyPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee",
        value: MsgRegisterCounterpartyPayee.encode(value).finish()
      };
    },
    payPacketFee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFee",
        value: MsgPayPacketFee.encode(value).finish()
      };
    },
    payPacketFeeAsync(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFeeAsync",
        value: MsgPayPacketFeeAsync.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    registerPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterPayee",
        value
      };
    },
    registerCounterpartyPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee",
        value
      };
    },
    payPacketFee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFee",
        value
      };
    },
    payPacketFeeAsync(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFeeAsync",
        value
      };
    }
  },
  toJSON: {
    registerPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterPayee",
        value: MsgRegisterPayee.toJSON(value)
      };
    },
    registerCounterpartyPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee",
        value: MsgRegisterCounterpartyPayee.toJSON(value)
      };
    },
    payPacketFee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFee",
        value: MsgPayPacketFee.toJSON(value)
      };
    },
    payPacketFeeAsync(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFeeAsync",
        value: MsgPayPacketFeeAsync.toJSON(value)
      };
    }
  },
  fromJSON: {
    registerPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterPayee",
        value: MsgRegisterPayee.fromJSON(value)
      };
    },
    registerCounterpartyPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee",
        value: MsgRegisterCounterpartyPayee.fromJSON(value)
      };
    },
    payPacketFee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFee",
        value: MsgPayPacketFee.fromJSON(value)
      };
    },
    payPacketFeeAsync(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFeeAsync",
        value: MsgPayPacketFeeAsync.fromJSON(value)
      };
    }
  },
  fromPartial: {
    registerPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterPayee",
        value: MsgRegisterPayee.fromPartial(value)
      };
    },
    registerCounterpartyPayee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee",
        value: MsgRegisterCounterpartyPayee.fromPartial(value)
      };
    },
    payPacketFee(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFee",
        value: MsgPayPacketFee.fromPartial(value)
      };
    },
    payPacketFeeAsync(value) {
      return {
        typeUrl: "/ibc.applications.fee.v1.MsgPayPacketFeeAsync",
        value: MsgPayPacketFeeAsync.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/interchain_accounts/controller/v1/tx.registry.js
var tx_registry_exports23 = {};
__export(tx_registry_exports23, {
  MessageComposer: () => MessageComposer23,
  load: () => load23,
  registry: () => registry23
});
var registry23 = [["/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount", MsgRegisterInterchainAccount], ["/ibc.applications.interchain_accounts.controller.v1.MsgSendTx", MsgSendTx]];
var load23 = (protoRegistry) => {
  registry23.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer23 = {
  encoded: {
    registerInterchainAccount(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
        value: MsgRegisterInterchainAccount.encode(value).finish()
      };
    },
    sendTx(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
        value: MsgSendTx.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    registerInterchainAccount(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
        value
      };
    },
    sendTx(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
        value
      };
    }
  },
  toJSON: {
    registerInterchainAccount(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
        value: MsgRegisterInterchainAccount.toJSON(value)
      };
    },
    sendTx(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
        value: MsgSendTx.toJSON(value)
      };
    }
  },
  fromJSON: {
    registerInterchainAccount(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
        value: MsgRegisterInterchainAccount.fromJSON(value)
      };
    },
    sendTx(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
        value: MsgSendTx.fromJSON(value)
      };
    }
  },
  fromPartial: {
    registerInterchainAccount(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
        value: MsgRegisterInterchainAccount.fromPartial(value)
      };
    },
    sendTx(value) {
      return {
        typeUrl: "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
        value: MsgSendTx.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/applications/transfer/v1/tx.registry.js
var tx_registry_exports24 = {};
__export(tx_registry_exports24, {
  MessageComposer: () => MessageComposer24,
  load: () => load24,
  registry: () => registry24
});
var registry24 = [["/ibc.applications.transfer.v1.MsgTransfer", MsgTransfer]];
var load24 = (protoRegistry) => {
  registry24.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer24 = {
  encoded: {
    transfer(value) {
      return {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: MsgTransfer.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    transfer(value) {
      return {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value
      };
    }
  },
  toJSON: {
    transfer(value) {
      return {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: MsgTransfer.toJSON(value)
      };
    }
  },
  fromJSON: {
    transfer(value) {
      return {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: MsgTransfer.fromJSON(value)
      };
    }
  },
  fromPartial: {
    transfer(value) {
      return {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: MsgTransfer.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/channel/v1/tx.registry.js
var tx_registry_exports25 = {};
__export(tx_registry_exports25, {
  MessageComposer: () => MessageComposer25,
  load: () => load25,
  registry: () => registry25
});
var registry25 = [["/ibc.core.channel.v1.MsgChannelOpenInit", MsgChannelOpenInit], ["/ibc.core.channel.v1.MsgChannelOpenTry", MsgChannelOpenTry], ["/ibc.core.channel.v1.MsgChannelOpenAck", MsgChannelOpenAck], ["/ibc.core.channel.v1.MsgChannelOpenConfirm", MsgChannelOpenConfirm], ["/ibc.core.channel.v1.MsgChannelCloseInit", MsgChannelCloseInit], ["/ibc.core.channel.v1.MsgChannelCloseConfirm", MsgChannelCloseConfirm], ["/ibc.core.channel.v1.MsgRecvPacket", MsgRecvPacket], ["/ibc.core.channel.v1.MsgTimeout", MsgTimeout], ["/ibc.core.channel.v1.MsgTimeoutOnClose", MsgTimeoutOnClose], ["/ibc.core.channel.v1.MsgAcknowledgement", MsgAcknowledgement]];
var load25 = (protoRegistry) => {
  registry25.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer25 = {
  encoded: {
    channelOpenInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
        value: MsgChannelOpenInit.encode(value).finish()
      };
    },
    channelOpenTry(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
        value: MsgChannelOpenTry.encode(value).finish()
      };
    },
    channelOpenAck(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
        value: MsgChannelOpenAck.encode(value).finish()
      };
    },
    channelOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        value: MsgChannelOpenConfirm.encode(value).finish()
      };
    },
    channelCloseInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
        value: MsgChannelCloseInit.encode(value).finish()
      };
    },
    channelCloseConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        value: MsgChannelCloseConfirm.encode(value).finish()
      };
    },
    recvPacket(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
        value: MsgRecvPacket.encode(value).finish()
      };
    },
    timeout(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeout",
        value: MsgTimeout.encode(value).finish()
      };
    },
    timeoutOnClose(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
        value: MsgTimeoutOnClose.encode(value).finish()
      };
    },
    acknowledgement(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
        value: MsgAcknowledgement.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    channelOpenInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
        value
      };
    },
    channelOpenTry(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
        value
      };
    },
    channelOpenAck(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
        value
      };
    },
    channelOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        value
      };
    },
    channelCloseInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
        value
      };
    },
    channelCloseConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        value
      };
    },
    recvPacket(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
        value
      };
    },
    timeout(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeout",
        value
      };
    },
    timeoutOnClose(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
        value
      };
    },
    acknowledgement(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
        value
      };
    }
  },
  toJSON: {
    channelOpenInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
        value: MsgChannelOpenInit.toJSON(value)
      };
    },
    channelOpenTry(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
        value: MsgChannelOpenTry.toJSON(value)
      };
    },
    channelOpenAck(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
        value: MsgChannelOpenAck.toJSON(value)
      };
    },
    channelOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        value: MsgChannelOpenConfirm.toJSON(value)
      };
    },
    channelCloseInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
        value: MsgChannelCloseInit.toJSON(value)
      };
    },
    channelCloseConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        value: MsgChannelCloseConfirm.toJSON(value)
      };
    },
    recvPacket(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
        value: MsgRecvPacket.toJSON(value)
      };
    },
    timeout(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeout",
        value: MsgTimeout.toJSON(value)
      };
    },
    timeoutOnClose(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
        value: MsgTimeoutOnClose.toJSON(value)
      };
    },
    acknowledgement(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
        value: MsgAcknowledgement.toJSON(value)
      };
    }
  },
  fromJSON: {
    channelOpenInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
        value: MsgChannelOpenInit.fromJSON(value)
      };
    },
    channelOpenTry(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
        value: MsgChannelOpenTry.fromJSON(value)
      };
    },
    channelOpenAck(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
        value: MsgChannelOpenAck.fromJSON(value)
      };
    },
    channelOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        value: MsgChannelOpenConfirm.fromJSON(value)
      };
    },
    channelCloseInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
        value: MsgChannelCloseInit.fromJSON(value)
      };
    },
    channelCloseConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        value: MsgChannelCloseConfirm.fromJSON(value)
      };
    },
    recvPacket(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
        value: MsgRecvPacket.fromJSON(value)
      };
    },
    timeout(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeout",
        value: MsgTimeout.fromJSON(value)
      };
    },
    timeoutOnClose(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
        value: MsgTimeoutOnClose.fromJSON(value)
      };
    },
    acknowledgement(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
        value: MsgAcknowledgement.fromJSON(value)
      };
    }
  },
  fromPartial: {
    channelOpenInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
        value: MsgChannelOpenInit.fromPartial(value)
      };
    },
    channelOpenTry(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
        value: MsgChannelOpenTry.fromPartial(value)
      };
    },
    channelOpenAck(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
        value: MsgChannelOpenAck.fromPartial(value)
      };
    },
    channelOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        value: MsgChannelOpenConfirm.fromPartial(value)
      };
    },
    channelCloseInit(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
        value: MsgChannelCloseInit.fromPartial(value)
      };
    },
    channelCloseConfirm(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        value: MsgChannelCloseConfirm.fromPartial(value)
      };
    },
    recvPacket(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
        value: MsgRecvPacket.fromPartial(value)
      };
    },
    timeout(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeout",
        value: MsgTimeout.fromPartial(value)
      };
    },
    timeoutOnClose(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
        value: MsgTimeoutOnClose.fromPartial(value)
      };
    },
    acknowledgement(value) {
      return {
        typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
        value: MsgAcknowledgement.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/client/v1/tx.registry.js
var tx_registry_exports26 = {};
__export(tx_registry_exports26, {
  MessageComposer: () => MessageComposer26,
  load: () => load26,
  registry: () => registry26
});
var registry26 = [["/ibc.core.client.v1.MsgCreateClient", MsgCreateClient], ["/ibc.core.client.v1.MsgUpdateClient", MsgUpdateClient], ["/ibc.core.client.v1.MsgUpgradeClient", MsgUpgradeClient], ["/ibc.core.client.v1.MsgSubmitMisbehaviour", MsgSubmitMisbehaviour]];
var load26 = (protoRegistry) => {
  registry26.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer26 = {
  encoded: {
    createClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgCreateClient",
        value: MsgCreateClient.encode(value).finish()
      };
    },
    updateClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
        value: MsgUpdateClient.encode(value).finish()
      };
    },
    upgradeClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
        value: MsgUpgradeClient.encode(value).finish()
      };
    },
    submitMisbehaviour(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        value: MsgSubmitMisbehaviour.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    createClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgCreateClient",
        value
      };
    },
    updateClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
        value
      };
    },
    upgradeClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
        value
      };
    },
    submitMisbehaviour(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        value
      };
    }
  },
  toJSON: {
    createClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgCreateClient",
        value: MsgCreateClient.toJSON(value)
      };
    },
    updateClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
        value: MsgUpdateClient.toJSON(value)
      };
    },
    upgradeClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
        value: MsgUpgradeClient.toJSON(value)
      };
    },
    submitMisbehaviour(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        value: MsgSubmitMisbehaviour.toJSON(value)
      };
    }
  },
  fromJSON: {
    createClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgCreateClient",
        value: MsgCreateClient.fromJSON(value)
      };
    },
    updateClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
        value: MsgUpdateClient.fromJSON(value)
      };
    },
    upgradeClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
        value: MsgUpgradeClient.fromJSON(value)
      };
    },
    submitMisbehaviour(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        value: MsgSubmitMisbehaviour.fromJSON(value)
      };
    }
  },
  fromPartial: {
    createClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgCreateClient",
        value: MsgCreateClient.fromPartial(value)
      };
    },
    updateClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
        value: MsgUpdateClient.fromPartial(value)
      };
    },
    upgradeClient(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
        value: MsgUpgradeClient.fromPartial(value)
      };
    },
    submitMisbehaviour(value) {
      return {
        typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        value: MsgSubmitMisbehaviour.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/core/connection/v1/tx.registry.js
var tx_registry_exports27 = {};
__export(tx_registry_exports27, {
  MessageComposer: () => MessageComposer27,
  load: () => load27,
  registry: () => registry27
});
var registry27 = [["/ibc.core.connection.v1.MsgConnectionOpenInit", MsgConnectionOpenInit], ["/ibc.core.connection.v1.MsgConnectionOpenTry", MsgConnectionOpenTry], ["/ibc.core.connection.v1.MsgConnectionOpenAck", MsgConnectionOpenAck], ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", MsgConnectionOpenConfirm]];
var load27 = (protoRegistry) => {
  registry27.forEach(([typeUrl, mod]) => {
    protoRegistry.register(typeUrl, mod);
  });
};
var MessageComposer27 = {
  encoded: {
    connectionOpenInit(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
        value: MsgConnectionOpenInit.encode(value).finish()
      };
    },
    connectionOpenTry(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
        value: MsgConnectionOpenTry.encode(value).finish()
      };
    },
    connectionOpenAck(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
        value: MsgConnectionOpenAck.encode(value).finish()
      };
    },
    connectionOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        value: MsgConnectionOpenConfirm.encode(value).finish()
      };
    }
  },
  withTypeUrl: {
    connectionOpenInit(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
        value
      };
    },
    connectionOpenTry(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
        value
      };
    },
    connectionOpenAck(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
        value
      };
    },
    connectionOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        value
      };
    }
  },
  toJSON: {
    connectionOpenInit(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
        value: MsgConnectionOpenInit.toJSON(value)
      };
    },
    connectionOpenTry(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
        value: MsgConnectionOpenTry.toJSON(value)
      };
    },
    connectionOpenAck(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
        value: MsgConnectionOpenAck.toJSON(value)
      };
    },
    connectionOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        value: MsgConnectionOpenConfirm.toJSON(value)
      };
    }
  },
  fromJSON: {
    connectionOpenInit(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
        value: MsgConnectionOpenInit.fromJSON(value)
      };
    },
    connectionOpenTry(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
        value: MsgConnectionOpenTry.fromJSON(value)
      };
    },
    connectionOpenAck(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
        value: MsgConnectionOpenAck.fromJSON(value)
      };
    },
    connectionOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        value: MsgConnectionOpenConfirm.fromJSON(value)
      };
    }
  },
  fromPartial: {
    connectionOpenInit(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
        value: MsgConnectionOpenInit.fromPartial(value)
      };
    },
    connectionOpenTry(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
        value: MsgConnectionOpenTry.fromPartial(value)
      };
    },
    connectionOpenAck(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
        value: MsgConnectionOpenAck.fromPartial(value)
      };
    },
    connectionOpenConfirm(value) {
      return {
        typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        value: MsgConnectionOpenConfirm.fromPartial(value)
      };
    }
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/rpc.query.js
var rpc_query_exports4 = {};
__export(rpc_query_exports4, {
  createRPCQueryClient: () => createRPCQueryClient4
});
var import_tendermint_rpc4 = __toESM(require_build7());
var import_stargate7 = __toESM(require_build8());
var createRPCQueryClient4 = async ({
  rpcEndpoint
}) => {
  const tmClient = await import_tendermint_rpc4.Tendermint34Client.connect(rpcEndpoint);
  const client = new import_stargate7.QueryClient(tmClient);
  return {
    cosmos: {
      app: {
        v1alpha1: (await import("./query.rpc.Query-Z645J2C5.js")).createRpcQueryExtension(client)
      },
      auth: {
        v1beta1: (await import("./query.rpc.Query-HSLFEKVN.js")).createRpcQueryExtension(client)
      },
      authz: {
        v1beta1: (await import("./query.rpc.Query-VOBALZII.js")).createRpcQueryExtension(client)
      },
      autocli: {
        v1: (await import("./query.rpc.Query-3ECKZXP6.js")).createRpcQueryExtension(client)
      },
      bank: {
        v1beta1: (await import("./query.rpc.Query-IKLKUQBX.js")).createRpcQueryExtension(client)
      },
      base: {
        node: {
          v1beta1: (await import("./query.rpc.Service-OGSDUVYD.js")).createRpcQueryExtension(client)
        },
        tendermint: {
          v1beta1: (await import("./query.rpc.Service-UMVNZL3P.js")).createRpcQueryExtension(client)
        }
      },
      consensus: {
        v1: (await import("./query.rpc.Query-3VII2VNJ.js")).createRpcQueryExtension(client)
      },
      distribution: {
        v1beta1: (await import("./query.rpc.Query-OHEFBXHH.js")).createRpcQueryExtension(client)
      },
      evidence: {
        v1beta1: (await import("./query.rpc.Query-XMO4CSIX.js")).createRpcQueryExtension(client)
      },
      feegrant: {
        v1beta1: (await import("./query.rpc.Query-75IUKG33.js")).createRpcQueryExtension(client)
      },
      gov: {
        v1: (await import("./query.rpc.Query-4R3ETNBS.js")).createRpcQueryExtension(client),
        v1beta1: (await import("./query.rpc.Query-LMLDHT3F.js")).createRpcQueryExtension(client)
      },
      group: {
        v1: (await import("./query.rpc.Query-YAFZXBYA.js")).createRpcQueryExtension(client)
      },
      mint: {
        v1beta1: (await import("./query.rpc.Query-HMTMFHXZ.js")).createRpcQueryExtension(client)
      },
      nft: {
        v1beta1: (await import("./query.rpc.Query-FGSDCMTH.js")).createRpcQueryExtension(client)
      },
      orm: {
        query: {
          v1alpha1: (await import("./query.rpc.Query-PE7Q6FYK.js")).createRpcQueryExtension(client)
        }
      },
      params: {
        v1beta1: (await import("./query.rpc.Query-AEFB4JOF.js")).createRpcQueryExtension(client)
      },
      slashing: {
        v1beta1: (await import("./query.rpc.Query-S22SWOLR.js")).createRpcQueryExtension(client)
      },
      staking: {
        v1beta1: (await import("./query.rpc.Query-5LB62TJJ.js")).createRpcQueryExtension(client)
      },
      tx: {
        v1beta1: (await import("./service.rpc.Service-5OSPDZTY.js")).createRpcQueryExtension(client)
      },
      upgrade: {
        v1beta1: (await import("./query.rpc.Query-MKAFUIMA.js")).createRpcQueryExtension(client)
      }
    },
    ibc: {
      applications: {
        fee: {
          v1: (await import("./query.rpc.Query-I544DTKS.js")).createRpcQueryExtension(client)
        },
        interchain_accounts: {
          controller: {
            v1: (await import("./query.rpc.Query-QWZ2MOOE.js")).createRpcQueryExtension(client)
          },
          host: {
            v1: (await import("./query.rpc.Query-BGMDWOKK.js")).createRpcQueryExtension(client)
          }
        },
        transfer: {
          v1: (await import("./query.rpc.Query-E5AVZZ3D.js")).createRpcQueryExtension(client)
        }
      },
      core: {
        channel: {
          v1: (await import("./query.rpc.Query-I5OKPDVF.js")).createRpcQueryExtension(client)
        },
        client: {
          v1: (await import("./query.rpc.Query-37DAIN4G.js")).createRpcQueryExtension(client)
        },
        connection: {
          v1: (await import("./query.rpc.Query-S4DD3S2V.js")).createRpcQueryExtension(client)
        }
      }
    }
  };
};

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/rpc.tx.js
var rpc_tx_exports4 = {};
__export(rpc_tx_exports4, {
  createRPCMsgClient: () => createRPCMsgClient4
});
var createRPCMsgClient4 = async ({
  rpc
}) => ({
  cosmos: {
    auth: {
      v1beta1: new (await import("./tx.rpc.msg-BKM7GIDF.js")).MsgClientImpl(rpc)
    },
    authz: {
      v1beta1: new (await import("./tx.rpc.msg-4IOFIOJT.js")).MsgClientImpl(rpc)
    },
    bank: {
      v1beta1: new (await import("./tx.rpc.msg-GY3AG57M.js")).MsgClientImpl(rpc)
    },
    consensus: {
      v1: new (await import("./tx.rpc.msg-7IS2XNHP.js")).MsgClientImpl(rpc)
    },
    crisis: {
      v1beta1: new (await import("./tx.rpc.msg-2P7C25FF.js")).MsgClientImpl(rpc)
    },
    distribution: {
      v1beta1: new (await import("./tx.rpc.msg-5N6UVCQE.js")).MsgClientImpl(rpc)
    },
    evidence: {
      v1beta1: new (await import("./tx.rpc.msg-AIXRTESQ.js")).MsgClientImpl(rpc)
    },
    feegrant: {
      v1beta1: new (await import("./tx.rpc.msg-F3E4UQKA.js")).MsgClientImpl(rpc)
    },
    gov: {
      v1: new (await import("./tx.rpc.msg-EPAYKNRX.js")).MsgClientImpl(rpc),
      v1beta1: new (await import("./tx.rpc.msg-WTSROBNU.js")).MsgClientImpl(rpc)
    },
    group: {
      v1: new (await import("./tx.rpc.msg-3CXHGTHS.js")).MsgClientImpl(rpc)
    },
    mint: {
      v1beta1: new (await import("./tx.rpc.msg-7L6KBKRN.js")).MsgClientImpl(rpc)
    },
    nft: {
      v1beta1: new (await import("./tx.rpc.msg-PDAZEZ2U.js")).MsgClientImpl(rpc)
    },
    slashing: {
      v1beta1: new (await import("./tx.rpc.msg-GQQ4TSDM.js")).MsgClientImpl(rpc)
    },
    staking: {
      v1beta1: new (await import("./tx.rpc.msg-2OHK3UTX.js")).MsgClientImpl(rpc)
    },
    upgrade: {
      v1beta1: new (await import("./tx.rpc.msg-FXRHAFBV.js")).MsgClientImpl(rpc)
    },
    vesting: {
      v1beta1: new (await import("./tx.rpc.msg-DIHQBATM.js")).MsgClientImpl(rpc)
    }
  },
  ibc: {
    applications: {
      fee: {
        v1: new (await import("./tx.rpc.msg-Q25SQP3N.js")).MsgClientImpl(rpc)
      },
      interchain_accounts: {
        controller: {
          v1: new (await import("./tx.rpc.msg-QP54RV25.js")).MsgClientImpl(rpc)
        }
      },
      transfer: {
        v1: new (await import("./tx.rpc.msg-ZMP6EUC4.js")).MsgClientImpl(rpc)
      }
    },
    core: {
      channel: {
        v1: new (await import("./tx.rpc.msg-5XXPKCLV.js")).MsgClientImpl(rpc)
      },
      client: {
        v1: new (await import("./tx.rpc.msg-HKP6SJ5W.js")).MsgClientImpl(rpc)
      },
      connection: {
        v1: new (await import("./tx.rpc.msg-C377A2KC.js")).MsgClientImpl(rpc)
      }
    }
  }
});

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/bundle.js
function ownKeys11(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread11(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys11(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys11(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ibc;
(function(_ibc) {
  let applications;
  (function(_applications) {
    let fee;
    (function(_fee) {
      const v1 = _fee.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, ack_exports), fee_exports), genesis_exports), metadata_exports), query_exports26), tx_exports23), tx_amino_exports22), tx_registry_exports22), query_rpc_Query_exports24), tx_rpc_msg_exports22);
    })(fee || (fee = _applications.fee || (_applications.fee = {})));
    let interchain_accounts;
    (function(_interchain_accounts) {
      let controller;
      (function(_controller) {
        const v12 = _controller.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, controller_exports), query_exports27), tx_exports24), tx_amino_exports23), tx_registry_exports23), query_rpc_Query_exports25), tx_rpc_msg_exports23);
      })(controller || (controller = _interchain_accounts.controller || (_interchain_accounts.controller = {})));
      let genesis;
      (function(_genesis) {
        const v12 = _genesis.v1 = _objectSpread11({}, genesis_exports22);
      })(genesis || (genesis = _interchain_accounts.genesis || (_interchain_accounts.genesis = {})));
      let host;
      (function(_host) {
        const v12 = _host.v1 = _objectSpread11(_objectSpread11(_objectSpread11({}, host_exports), query_exports28), query_rpc_Query_exports26);
      })(host || (host = _interchain_accounts.host || (_interchain_accounts.host = {})));
      const v1 = _interchain_accounts.v1 = _objectSpread11(_objectSpread11(_objectSpread11({}, account_exports), metadata_exports2), packet_exports);
    })(interchain_accounts || (interchain_accounts = _applications.interchain_accounts || (_applications.interchain_accounts = {})));
    let transfer;
    (function(_transfer) {
      const v1 = _transfer.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, authz_exports6), genesis_exports23), query_exports29), transfer_exports), tx_exports25), tx_amino_exports24), tx_registry_exports24), query_rpc_Query_exports27), tx_rpc_msg_exports24);
      const v2 = _transfer.v2 = _objectSpread11({}, packet_exports2);
    })(transfer || (transfer = _applications.transfer || (_applications.transfer = {})));
  })(applications || (applications = _ibc.applications || (_ibc.applications = {})));
  let core;
  (function(_core) {
    let channel;
    (function(_channel) {
      const v1 = _channel.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, channel_exports), genesis_exports24), query_exports30), tx_exports26), tx_amino_exports25), tx_registry_exports25), query_rpc_Query_exports28), tx_rpc_msg_exports25);
    })(channel || (channel = _core.channel || (_core.channel = {})));
    let client;
    (function(_client) {
      const v1 = _client.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, client_exports), genesis_exports25), query_exports31), tx_exports27), tx_amino_exports26), tx_registry_exports26), query_rpc_Query_exports29), tx_rpc_msg_exports26);
    })(client || (client = _core.client || (_core.client = {})));
    let commitment;
    (function(_commitment) {
      const v1 = _commitment.v1 = _objectSpread11({}, commitment_exports);
    })(commitment || (commitment = _core.commitment || (_core.commitment = {})));
    let connection;
    (function(_connection) {
      const v1 = _connection.v1 = _objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11(_objectSpread11({}, connection_exports), genesis_exports26), query_exports32), tx_exports28), tx_amino_exports27), tx_registry_exports27), query_rpc_Query_exports30), tx_rpc_msg_exports27);
    })(connection || (connection = _core.connection || (_core.connection = {})));
    let types;
    (function(_types) {
      const v1 = _types.v1 = _objectSpread11({}, genesis_exports27);
    })(types || (types = _core.types || (_core.types = {})));
  })(core || (core = _ibc.core || (_ibc.core = {})));
  let lightclients;
  (function(_lightclients) {
    let solomachine;
    (function(_solomachine) {
      const v2 = _solomachine.v2 = _objectSpread11({}, solomachine_exports);
      const v3 = _solomachine.v3 = _objectSpread11({}, solomachine_exports2);
    })(solomachine || (solomachine = _lightclients.solomachine || (_lightclients.solomachine = {})));
    let tendermint2;
    (function(_tendermint) {
      const v1 = _tendermint.v1 = _objectSpread11({}, tendermint_exports);
    })(tendermint2 || (tendermint2 = _lightclients.tendermint || (_lightclients.tendermint = {})));
  })(lightclients || (lightclients = _ibc.lightclients || (_ibc.lightclients = {})));
  const ClientFactory = _ibc.ClientFactory = _objectSpread11(_objectSpread11({}, rpc_query_exports4), rpc_tx_exports4);
})(ibc || (ibc = {}));

// node_modules/@empower-plastic/empowerjs/module/codegen/ibc/client.js
var import_proto_signing4 = __toESM(require_build6());
var import_stargate8 = __toESM(require_build8());
function ownKeys12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ibcAminoConverters = _objectSpread12(_objectSpread12(_objectSpread12(_objectSpread12(_objectSpread12(_objectSpread12({}, AminoConverter22), AminoConverter23), AminoConverter24), AminoConverter25), AminoConverter26), AminoConverter27);
var ibcProtoRegistry = [...registry22, ...registry23, ...registry24, ...registry25, ...registry26, ...registry27];
var getSigningIbcClientOptions = ({
  defaultTypes = import_stargate8.defaultRegistryTypes
} = {}) => {
  const registry28 = new import_proto_signing4.Registry([...defaultTypes, ...ibcProtoRegistry]);
  const aminoTypes = new import_stargate8.AminoTypes(_objectSpread12({}, ibcAminoConverters));
  return {
    registry: registry28,
    aminoTypes
  };
};
var getSigningIbcClient = async ({
  rpcEndpoint,
  signer,
  defaultTypes = import_stargate8.defaultRegistryTypes
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningIbcClientOptions({
    defaultTypes
  });
  const client = await import_stargate8.SigningStargateClient.connectWithSigner(rpcEndpoint, signer, {
    registry: registry28,
    aminoTypes
  });
  return client;
};

// node_modules/@empower-plastic/empowerjs/module/codegen/tendermint/libs/bits/types.js
var types_exports11 = {};
__export(types_exports11, {
  BitArray: () => BitArray
});
var _m092 = __toESM(require_minimal());
function createBaseBitArray() {
  return {
    bits: BigInt("0"),
    elems: []
  };
}
var BitArray = {
  encode(message, writer = _m092.Writer.create()) {
    if (message.bits !== BigInt(0)) {
      writer.uint32(8).int64(import_long.default.fromString(message.bits.toString()));
    }
    writer.uint32(18).fork();
    for (const v of message.elems) {
      writer.uint64(import_long.default.fromString(v.toString()));
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m092.Reader ? input : new _m092.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBitArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bits = BigInt(reader.int64().toString());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.elems.push(BigInt(reader.uint64().toString()));
            }
          } else {
            message.elems.push(BigInt(reader.uint64().toString()));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bits: isSet(object.bits) ? BigInt(object.bits.toString()) : BigInt("0"),
      elems: Array.isArray(object === null || object === void 0 ? void 0 : object.elems) ? object.elems.map((e) => BigInt(e.toString())) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bits !== void 0 && (obj.bits = (message.bits || BigInt("0")).toString());
    if (message.elems) {
      obj.elems = message.elems.map((e) => (e || BigInt("0")).toString());
    } else {
      obj.elems = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _object$elems;
    const message = createBaseBitArray();
    message.bits = object.bits !== void 0 && object.bits !== null ? BigInt(object.bits.toString()) : BigInt("0");
    message.elems = ((_object$elems = object.elems) === null || _object$elems === void 0 ? void 0 : _object$elems.map((e) => BigInt(e.toString()))) || [];
    return message;
  }
};

// node_modules/@empower-plastic/empowerjs/module/codegen/tendermint/bundle.js
function ownKeys13(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread13(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys13(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys13(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var tendermint;
(function(_tendermint) {
  const abci = _tendermint.abci = _objectSpread13({}, types_exports3);
  const crypto = _tendermint.crypto = _objectSpread13(_objectSpread13({}, keys_exports), proof_exports);
  let libs;
  (function(_libs) {
    const bits = _libs.bits = _objectSpread13({}, types_exports11);
  })(libs || (libs = _tendermint.libs || (_tendermint.libs = {})));
  const p2p = _tendermint.p2p = _objectSpread13({}, types_exports5);
  const types = _tendermint.types = _objectSpread13(_objectSpread13(_objectSpread13(_objectSpread13(_objectSpread13({}, block_exports), evidence_exports), params_exports), types_exports2), validator_exports);
  const version = _tendermint.version = _objectSpread13({}, types_exports);
})(tendermint || (tendermint = {}));

// node_modules/@empower-plastic/empowerjs/module/plastic-credit-utils/empower-data-creator.js
var import_jsonschema = __toESM(require_lib());
var PlasticCreditBuilder = class {
  constructor() {
    _defineProperty(this, "creditEventsData", void 0);
    _defineProperty(this, "creditMediaData", void 0);
    _defineProperty(this, "creditFilesData", void 0);
    _defineProperty(this, "issuanceDate", void 0);
    _defineProperty(this, "creditType", void 0);
    _defineProperty(this, "applicantData", void 0);
    this.reset();
  }
  addCreditEventData(creditEventData) {
    this.creditEventsData.content.push(creditEventData);
    return this;
  }
  addCreditMediaData(files) {
    this.creditMediaData.content = files;
    return this;
  }
  addCreditFilesData(files) {
    this.creditFilesData.content = files;
    return this;
  }
  setIssuanceDate(issuanceDate) {
    this.issuanceDate = issuanceDate;
    return this;
  }
  setCreditType(creditType) {
    this.creditType = creditType;
    return this;
  }
  setApplicantData(applicantData) {
    this.applicantData = applicantData;
    return this;
  }
  build() {
    if (!this.creditEventsData.content.length) {
      throw new Error("Credit events data is required");
    }
    if (!this.creditMediaData.content.length) {
      throw new Error("Credit media data is required");
    }
    if (!this.creditFilesData.content.length) {
      throw new Error("Credit files data is required");
    }
    if (!this.issuanceDate) {
      throw new Error("Issuance date is required");
    }
    if (!this.creditType) {
      throw new Error("Credit type is required");
    }
    if (!this.applicantData) {
      throw new Error("Applicant data is required");
    }
    const result = {
      version: "v1",
      credit_props: [this.creditEventsData, this.creditMediaData, this.creditFilesData, {
        id: "issuance_date",
        type: "date",
        content: this.issuanceDate.toISOString()
      }, {
        id: "credit_type",
        type: "text",
        content: this.creditType
      }, this.applicantData]
    };
    const schemaValidator = new import_jsonschema.default.Validator();
    const schema = require_empower_data_format_schema();
    const validationResult = schemaValidator.validate(result, schema);
    if (validationResult.errors.length) {
      let errors = "";
      for (let error of validationResult.errors) {
        errors += error.stack + "\n";
      }
      throw new Error("Invalid data format:\n" + errors);
    }
    return result;
  }
  reset() {
    this.creditEventsData = {
      id: "credit_events_data",
      type: "empower_credit_events_data",
      content: []
    };
    this.creditMediaData = {
      id: "credit_media",
      type: "file_list",
      content: []
    };
    this.creditFilesData = {
      id: "credit_files",
      type: "file_list",
      content: []
    };
    this.issuanceDate = null;
    this.creditType = "";
    this.applicantData = {};
  }
};
var EventBuilder = class {
  constructor() {
    _defineProperty(this, "location", void 0);
    _defineProperty(this, "amount", void 0);
    _defineProperty(this, "magnitude", void 0);
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "registrationDate", void 0);
    this.reset();
  }
  setLocation(location) {
    this.location = location;
    return this;
  }
  setAmount(amount) {
    this.amount = amount;
    return this;
  }
  setMagnitude(magnitude) {
    this.magnitude = magnitude;
    return this;
  }
  setMaterial(material) {
    this.material = material;
    return this;
  }
  setRegistrationDate(registrationDate) {
    this.registrationDate = registrationDate;
    return this;
  }
  build() {
    if (!this.location.latitude || !this.location.longitude) {
      throw new Error("Location is required");
    }
    if (!this.amount) {
      throw new Error("Amount is required");
    }
    if (!this.magnitude) {
      throw new Error("Magnitude is required");
    }
    if (this.material.length == 0) {
      throw new Error("Material is required");
    }
    if (!this.registrationDate) {
      throw new Error("Registration date is required");
    }
    return {
      id: "event_data",
      type: "empower_event_data",
      content: [{
        id: "location",
        type: "coordinates",
        content: {
          latitude: this.location.latitude,
          longitude: this.location.longitude
        }
      }, {
        id: "amount",
        type: "number",
        content: this.amount
      }, {
        id: "magnitude",
        type: "text",
        content: this.magnitude
      }, {
        id: "material",
        type: "property_map",
        content: this.material
      }, {
        id: "registration_date",
        type: "date",
        content: this.registrationDate.toISOString()
      }]
    };
  }
  reset() {
    this.location = {};
    this.amount = 0;
    this.magnitude = "";
    this.material = [];
    this.registrationDate = null;
  }
};
var ApplicantBuilder = class {
  constructor() {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "description", void 0);
    _defineProperty(this, "web_refs", void 0);
    this.reset();
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setDescription(description) {
    this.description = description;
    return this;
  }
  setWebRefs(webRefs) {
    this.web_refs = webRefs;
    return this;
  }
  build() {
    if (!this.name) {
      throw new Error("Name is required");
    }
    if (!this.description) {
      throw new Error("Description is required");
    }
    return {
      id: "applicant_data",
      type: "empower_applicant_data",
      content: {
        name: this.name,
        description: this.description,
        web_refs: this.web_refs
      }
    };
  }
  reset() {
    this.name = "";
    this.description = "";
    this.web_refs = [];
  }
};
var MaterialPropertyBuilder = class {
  constructor() {
    _defineProperty(this, "properties", []);
    this.reset();
  }
  addProperty(key, value) {
    this.properties.push({
      key,
      value
    });
    return this;
  }
  build() {
    const properties = this.properties;
    this.reset();
    return properties;
  }
  reset() {
    this.properties = [];
  }
};
var FileBuilder = class {
  constructor() {
    _defineProperty(this, "files", []);
    this.reset();
  }
  addFile(name, url) {
    this.files.push({
      name,
      url
    });
    return this;
  }
  build() {
    const files = this.files;
    this.reset();
    return files;
  }
  reset() {
    this.files = [];
  }
};

// node_modules/@empower-plastic/empowerjs/module/plastic-credit-marketplace/PlasticCreditMarketplace.types.js
var PlasticCreditMarketplace_types_exports = {};

// node_modules/@empower-plastic/empowerjs/module/plastic-credit-marketplace/PlasticCreditMarketplace.client.js
var PlasticCreditMarketplace_client_exports = {};
__export(PlasticCreditMarketplace_client_exports, {
  PlasticCreditMarketplaceClient: () => PlasticCreditMarketplaceClient,
  PlasticCreditMarketplaceQueryClient: () => PlasticCreditMarketplaceQueryClient
});
var PlasticCreditMarketplaceQueryClient = class {
  constructor(client, contractAddress) {
    _defineProperty(this, "client", void 0);
    _defineProperty(this, "contractAddress", void 0);
    _defineProperty(this, "listings", async ({
      limit,
      startAfter
    }) => {
      return this.client.queryContractSmart(this.contractAddress, {
        listings: {
          limit,
          start_after: startAfter
        }
      });
    });
    _defineProperty(this, "listing", async ({
      denom,
      owner
    }) => {
      return this.client.queryContractSmart(this.contractAddress, {
        listing: {
          denom,
          owner
        }
      });
    });
    _defineProperty(this, "feeSplitConfig", async () => {
      return this.client.queryContractSmart(this.contractAddress, {
        fee_split_config: {}
      });
    });
    _defineProperty(this, "price", async ({
      denom,
      numberOfCreditsToBuy,
      owner
    }) => {
      return this.client.queryContractSmart(this.contractAddress, {
        price: {
          denom,
          number_of_credits_to_buy: numberOfCreditsToBuy,
          owner
        }
      });
    });
    this.client = client;
    this.contractAddress = contractAddress;
    this.listings = this.listings.bind(this);
    this.listing = this.listing.bind(this);
    this.feeSplitConfig = this.feeSplitConfig.bind(this);
    this.price = this.price.bind(this);
  }
};
var PlasticCreditMarketplaceClient = class extends PlasticCreditMarketplaceQueryClient {
  constructor(client, sender, contractAddress) {
    super(client, contractAddress);
    _defineProperty(this, "client", void 0);
    _defineProperty(this, "sender", void 0);
    _defineProperty(this, "contractAddress", void 0);
    _defineProperty(this, "createListing", async ({
      denom,
      numberOfCredits,
      operator,
      pricePerCredit
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        create_listing: {
          denom,
          number_of_credits: numberOfCredits,
          operator,
          price_per_credit: pricePerCredit
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "updateListing", async ({
      denom,
      numberOfCredits,
      pricePerCredit
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        update_listing: {
          denom,
          number_of_credits: numberOfCredits,
          price_per_credit: pricePerCredit
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "buyCredits", async ({
      denom,
      numberOfCreditsToBuy,
      owner,
      retire,
      retiringEntityAdditionalData,
      retiringEntityName
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        buy_credits: {
          denom,
          number_of_credits_to_buy: numberOfCreditsToBuy,
          owner,
          retire,
          retiring_entity_additional_data: retiringEntityAdditionalData,
          retiring_entity_name: retiringEntityName
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "cancelListing", async ({
      denom
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        cancel_listing: {
          denom
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "freezeCredits", async ({
      buyer,
      denom,
      numberOfCreditsToFreeze,
      owner,
      timeoutUnixTimestamp
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        freeze_credits: {
          buyer,
          denom,
          number_of_credits_to_freeze: numberOfCreditsToFreeze,
          owner,
          timeout_unix_timestamp: timeoutUnixTimestamp
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "cancelFrozenCredits", async ({
      buyer,
      denom,
      numberOfFrozenCreditsToCancel,
      owner
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        cancel_frozen_credits: {
          buyer,
          denom,
          number_of_frozen_credits_to_cancel: numberOfFrozenCreditsToCancel,
          owner
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "releaseFrozenCredits", async ({
      buyer,
      denom,
      numberOfCreditsToRelease,
      owner,
      retire,
      retiringEntityAdditionalData,
      retiringEntityName
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        release_frozen_credits: {
          buyer,
          denom,
          number_of_credits_to_release: numberOfCreditsToRelease,
          owner,
          retire,
          retiring_entity_additional_data: retiringEntityAdditionalData,
          retiring_entity_name: retiringEntityName
        }
      }, fee, memo, funds);
    });
    _defineProperty(this, "editFeeSplitConfig", async ({
      feePercentage,
      shares
    }, fee = "auto", memo, funds) => {
      return await this.client.execute(this.sender, this.contractAddress, {
        edit_fee_split_config: {
          fee_percentage: feePercentage,
          shares
        }
      }, fee, memo, funds);
    });
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createListing = this.createListing.bind(this);
    this.updateListing = this.updateListing.bind(this);
    this.buyCredits = this.buyCredits.bind(this);
    this.cancelListing = this.cancelListing.bind(this);
    this.freezeCredits = this.freezeCredits.bind(this);
    this.cancelFrozenCredits = this.cancelFrozenCredits.bind(this);
    this.releaseFrozenCredits = this.releaseFrozenCredits.bind(this);
    this.editFeeSplitConfig = this.editFeeSplitConfig.bind(this);
  }
};

// node_modules/@empower-plastic/empowerjs/module/plastic-credit-marketplace/index.js
function ownKeys14(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread14(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys14(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys14(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var contracts;
(function(_contracts) {
  const PlasticCreditMarketplace = _contracts.PlasticCreditMarketplace = _objectSpread14(_objectSpread14({}, PlasticCreditMarketplace_types_exports), PlasticCreditMarketplace_client_exports);
})(contracts || (contracts = {}));

// node_modules/@empower-plastic/empowerjs/module/utils/signing-client.js
var import_stargate9 = __toESM(require_build8());
var import_cosmwasm_stargate = __toESM(require_build9());
var import_tendermint_rpc5 = __toESM(require_build7());
var import_math = __toESM(require_build3());
var getSigningTM37EmpowerchainClient = async ({
  rpcEndpoint,
  signer,
  defaultTypes = import_stargate9.defaultRegistryTypes,
  gasPrice = {
    amount: import_math.Decimal.fromAtomics("25", 6),
    denom: "umpwr"
  }
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningEmpowerchainClientOptions({
    defaultTypes
  });
  const tm37Client = await import_tendermint_rpc5.Tendermint37Client.connect(rpcEndpoint);
  const client = await import_stargate9.SigningStargateClient.createWithSigner(tm37Client, signer, {
    registry: registry28,
    aminoTypes,
    gasPrice
  });
  return client;
};
var getSigningCosmWasmTM37EmpowerchainClient = async ({
  rpcEndpoint,
  signer,
  defaultTypes = import_stargate9.defaultRegistryTypes,
  gasPrice = {
    amount: import_math.Decimal.fromAtomics("25", 6),
    denom: "umpwr"
  }
}) => {
  const {
    registry: registry28,
    aminoTypes
  } = getSigningEmpowerchainClientOptions({
    defaultTypes
  });
  const tm37Client = await import_tendermint_rpc5.Tendermint37Client.connect(rpcEndpoint);
  const client = await import_cosmwasm_stargate.SigningCosmWasmClient.createWithSigner(tm37Client, signer, {
    registry: registry28,
    aminoTypes,
    gasPrice
  });
  return client;
};
export {
  ApplicantBuilder,
  EventBuilder,
  FileBuilder,
  MaterialPropertyBuilder,
  PlasticCreditBuilder,
  amino,
  contracts,
  cosmos,
  cosmosAminoConverters,
  cosmosProtoRegistry,
  cosmos_proto,
  cosmwasm,
  cosmwasmAminoConverters,
  cosmwasmProtoRegistry,
  empowerchain,
  empowerchainAminoConverters,
  empowerchainProtoRegistry,
  getSigningCosmWasmTM37EmpowerchainClient,
  getSigningCosmosClient,
  getSigningCosmosClientOptions,
  getSigningCosmwasmClient,
  getSigningCosmwasmClientOptions,
  getSigningEmpowerchainClient,
  getSigningEmpowerchainClientOptions,
  getSigningIbcClient,
  getSigningIbcClientOptions,
  getSigningTM37EmpowerchainClient,
  gogoproto,
  google,
  ibc,
  ibcAminoConverters,
  ibcProtoRegistry,
  tendermint
};
//# sourceMappingURL=@empower-plastic_empowerjs.js.map
