{
  "version": 3,
  "sources": ["../../node_modules/@empower-plastic/empowerjs/module/codegen/google/protobuf/duration.js"],
  "sourcesContent": ["import * as _m0 from \"protobufjs/minimal\";\nimport { Long, isSet } from \"../../helpers\";\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n * \n * # Examples\n * \n * Example 1: Compute Duration from two Timestamps in pseudo code.\n * \n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n * \n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n * \n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (durations.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n * \n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n * \n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n * \n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n * \n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n * \n * Example 3: Compute Duration from datetime.timedelta in Python.\n * \n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n * \n * # JSON Mapping\n * \n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n */\n\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n * \n * # Examples\n * \n * Example 1: Compute Duration from two Timestamps in pseudo code.\n * \n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n * \n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n * \n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (durations.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n * \n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n * \n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n * \n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n * \n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n * \n * Example 3: Compute Duration from datetime.timedelta in Python.\n * \n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n * \n * # JSON Mapping\n * \n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n */\n\nfunction createBaseDuration() {\n  return {\n    seconds: BigInt(\"0\"),\n    nanos: 0\n  };\n}\nexport const Duration = {\n  encode(message, writer = _m0.Writer.create()) {\n    if (message.seconds !== BigInt(0)) {\n      writer.uint32(8).int64(Long.fromString(message.seconds.toString()));\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDuration();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = BigInt(reader.int64().toString());\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      seconds: isSet(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(\"0\"),\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.seconds !== undefined && (obj.seconds = (message.seconds || BigInt(\"0\")).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n  fromPartial(object) {\n    var _object$nanos;\n    const message = createBaseDuration();\n    message.seconds = object.seconds !== undefined && object.seconds !== null ? BigInt(object.seconds.toString()) : BigInt(\"0\");\n    message.nanos = (_object$nanos = object.nanos) !== null && _object$nanos !== void 0 ? _object$nanos : 0;\n    return message;\n  }\n};"],
  "mappings": ";;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,UAAqB;AA4HrB,SAAS,qBAAqB;AAC5B,SAAO;AAAA,IACL,SAAS,OAAO,GAAG;AAAA,IACnB,OAAO;AAAA,EACT;AACF;AACO,IAAM,WAAW;AAAA,EACtB,OAAO,SAAS,SAAa,WAAO,OAAO,GAAG;AAC5C,QAAI,QAAQ,YAAY,OAAO,CAAC,GAAG;AACjC,aAAO,OAAO,CAAC,EAAE,MAAM,YAAAA,QAAK,WAAW,QAAQ,QAAQ,SAAS,CAAC,CAAC;AAAA,IACpE;AACA,QAAI,QAAQ,UAAU,GAAG;AACvB,aAAO,OAAO,EAAE,EAAE,MAAM,QAAQ,KAAK;AAAA,IACvC;AACA,WAAO;AAAA,EACT;AAAA,EACA,OAAO,OAAO,QAAQ;AACpB,UAAM,SAAS,iBAAqB,aAAS,QAAQ,IAAQ,WAAO,KAAK;AACzE,QAAI,MAAM,WAAW,SAAY,OAAO,MAAM,OAAO,MAAM;AAC3D,UAAM,UAAU,mBAAmB;AACnC,WAAO,OAAO,MAAM,KAAK;AACvB,YAAM,MAAM,OAAO,OAAO;AAC1B,cAAQ,QAAQ,GAAG;AAAA,QACjB,KAAK;AACH,kBAAQ,UAAU,OAAO,OAAO,MAAM,EAAE,SAAS,CAAC;AAClD;AAAA,QACF,KAAK;AACH,kBAAQ,QAAQ,OAAO,MAAM;AAC7B;AAAA,QACF;AACE,iBAAO,SAAS,MAAM,CAAC;AACvB;AAAA,MACJ;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,SAAS,QAAQ;AACf,WAAO;AAAA,MACL,SAAS,MAAM,OAAO,OAAO,IAAI,OAAO,OAAO,QAAQ,SAAS,CAAC,IAAI,OAAO,GAAG;AAAA,MAC/E,OAAO,MAAM,OAAO,KAAK,IAAI,OAAO,OAAO,KAAK,IAAI;AAAA,IACtD;AAAA,EACF;AAAA,EACA,OAAO,SAAS;AACd,UAAM,MAAM,CAAC;AACb,YAAQ,YAAY,WAAc,IAAI,WAAW,QAAQ,WAAW,OAAO,GAAG,GAAG,SAAS;AAC1F,YAAQ,UAAU,WAAc,IAAI,QAAQ,KAAK,MAAM,QAAQ,KAAK;AACpE,WAAO;AAAA,EACT;AAAA,EACA,YAAY,QAAQ;AAClB,QAAI;AACJ,UAAM,UAAU,mBAAmB;AACnC,YAAQ,UAAU,OAAO,YAAY,UAAa,OAAO,YAAY,OAAO,OAAO,OAAO,QAAQ,SAAS,CAAC,IAAI,OAAO,GAAG;AAC1H,YAAQ,SAAS,gBAAgB,OAAO,WAAW,QAAQ,kBAAkB,SAAS,gBAAgB;AACtG,WAAO;AAAA,EACT;AACF;",
  "names": ["Long"]
}
